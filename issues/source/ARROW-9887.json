{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13325201",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201",
    "key": "ARROW-9887",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12345977",
                "id": "12345977",
                "description": "",
                "name": "2.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-10-19"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jorgecarleitao",
            "name": "jorgecarleitao",
            "key": "jorgecarleitao",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jorgecarleitao&avatarId=43827",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jorgecarleitao&avatarId=43827",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jorgecarleitao&avatarId=43827",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jorgecarleitao&avatarId=43827"
            },
            "displayName": "Jorge Leit\u00e3o",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 5400,
            "total": 5400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9887/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 9,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao opened a new pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080\n\n\n   @alamb and @andygrove , I was able to split #8032 in two, so that they address different problems. This PR is specific to the problem that we have been discussing in #7967. It offers a solution that covers the three main cases:\r\n   \r\n   * single return type, such as `sqrt -> f64`\r\n   * finite set of return types, such as `concat` (utf8 and largeUTF8)\r\n   * potentially infinite set of return types, such as `array` (Array of any primitive or non-primitive type)\r\n   \r\n   I believe that this implementation is closer to option 1 that @alamb enumerated here. It is so because so far I was unable to offer an implementation for option 3, because functions such as `array` have an arbitrary return type (it can be any valid type, primitive or non-primitive), and thus we can't write them as `array_TYPE` as the number of cases is potentially large.\r\n   \r\n   ---------------\r\n   \r\n   This PR is exclusive to *built-in functions* of variable return type and it does not care about UDFs. It addresses a limitation of our current logical planning, that has been thoroughly discussed in #8032 and #7967, that logical planning needs to specify a specific return type when planning usage of UDFs and built-in functions (details below).\r\n   \r\n   Notation: `return type function`: a function mapping the functions' argument types to its return type. E.g. `(utf8) -> utf8; (LargeUtf8) -> LargeUtf8;` is an example of the signature of a typical one argument string function.\r\n   \r\n   The primary difference between built-ins and UDFs is that built-in's return type function is always known (hard-coded), while the return type function of a UDF is known by accessing the registry where it is registered on (it is a non-static closure).\r\n   \r\n   This PR is required to address an incompatibility of the following requirements that I gathered from discussions between @alamb, @andygrove and @jorgecarleitao:\r\n   \r\n   1. we want to have typing information during logical planning (see [here](https://docs.google.com/document/d/1Kzz642ScizeKXmVE1bBlbLvR663BKQaGqVIyy9cAscY/edit?disco=AAAAJ4XOjHk))\r\n   2. we want to have functions that require their return type to depend on their input. Examples include `array` (any type to any other type) and `concatenate` (`utf8 -> utf8`, `largeutf8 -> largeutf8`), and many others (see [here](https://github.com/apache/arrow/pull/7967#issuecomment-682832105))\r\n   3. we would like users to plan built-in functions without accessing the registry (see [here](https://github.com/apache/arrow/pull/8032#issuecomment-679327189) and mailing list)\r\n   4. a UDFs return type function needs to be retrieved from the registry (`ExecutionContextState`).\r\n   5. Currently, all our built-in functions are declared as UDFs and registered on the registry when the context is initialized.\r\n   \r\n   These points are incompatible because:\r\n   \r\n   * 1. and 2. requires access to built-in function's return type function during planning\r\n   * 4. and 5. requires access the registry to know the built-in's return type\r\n   * 3. forbids us from accessing the registry during planning\r\n   \r\n   This PR solves this incompatibility by leveraging the following:\r\n   \r\n   * builtin functions have a well declared return type during planning, since they are part of the source code\r\n   * builtin functions do not need to be in our function's registry\r\n   \r\n   The first commit in this PR makes the existing logical node `Expr::ScalarFunction` to be exclusive for built-in functions, and moves our UDF planning logic to a new node named `Expr::ScalarUDF`. It also makes the planning of built-in functions to no longer require access the registry.\r\n   \r\n   The second commit in this PR introduces the necessary functionality for built-in functions to support all types of complex signatures. Examples of usage of this functionality are in the following PRs:\r\n   \r\n   1. add support for math functions that accept f32: https://github.com/jorgecarleitao/arrow/pull/4/files\r\n   2. add `concat`, of an arbitrary number of arguments of type utf8: https://github.com/jorgecarleitao/arrow/pull/5/files\r\n   3. add `array` function, supporting an arbitrary number of arguments with uniform types: https://github.com/jorgecarleitao/arrow/pull/6/files\r\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-30T10:53:46.465+0000",
                    "updated": "2020-08-30T10:53:46.465+0000",
                    "started": "2020-08-30T10:53:46.465+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476217",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476222",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#issuecomment-683406784\n\n\n   https://issues.apache.org/jira/browse/ARROW-9887\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-30T11:06:38.639+0000",
                    "updated": "2020-08-30T11:06:38.639+0000",
                    "started": "2020-08-30T11:06:38.639+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476222",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476226",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r479755529\n\n\n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -0,0 +1,319 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Declaration of built-in (scalar) functions.\n+//! This module contains built-in functions' enumeration and metadata.\n+//!\n+//! Generally, a function has:\n+//! * a set of valid argument types\n+//! * a return type function of an incoming argument types\n+//! * the computation valid for all sets of valid argument types\n+//!\n+//! * Argument types: the number of arguments and set of valid types. For example, [[f32, f32], [f64, f64]] is a function of two arguments only accepting f32 or f64 on each of its arguments.\n+//! * Return type: a function `(arg_types) -> return_type`. E.g. for sqrt, ([f32]) -> f32, ([f64]) -> f64.\n+//!\n+//! Currently, this implementation supports only a single argument and a single signature.\n+//!\n+//! This module also has a set of coercion rules to improve user experience: if an argument i32 is passed\n+//! to a function that supports f64, it is coerced to f64.\n+\n+use super::{\n+    expressions::{cast, is_numeric},\n+    PhysicalExpr,\n+};\n+use crate::error::{ExecutionError, Result};\n+use crate::execution::physical_plan::math_expressions;\n+use crate::execution::physical_plan::udf;\n+use arrow::{\n+    compute::kernels::length::length,\n+    datatypes::{DataType, Schema},\n+};\n+use std::{fmt, str::FromStr, sync::Arc};\n+use udf::ScalarUdf;\n+\n+/// Enum of all built-in scalar functions\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ScalarFunction {\n+    /// sqrt\n+    Sqrt,\n+    /// sin\n+    Sin,\n+    /// cos\n+    Cos,\n+    /// tan\n+    Tan,\n+    /// asin\n+    Asin,\n+    /// acos\n+    Acos,\n+    /// atan\n+    Atan,\n+    /// exp\n+    Exp,\n+    /// log, also known as ln\n+    Log,\n+    /// log2\n+    Log2,\n+    /// log10\n+    Log10,\n+    /// floor\n+    Floor,\n+    /// ceil\n+    Ceil,\n+    /// round\n+    Round,\n+    /// trunc\n+    Trunc,\n+    /// abs\n+    Abs,\n+    /// signum\n+    Signum,\n+    /// length\n+    Length,\n+}\n+\n+impl fmt::Display for ScalarFunction {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // lowercase of the debug.\n+        write!(f, \"{}\", format!(\"{:?}\", self).to_lowercase())\n+    }\n+}\n+\n+impl FromStr for ScalarFunction {\n+    type Err = ExecutionError;\n+    fn from_str(name: &str) -> Result<ScalarFunction> {\n+        Ok(match name {\n+            \"sqrt\" => ScalarFunction::Sqrt,\n+            \"sin\" => ScalarFunction::Sin,\n+            \"cos\" => ScalarFunction::Cos,\n+            \"tan\" => ScalarFunction::Tan,\n+            \"asin\" => ScalarFunction::Asin,\n+            \"acos\" => ScalarFunction::Acos,\n+            \"atan\" => ScalarFunction::Atan,\n+            \"exp\" => ScalarFunction::Exp,\n+            \"log\" => ScalarFunction::Log,\n+            \"log2\" => ScalarFunction::Log2,\n+            \"log10\" => ScalarFunction::Log10,\n+            \"floor\" => ScalarFunction::Floor,\n+            \"ceil\" => ScalarFunction::Ceil,\n+            \"round\" => ScalarFunction::Round,\n+            \"truc\" => ScalarFunction::Trunc,\n+            \"abs\" => ScalarFunction::Abs,\n+            \"signum\" => ScalarFunction::Signum,\n+            \"length\" => ScalarFunction::Length,\n+            _ => {\n+                return Err(ExecutionError::General(format!(\n+                    \"There is no built-in function named {}\",\n+                    name\n+                )))\n+            }\n+        })\n+    }\n+}\n+\n+/// Returns the datatype of the scalar function\n+pub fn return_type(fun: &ScalarFunction, arg_types: &Vec<DataType>) -> Result<DataType> {\n+    // Note that this function *must* return the same type that the respective physical expression returns\n+    // or the execution panics.\n+\n+    if arg_types.len() != 1 {\n+        // for now, every function expects a single argument, and thus this is enough\n+        return Err(ExecutionError::General(format!(\n+            \"The function \\\"{}\\\" expected 1 argument, but received \\\"{}\\\"\",\n+            fun,\n+            arg_types.len()\n+        )));\n+    }\n+\n+    // verify that this is a valid type for this function\n+    coerce(fun, &arg_types[0])?;\n+\n+    // the return type after coercion.\n+    // for now, this is type-independent, but there will be built-in functions whose return type\n\nReview comment:\n       ```suggestion\r\n       // for now, this is type-independent, but there may be built-in functions whose return type\r\n   ```\n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -0,0 +1,319 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Declaration of built-in (scalar) functions.\n+//! This module contains built-in functions' enumeration and metadata.\n+//!\n+//! Generally, a function has:\n+//! * a set of valid argument types\n+//! * a return type function of an incoming argument types\n+//! * the computation valid for all sets of valid argument types\n+//!\n+//! * Argument types: the number of arguments and set of valid types. For example, [[f32, f32], [f64, f64]] is a function of two arguments only accepting f32 or f64 on each of its arguments.\n+//! * Return type: a function `(arg_types) -> return_type`. E.g. for sqrt, ([f32]) -> f32, ([f64]) -> f64.\n+//!\n+//! Currently, this implementation supports only a single argument and a single signature.\n+//!\n+//! This module also has a set of coercion rules to improve user experience: if an argument i32 is passed\n+//! to a function that supports f64, it is coerced to f64.\n+\n+use super::{\n+    expressions::{cast, is_numeric},\n+    PhysicalExpr,\n+};\n+use crate::error::{ExecutionError, Result};\n+use crate::execution::physical_plan::math_expressions;\n+use crate::execution::physical_plan::udf;\n+use arrow::{\n+    compute::kernels::length::length,\n+    datatypes::{DataType, Schema},\n+};\n+use std::{fmt, str::FromStr, sync::Arc};\n+use udf::ScalarUdf;\n+\n+/// Enum of all built-in scalar functions\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ScalarFunction {\n+    /// sqrt\n+    Sqrt,\n+    /// sin\n+    Sin,\n+    /// cos\n+    Cos,\n+    /// tan\n+    Tan,\n+    /// asin\n+    Asin,\n+    /// acos\n+    Acos,\n+    /// atan\n+    Atan,\n+    /// exp\n+    Exp,\n+    /// log, also known as ln\n+    Log,\n+    /// log2\n+    Log2,\n+    /// log10\n+    Log10,\n+    /// floor\n+    Floor,\n+    /// ceil\n+    Ceil,\n+    /// round\n+    Round,\n+    /// trunc\n+    Trunc,\n+    /// abs\n+    Abs,\n+    /// signum\n+    Signum,\n+    /// length\n+    Length,\n+}\n+\n+impl fmt::Display for ScalarFunction {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // lowercase of the debug.\n+        write!(f, \"{}\", format!(\"{:?}\", self).to_lowercase())\n+    }\n+}\n+\n+impl FromStr for ScalarFunction {\n+    type Err = ExecutionError;\n+    fn from_str(name: &str) -> Result<ScalarFunction> {\n+        Ok(match name {\n+            \"sqrt\" => ScalarFunction::Sqrt,\n+            \"sin\" => ScalarFunction::Sin,\n+            \"cos\" => ScalarFunction::Cos,\n+            \"tan\" => ScalarFunction::Tan,\n+            \"asin\" => ScalarFunction::Asin,\n+            \"acos\" => ScalarFunction::Acos,\n+            \"atan\" => ScalarFunction::Atan,\n+            \"exp\" => ScalarFunction::Exp,\n+            \"log\" => ScalarFunction::Log,\n+            \"log2\" => ScalarFunction::Log2,\n+            \"log10\" => ScalarFunction::Log10,\n+            \"floor\" => ScalarFunction::Floor,\n+            \"ceil\" => ScalarFunction::Ceil,\n+            \"round\" => ScalarFunction::Round,\n+            \"truc\" => ScalarFunction::Trunc,\n+            \"abs\" => ScalarFunction::Abs,\n+            \"signum\" => ScalarFunction::Signum,\n+            \"length\" => ScalarFunction::Length,\n+            _ => {\n+                return Err(ExecutionError::General(format!(\n+                    \"There is no built-in function named {}\",\n+                    name\n+                )))\n+            }\n+        })\n+    }\n+}\n+\n+/// Returns the datatype of the scalar function\n+pub fn return_type(fun: &ScalarFunction, arg_types: &Vec<DataType>) -> Result<DataType> {\n+    // Note that this function *must* return the same type that the respective physical expression returns\n+    // or the execution panics.\n+\n+    if arg_types.len() != 1 {\n+        // for now, every function expects a single argument, and thus this is enough\n+        return Err(ExecutionError::General(format!(\n+            \"The function \\\"{}\\\" expected 1 argument, but received \\\"{}\\\"\",\n+            fun,\n+            arg_types.len()\n+        )));\n+    }\n+\n+    // verify that this is a valid type for this function\n+    coerce(fun, &arg_types[0])?;\n+\n+    // the return type after coercion.\n+    // for now, this is type-independent, but there will be built-in functions whose return type\n+    // depends on the incoming type.\n+    match fun {\n+        ScalarFunction::Length => Ok(DataType::UInt32),\n+        _ => Ok(DataType::Float64),\n+    }\n+}\n+\n+/// Create a physical (function) expression.\n+/// This function errors when `args`' can't be coerced to a valid argument type of the function.\n+pub fn function(\n+    fun: &ScalarFunction,\n+    args: &Vec<Arc<dyn PhysicalExpr>>,\n+    input_schema: &Schema,\n+) -> Result<Arc<dyn PhysicalExpr>> {\n+    let fun_expr: ScalarUdf = Arc::new(match fun {\n+        ScalarFunction::Sqrt => math_expressions::sqrt,\n+        ScalarFunction::Sin => math_expressions::sin,\n+        ScalarFunction::Cos => math_expressions::cos,\n+        ScalarFunction::Tan => math_expressions::tan,\n+        ScalarFunction::Asin => math_expressions::asin,\n+        ScalarFunction::Acos => math_expressions::acos,\n+        ScalarFunction::Atan => math_expressions::atan,\n+        ScalarFunction::Exp => math_expressions::exp,\n+        ScalarFunction::Log => math_expressions::ln,\n+        ScalarFunction::Log2 => math_expressions::log2,\n+        ScalarFunction::Log10 => math_expressions::log10,\n+        ScalarFunction::Floor => math_expressions::floor,\n+        ScalarFunction::Ceil => math_expressions::ceil,\n+        ScalarFunction::Round => math_expressions::round,\n+        ScalarFunction::Trunc => math_expressions::trunc,\n+        ScalarFunction::Abs => math_expressions::abs,\n+        ScalarFunction::Signum => math_expressions::signum,\n+        ScalarFunction::Length => |args| Ok(Arc::new(length(args[0].as_ref())?)),\n+    });\n+    let data_types = args\n+        .iter()\n+        .map(|e| e.data_type(input_schema))\n+        .collect::<Result<Vec<_>>>()?;\n+\n+    // coerce type\n+    // for now, this supports a single type.\n+    assert!(args.len() == 1);\n+    assert!(data_types.len() == 1);\n+    let arg_type = coerce(fun, &data_types[0])?;\n+    let args = vec![cast(args[0].clone(), input_schema, arg_type.clone())?];\n+\n+    Ok(Arc::new(udf::ScalarFunctionExpr::new(\n+        &format!(\"{}\", fun),\n+        fun_expr,\n+        args,\n+        &return_type(&fun, &vec![arg_type])?,\n+    )))\n+}\n+\n+/// the type supported by the function `fun`.\n+fn valid_type(fun: &ScalarFunction) -> DataType {\n\nReview comment:\n       ```suggestion\r\n   fn argument_type(fun: &ScalarFunction) -> DataType {\r\n   ```\r\n   \r\n   \n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -0,0 +1,319 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Declaration of built-in (scalar) functions.\n+//! This module contains built-in functions' enumeration and metadata.\n+//!\n+//! Generally, a function has:\n+//! * a set of valid argument types\n+//! * a return type function of an incoming argument types\n+//! * the computation valid for all sets of valid argument types\n+//!\n+//! * Argument types: the number of arguments and set of valid types. For example, [[f32, f32], [f64, f64]] is a function of two arguments only accepting f32 or f64 on each of its arguments.\n+//! * Return type: a function `(arg_types) -> return_type`. E.g. for sqrt, ([f32]) -> f32, ([f64]) -> f64.\n+//!\n+//! Currently, this implementation supports only a single argument and a single signature.\n+//!\n+//! This module also has a set of coercion rules to improve user experience: if an argument i32 is passed\n+//! to a function that supports f64, it is coerced to f64.\n+\n+use super::{\n+    expressions::{cast, is_numeric},\n+    PhysicalExpr,\n+};\n+use crate::error::{ExecutionError, Result};\n+use crate::execution::physical_plan::math_expressions;\n+use crate::execution::physical_plan::udf;\n+use arrow::{\n+    compute::kernels::length::length,\n+    datatypes::{DataType, Schema},\n+};\n+use std::{fmt, str::FromStr, sync::Arc};\n+use udf::ScalarUdf;\n+\n+/// Enum of all built-in scalar functions\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ScalarFunction {\n+    /// sqrt\n+    Sqrt,\n+    /// sin\n+    Sin,\n+    /// cos\n+    Cos,\n+    /// tan\n+    Tan,\n+    /// asin\n+    Asin,\n+    /// acos\n+    Acos,\n+    /// atan\n+    Atan,\n+    /// exp\n+    Exp,\n+    /// log, also known as ln\n+    Log,\n+    /// log2\n+    Log2,\n+    /// log10\n+    Log10,\n+    /// floor\n+    Floor,\n+    /// ceil\n+    Ceil,\n+    /// round\n+    Round,\n+    /// trunc\n+    Trunc,\n+    /// abs\n+    Abs,\n+    /// signum\n+    Signum,\n+    /// length\n+    Length,\n+}\n+\n+impl fmt::Display for ScalarFunction {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // lowercase of the debug.\n+        write!(f, \"{}\", format!(\"{:?}\", self).to_lowercase())\n+    }\n+}\n+\n+impl FromStr for ScalarFunction {\n+    type Err = ExecutionError;\n+    fn from_str(name: &str) -> Result<ScalarFunction> {\n+        Ok(match name {\n+            \"sqrt\" => ScalarFunction::Sqrt,\n+            \"sin\" => ScalarFunction::Sin,\n+            \"cos\" => ScalarFunction::Cos,\n+            \"tan\" => ScalarFunction::Tan,\n+            \"asin\" => ScalarFunction::Asin,\n+            \"acos\" => ScalarFunction::Acos,\n+            \"atan\" => ScalarFunction::Atan,\n+            \"exp\" => ScalarFunction::Exp,\n+            \"log\" => ScalarFunction::Log,\n+            \"log2\" => ScalarFunction::Log2,\n+            \"log10\" => ScalarFunction::Log10,\n+            \"floor\" => ScalarFunction::Floor,\n+            \"ceil\" => ScalarFunction::Ceil,\n+            \"round\" => ScalarFunction::Round,\n+            \"truc\" => ScalarFunction::Trunc,\n+            \"abs\" => ScalarFunction::Abs,\n+            \"signum\" => ScalarFunction::Signum,\n+            \"length\" => ScalarFunction::Length,\n+            _ => {\n+                return Err(ExecutionError::General(format!(\n+                    \"There is no built-in function named {}\",\n+                    name\n+                )))\n+            }\n+        })\n+    }\n+}\n+\n+/// Returns the datatype of the scalar function\n+pub fn return_type(fun: &ScalarFunction, arg_types: &Vec<DataType>) -> Result<DataType> {\n+    // Note that this function *must* return the same type that the respective physical expression returns\n+    // or the execution panics.\n+\n+    if arg_types.len() != 1 {\n+        // for now, every function expects a single argument, and thus this is enough\n+        return Err(ExecutionError::General(format!(\n+            \"The function \\\"{}\\\" expected 1 argument, but received \\\"{}\\\"\",\n+            fun,\n+            arg_types.len()\n+        )));\n+    }\n+\n+    // verify that this is a valid type for this function\n+    coerce(fun, &arg_types[0])?;\n+\n+    // the return type after coercion.\n+    // for now, this is type-independent, but there will be built-in functions whose return type\n+    // depends on the incoming type.\n+    match fun {\n+        ScalarFunction::Length => Ok(DataType::UInt32),\n+        _ => Ok(DataType::Float64),\n+    }\n+}\n+\n+/// Create a physical (function) expression.\n+/// This function errors when `args`' can't be coerced to a valid argument type of the function.\n+pub fn function(\n\nReview comment:\n       ```suggestion\r\n   pub fn to_physical_expr(\r\n   ```\r\n   \r\n   I personally find `function` to be a little confusing as the term is so generic and could apply to many things\n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -0,0 +1,319 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Declaration of built-in (scalar) functions.\n+//! This module contains built-in functions' enumeration and metadata.\n+//!\n+//! Generally, a function has:\n+//! * a set of valid argument types\n+//! * a return type function of an incoming argument types\n+//! * the computation valid for all sets of valid argument types\n+//!\n+//! * Argument types: the number of arguments and set of valid types. For example, [[f32, f32], [f64, f64]] is a function of two arguments only accepting f32 or f64 on each of its arguments.\n+//! * Return type: a function `(arg_types) -> return_type`. E.g. for sqrt, ([f32]) -> f32, ([f64]) -> f64.\n+//!\n+//! Currently, this implementation supports only a single argument and a single signature.\n+//!\n+//! This module also has a set of coercion rules to improve user experience: if an argument i32 is passed\n+//! to a function that supports f64, it is coerced to f64.\n+\n+use super::{\n+    expressions::{cast, is_numeric},\n+    PhysicalExpr,\n+};\n+use crate::error::{ExecutionError, Result};\n+use crate::execution::physical_plan::math_expressions;\n+use crate::execution::physical_plan::udf;\n+use arrow::{\n+    compute::kernels::length::length,\n+    datatypes::{DataType, Schema},\n+};\n+use std::{fmt, str::FromStr, sync::Arc};\n+use udf::ScalarUdf;\n+\n+/// Enum of all built-in scalar functions\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ScalarFunction {\n+    /// sqrt\n+    Sqrt,\n+    /// sin\n+    Sin,\n+    /// cos\n+    Cos,\n+    /// tan\n+    Tan,\n+    /// asin\n+    Asin,\n+    /// acos\n+    Acos,\n+    /// atan\n+    Atan,\n+    /// exp\n+    Exp,\n+    /// log, also known as ln\n+    Log,\n+    /// log2\n+    Log2,\n+    /// log10\n+    Log10,\n+    /// floor\n+    Floor,\n+    /// ceil\n+    Ceil,\n+    /// round\n+    Round,\n+    /// trunc\n+    Trunc,\n+    /// abs\n+    Abs,\n+    /// signum\n+    Signum,\n+    /// length\n+    Length,\n+}\n+\n+impl fmt::Display for ScalarFunction {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // lowercase of the debug.\n+        write!(f, \"{}\", format!(\"{:?}\", self).to_lowercase())\n+    }\n+}\n+\n+impl FromStr for ScalarFunction {\n+    type Err = ExecutionError;\n+    fn from_str(name: &str) -> Result<ScalarFunction> {\n+        Ok(match name {\n+            \"sqrt\" => ScalarFunction::Sqrt,\n+            \"sin\" => ScalarFunction::Sin,\n+            \"cos\" => ScalarFunction::Cos,\n+            \"tan\" => ScalarFunction::Tan,\n+            \"asin\" => ScalarFunction::Asin,\n+            \"acos\" => ScalarFunction::Acos,\n+            \"atan\" => ScalarFunction::Atan,\n+            \"exp\" => ScalarFunction::Exp,\n+            \"log\" => ScalarFunction::Log,\n+            \"log2\" => ScalarFunction::Log2,\n+            \"log10\" => ScalarFunction::Log10,\n+            \"floor\" => ScalarFunction::Floor,\n+            \"ceil\" => ScalarFunction::Ceil,\n+            \"round\" => ScalarFunction::Round,\n+            \"truc\" => ScalarFunction::Trunc,\n+            \"abs\" => ScalarFunction::Abs,\n+            \"signum\" => ScalarFunction::Signum,\n+            \"length\" => ScalarFunction::Length,\n+            _ => {\n+                return Err(ExecutionError::General(format!(\n+                    \"There is no built-in function named {}\",\n+                    name\n+                )))\n+            }\n+        })\n+    }\n+}\n+\n+/// Returns the datatype of the scalar function\n+pub fn return_type(fun: &ScalarFunction, arg_types: &Vec<DataType>) -> Result<DataType> {\n+    // Note that this function *must* return the same type that the respective physical expression returns\n+    // or the execution panics.\n+\n+    if arg_types.len() != 1 {\n+        // for now, every function expects a single argument, and thus this is enough\n+        return Err(ExecutionError::General(format!(\n+            \"The function \\\"{}\\\" expected 1 argument, but received \\\"{}\\\"\",\n+            fun,\n+            arg_types.len()\n+        )));\n+    }\n+\n+    // verify that this is a valid type for this function\n+    coerce(fun, &arg_types[0])?;\n+\n+    // the return type after coercion.\n+    // for now, this is type-independent, but there will be built-in functions whose return type\n+    // depends on the incoming type.\n+    match fun {\n+        ScalarFunction::Length => Ok(DataType::UInt32),\n+        _ => Ok(DataType::Float64),\n+    }\n+}\n+\n+/// Create a physical (function) expression.\n+/// This function errors when `args`' can't be coerced to a valid argument type of the function.\n+pub fn function(\n+    fun: &ScalarFunction,\n+    args: &Vec<Arc<dyn PhysicalExpr>>,\n+    input_schema: &Schema,\n+) -> Result<Arc<dyn PhysicalExpr>> {\n+    let fun_expr: ScalarUdf = Arc::new(match fun {\n+        ScalarFunction::Sqrt => math_expressions::sqrt,\n+        ScalarFunction::Sin => math_expressions::sin,\n+        ScalarFunction::Cos => math_expressions::cos,\n+        ScalarFunction::Tan => math_expressions::tan,\n+        ScalarFunction::Asin => math_expressions::asin,\n+        ScalarFunction::Acos => math_expressions::acos,\n+        ScalarFunction::Atan => math_expressions::atan,\n+        ScalarFunction::Exp => math_expressions::exp,\n+        ScalarFunction::Log => math_expressions::ln,\n+        ScalarFunction::Log2 => math_expressions::log2,\n+        ScalarFunction::Log10 => math_expressions::log10,\n+        ScalarFunction::Floor => math_expressions::floor,\n+        ScalarFunction::Ceil => math_expressions::ceil,\n+        ScalarFunction::Round => math_expressions::round,\n+        ScalarFunction::Trunc => math_expressions::trunc,\n+        ScalarFunction::Abs => math_expressions::abs,\n+        ScalarFunction::Signum => math_expressions::signum,\n+        ScalarFunction::Length => |args| Ok(Arc::new(length(args[0].as_ref())?)),\n+    });\n+    let data_types = args\n+        .iter()\n+        .map(|e| e.data_type(input_schema))\n+        .collect::<Result<Vec<_>>>()?;\n+\n+    // coerce type\n+    // for now, this supports a single type.\n+    assert!(args.len() == 1);\n+    assert!(data_types.len() == 1);\n+    let arg_type = coerce(fun, &data_types[0])?;\n+    let args = vec![cast(args[0].clone(), input_schema, arg_type.clone())?];\n+\n+    Ok(Arc::new(udf::ScalarFunctionExpr::new(\n+        &format!(\"{}\", fun),\n+        fun_expr,\n+        args,\n+        &return_type(&fun, &vec![arg_type])?,\n+    )))\n+}\n+\n+/// the type supported by the function `fun`.\n\nReview comment:\n       ```suggestion\r\n   /// the type of argument required by the function `fun`.\r\n   ```\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -592,7 +607,7 @@ mod tests {\n     fn select_scalar_func_with_literal_no_relation() {\n         quick_test(\n             \"SELECT sqrt(9)\",\n-            \"Projection: sqrt(CAST(Int64(9) AS Float64))\\\n+            \"Projection: sqrt(Int64(9))\\\n\nReview comment:\n       This change would imply to me that `sqrt` can take an `int` which is not actually what happens, right? At some point something adds a `Cast` to float...\n\n##########\nFile path: rust/datafusion/src/logicalplan.rs\n##########\n@@ -190,7 +190,14 @@ fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n             let expr = create_name(expr, input_schema)?;\n             Ok(format!(\"CAST({} as {:?})\", expr, data_type))\n         }\n-        Expr::ScalarFunction { name, args, .. } => {\n+        Expr::ScalarFunction { fun, args, .. } => {\n+            let mut names = Vec::with_capacity(args.len());\n\nReview comment:\n       I don't know how much you care about using \"idomatic\" rust, but you can probably do the same kind of thing here with iterators:\r\n   \r\n   ```\r\n   let names = args.iter()\r\n     .map(|e| create_name(e, input_schema)\r\n     .collect::<Result<Vec_>>()?;\r\n   ```\n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -45,6 +43,22 @@ use arrow::{\n use std::{fmt, str::FromStr, sync::Arc};\n use udf::ScalarUdf;\n \n+/// A function's signature, which defines the function's supported argument types.\n+#[derive(Debug)]\n+pub enum Signature {\n+    /// arbitrary number of arguments of an uniform type out of a list of valid types\n+    // A function such as `concat` is `Many(vec![DataType::Utf8, DataType::LargeUtf8])`\n+    Many(Vec<DataType>),\n+    /// arbitrary number of arguments of an arbitrary but uniform type\n+    // A function such as `array` is `ManyUniform`\n+    // The first argument decides the type used for coercion\n+    ManyUniform,\n\nReview comment:\n       the idea of a `ManyUniform` number of arguments perhaps is what is making this so complicated. `ManyUniform` sounds a lot like the notion of \"varargs\" (variadic functions) from C (aka how you can do `printf(char *msg, ...)`, though that does not restrict to a single type. \n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -0,0 +1,319 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+//! Declaration of built-in (scalar) functions.\n+//! This module contains built-in functions' enumeration and metadata.\n+//!\n+//! Generally, a function has:\n+//! * a set of valid argument types\n+//! * a return type function of an incoming argument types\n+//! * the computation valid for all sets of valid argument types\n+//!\n+//! * Argument types: the number of arguments and set of valid types. For example, [[f32, f32], [f64, f64]] is a function of two arguments only accepting f32 or f64 on each of its arguments.\n+//! * Return type: a function `(arg_types) -> return_type`. E.g. for sqrt, ([f32]) -> f32, ([f64]) -> f64.\n+//!\n+//! Currently, this implementation supports only a single argument and a single signature.\n+//!\n+//! This module also has a set of coercion rules to improve user experience: if an argument i32 is passed\n+//! to a function that supports f64, it is coerced to f64.\n+\n+use super::{\n+    expressions::{cast, is_numeric},\n+    PhysicalExpr,\n+};\n+use crate::error::{ExecutionError, Result};\n+use crate::execution::physical_plan::math_expressions;\n+use crate::execution::physical_plan::udf;\n+use arrow::{\n+    compute::kernels::length::length,\n+    datatypes::{DataType, Schema},\n+};\n+use std::{fmt, str::FromStr, sync::Arc};\n+use udf::ScalarUdf;\n+\n+/// Enum of all built-in scalar functions\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum ScalarFunction {\n+    /// sqrt\n+    Sqrt,\n+    /// sin\n+    Sin,\n+    /// cos\n+    Cos,\n+    /// tan\n+    Tan,\n+    /// asin\n+    Asin,\n+    /// acos\n+    Acos,\n+    /// atan\n+    Atan,\n+    /// exp\n+    Exp,\n+    /// log, also known as ln\n+    Log,\n+    /// log2\n+    Log2,\n+    /// log10\n+    Log10,\n+    /// floor\n+    Floor,\n+    /// ceil\n+    Ceil,\n+    /// round\n+    Round,\n+    /// trunc\n+    Trunc,\n+    /// abs\n+    Abs,\n+    /// signum\n+    Signum,\n+    /// length\n+    Length,\n+}\n+\n+impl fmt::Display for ScalarFunction {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        // lowercase of the debug.\n+        write!(f, \"{}\", format!(\"{:?}\", self).to_lowercase())\n+    }\n+}\n+\n+impl FromStr for ScalarFunction {\n+    type Err = ExecutionError;\n+    fn from_str(name: &str) -> Result<ScalarFunction> {\n+        Ok(match name {\n+            \"sqrt\" => ScalarFunction::Sqrt,\n+            \"sin\" => ScalarFunction::Sin,\n+            \"cos\" => ScalarFunction::Cos,\n+            \"tan\" => ScalarFunction::Tan,\n+            \"asin\" => ScalarFunction::Asin,\n+            \"acos\" => ScalarFunction::Acos,\n+            \"atan\" => ScalarFunction::Atan,\n+            \"exp\" => ScalarFunction::Exp,\n+            \"log\" => ScalarFunction::Log,\n+            \"log2\" => ScalarFunction::Log2,\n+            \"log10\" => ScalarFunction::Log10,\n+            \"floor\" => ScalarFunction::Floor,\n+            \"ceil\" => ScalarFunction::Ceil,\n+            \"round\" => ScalarFunction::Round,\n+            \"truc\" => ScalarFunction::Trunc,\n+            \"abs\" => ScalarFunction::Abs,\n+            \"signum\" => ScalarFunction::Signum,\n+            \"length\" => ScalarFunction::Length,\n+            _ => {\n+                return Err(ExecutionError::General(format!(\n+                    \"There is no built-in function named {}\",\n+                    name\n+                )))\n+            }\n+        })\n+    }\n+}\n+\n+/// Returns the datatype of the scalar function\n+pub fn return_type(fun: &ScalarFunction, arg_types: &Vec<DataType>) -> Result<DataType> {\n+    // Note that this function *must* return the same type that the respective physical expression returns\n+    // or the execution panics.\n+\n+    if arg_types.len() != 1 {\n+        // for now, every function expects a single argument, and thus this is enough\n+        return Err(ExecutionError::General(format!(\n+            \"The function \\\"{}\\\" expected 1 argument, but received \\\"{}\\\"\",\n+            fun,\n+            arg_types.len()\n+        )));\n+    }\n+\n+    // verify that this is a valid type for this function\n+    coerce(fun, &arg_types[0])?;\n+\n+    // the return type after coercion.\n+    // for now, this is type-independent, but there will be built-in functions whose return type\n+    // depends on the incoming type.\n+    match fun {\n+        ScalarFunction::Length => Ok(DataType::UInt32),\n+        _ => Ok(DataType::Float64),\n+    }\n+}\n+\n+/// Create a physical (function) expression.\n+/// This function errors when `args`' can't be coerced to a valid argument type of the function.\n+pub fn function(\n+    fun: &ScalarFunction,\n+    args: &Vec<Arc<dyn PhysicalExpr>>,\n+    input_schema: &Schema,\n+) -> Result<Arc<dyn PhysicalExpr>> {\n+    let fun_expr: ScalarUdf = Arc::new(match fun {\n+        ScalarFunction::Sqrt => math_expressions::sqrt,\n+        ScalarFunction::Sin => math_expressions::sin,\n+        ScalarFunction::Cos => math_expressions::cos,\n+        ScalarFunction::Tan => math_expressions::tan,\n+        ScalarFunction::Asin => math_expressions::asin,\n+        ScalarFunction::Acos => math_expressions::acos,\n+        ScalarFunction::Atan => math_expressions::atan,\n+        ScalarFunction::Exp => math_expressions::exp,\n+        ScalarFunction::Log => math_expressions::ln,\n+        ScalarFunction::Log2 => math_expressions::log2,\n+        ScalarFunction::Log10 => math_expressions::log10,\n+        ScalarFunction::Floor => math_expressions::floor,\n+        ScalarFunction::Ceil => math_expressions::ceil,\n+        ScalarFunction::Round => math_expressions::round,\n+        ScalarFunction::Trunc => math_expressions::trunc,\n+        ScalarFunction::Abs => math_expressions::abs,\n+        ScalarFunction::Signum => math_expressions::signum,\n+        ScalarFunction::Length => |args| Ok(Arc::new(length(args[0].as_ref())?)),\n+    });\n+    let data_types = args\n+        .iter()\n+        .map(|e| e.data_type(input_schema))\n+        .collect::<Result<Vec<_>>>()?;\n+\n+    // coerce type\n+    // for now, this supports a single type.\n+    assert!(args.len() == 1);\n+    assert!(data_types.len() == 1);\n+    let arg_type = coerce(fun, &data_types[0])?;\n+    let args = vec![cast(args[0].clone(), input_schema, arg_type.clone())?];\n+\n+    Ok(Arc::new(udf::ScalarFunctionExpr::new(\n+        &format!(\"{}\", fun),\n+        fun_expr,\n+        args,\n+        &return_type(&fun, &vec![arg_type])?,\n+    )))\n+}\n+\n+/// the type supported by the function `fun`.\n+fn valid_type(fun: &ScalarFunction) -> DataType {\n+    // note: the physical expression must accept the type returned by this function or the execution panics.\n+\n+    // for now, the list is small, as we do not have many built-in functions.\n+    match fun {\n+        ScalarFunction::Length => DataType::Utf8,\n+        // math expressions expect f64\n+        _ => DataType::Float64,\n+    }\n+}\n+\n+/// coercion rules for all built-in functions.\n+/// Returns a DataType coerced from `arg_type` that is accepted by `fun`.\n+/// Errors when `arg_type` can't be coerced to a valid return type of `fun`.\n+fn coerce(fun: &ScalarFunction, arg_type: &DataType) -> Result<DataType> {\n\nReview comment:\n       ```suggestion\r\n   fn is_argument_compatible(fun: &ScalarFunction, arg_type: &DataType) -> Result<DataType> {\r\n   ```\r\n   \r\n   I don't think this function is \"coercing\" the input -- it is effectively encoding \"what coercions would be possible\" I think... \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-30T11:29:27.894+0000",
                    "updated": "2020-08-30T11:29:27.894+0000",
                    "started": "2020-08-30T11:29:27.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476226",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476259",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r479785852\n\n\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -592,7 +607,7 @@ mod tests {\n     fn select_scalar_func_with_literal_no_relation() {\n         quick_test(\n             \"SELECT sqrt(9)\",\n-            \"Projection: sqrt(CAST(Int64(9) AS Float64))\\\n+            \"Projection: sqrt(Int64(9))\\\n\nReview comment:\n       It depends where want to perform the cast. This test was ensuring that the cast was happenning on the logical plane, due to the type coercer.\r\n   \r\n   IMO `sqrt(8)` is a logical expression that everyone agrees should return `2.82842712475...` and the reason we cast it to f64 is entirely due to a limitation of our physical expressions, that only implement `sqrt` for f64.\r\n   \r\n   For this reason, IMO these type of casting operations should only be done on our physical plane. For example, a different physical planner could prefer to not have it `cast`ed because it has a specialized implementation that supports other types.\r\n   \r\n   This PR moves casting operations on built-in functions to the physical plane, like we are performing for binary operators.\r\n   \r\n   Note that the user continues to have full transparency: they can use `EXPLAIN verbose` to get the physical plan, that contains the cast.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-30T15:54:48.493+0000",
                    "updated": "2020-08-30T15:54:48.493+0000",
                    "started": "2020-08-30T15:54:48.493+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476259",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476260",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r479786701\n\n\n\n##########\nFile path: rust/datafusion/src/execution/physical_plan/functions.rs\n##########\n@@ -45,6 +43,22 @@ use arrow::{\n use std::{fmt, str::FromStr, sync::Arc};\n use udf::ScalarUdf;\n \n+/// A function's signature, which defines the function's supported argument types.\n+#[derive(Debug)]\n+pub enum Signature {\n+    /// arbitrary number of arguments of an uniform type out of a list of valid types\n+    // A function such as `concat` is `Many(vec![DataType::Utf8, DataType::LargeUtf8])`\n+    Many(Vec<DataType>),\n+    /// arbitrary number of arguments of an arbitrary but uniform type\n+    // A function such as `array` is `ManyUniform`\n+    // The first argument decides the type used for coercion\n+    ManyUniform,\n\nReview comment:\n       Yes, `Variadic`, that is more appropriate name.\r\n   \r\n   > the idea of a ManyUniform number of arguments perhaps is what is making this so complicated.\r\n   \r\n   I am not sure: implementation-wise, it is [a small variation](https://github.com/apache/arrow/pull/8080/files#diff-5743c88f5e5129ef14deb93746ca66c8R63) of `Uniform`.\r\n   \r\n   The complication comes from what we want to achieve: we are essentially building a dynamic typed system with type-checking during planning. AFAIK that is a subset of a compiler...\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-30T16:03:10.047+0000",
                    "updated": "2020-08-30T16:03:10.047+0000",
                    "started": "2020-08-30T16:03:10.047+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476260",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476523",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r480048622\n\n\n\n##########\nFile path: rust/datafusion/src/sql/planner.rs\n##########\n@@ -592,7 +607,7 @@ mod tests {\n     fn select_scalar_func_with_literal_no_relation() {\n         quick_test(\n             \"SELECT sqrt(9)\",\n-            \"Projection: sqrt(CAST(Int64(9) AS Float64))\\\n+            \"Projection: sqrt(Int64(9))\\\n\nReview comment:\n       > For this reason, IMO these type of casting operations should only be done on our physical plane. For example, a different physical planner could prefer to not have it casted because it has a specialized implementation that supports other types.\r\n   \r\n   I hadn't thought of the idea that different physical planners might want to do type coercion differently -- that is a good point and it makes sense to me. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-31T10:55:03.363+0000",
                    "updated": "2020-08-31T10:55:03.363+0000",
                    "started": "2020-08-31T10:55:03.363+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476523",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476677",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "jorgecarleitao commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r480263816\n\n\n\n##########\nFile path: rust/datafusion/src/logicalplan.rs\n##########\n@@ -190,7 +190,14 @@ fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n             let expr = create_name(expr, input_schema)?;\n             Ok(format!(\"CAST({} as {:?})\", expr, data_type))\n         }\n-        Expr::ScalarFunction { name, args, .. } => {\n+        Expr::ScalarFunction { fun, args, .. } => {\n+            let mut names = Vec::with_capacity(args.len());\n\nReview comment:\n       I agree. I kept it because the code around this change is using this idiom. I would prefer to change that whole code (`ScalarUDF`, `AggregateFunction`, `ScalarFunction`) in a separate commit to not want to complicate even further this PR\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-31T17:01:21.641+0000",
                    "updated": "2020-08-31T17:01:21.641+0000",
                    "started": "2020-08-31T17:01:21.641+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476677",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476830",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080#discussion_r480397191\n\n\n\n##########\nFile path: rust/datafusion/src/logicalplan.rs\n##########\n@@ -190,7 +190,14 @@ fn create_name(e: &Expr, input_schema: &Schema) -> Result<String> {\n             let expr = create_name(expr, input_schema)?;\n             Ok(format!(\"CAST({} as {:?})\", expr, data_type))\n         }\n-        Expr::ScalarFunction { name, args, .. } => {\n+        Expr::ScalarFunction { fun, args, .. } => {\n+            let mut names = Vec::with_capacity(args.len());\n\nReview comment:\n       that makes sense\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-08-31T21:02:31.777+0000",
                    "updated": "2020-08-31T21:02:31.777+0000",
                    "started": "2020-08-31T21:02:31.777+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476830",
                    "issueId": "13325201"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/worklog/476964",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove closed pull request #8080:\nURL: https://github.com/apache/arrow/pull/8080\n\n\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-09-01T02:25:55.964+0000",
                    "updated": "2020-09-01T02:25:55.964+0000",
                    "started": "2020-09-01T02:25:55.964+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "476964",
                    "issueId": "13325201"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 5400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@40c95140[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@78bd17f1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5030d569[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@40a24201[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56d90a45[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@42557cdd[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@14187263[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@467898ab[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@58ed3903[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@31b71557[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@666be268[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@645483ce[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 5400,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Sep 01 02:25:49 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-09-01T02:25:49.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-9887/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-08-30T10:36:10.000+0000",
        "updated": "2020-09-29T22:43:41.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1.5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 5400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] [DataFusion] Add support for complex return types of built-in functions",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13325201/comment/17188102",
                    "id": "17188102",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "body": "Issue resolved by pull request 8080\n[https://github.com/apache/arrow/pull/8080]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
                        "name": "andygrove",
                        "key": "andygrove",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
                        },
                        "displayName": "Andy Grove",
                        "active": true,
                        "timeZone": "America/Denver"
                    },
                    "created": "2020-09-01T02:25:49.723+0000",
                    "updated": "2020-09-01T02:25:49.723+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0i74w:",
        "customfield_12314139": null
    }
}