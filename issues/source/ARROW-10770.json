{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13343229",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229",
    "key": "ARROW-10770",
    "fields": {
        "parent": {
            "id": "13215112",
            "key": "ARROW-4534",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13215112",
            "fields": {
                "summary": "[Rust] Build JSON reader for reading record batches from line-delimited JSON files",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                    "name": "Major",
                    "id": "3"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=nevi_me",
            "name": "nevi_me",
            "key": "nevi_me",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=nevi_me&avatarId=24271",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=nevi_me&avatarId=24271",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=nevi_me&avatarId=24271",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=nevi_me&avatarId=24271"
            },
            "displayName": "Neville Dipale",
            "active": true,
            "timeZone": "Africa/Johannesburg"
        },
        "aggregateprogress": {
            "progress": 13800,
            "total": 13800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 13800,
            "total": 13800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10770/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 23,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525113",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me opened a new pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938\n\n\n   Big one!\r\n   \r\n   This implements a JSON nested list reader, which means that we can now read `<struct<list<struct<_>>>` and other variants.\r\n   While working on this, I noticed some bugs in the reader, which I fixed. They were:\r\n   \r\n   * `<list<string>>` was not read correctly by the dictionary hack\r\n   * `<list<primitive>>` was not creating the correct list offsets, sometimes `null` was placed in the incorrect logical location\r\n   \r\n   I've also added a few benchmarks, where the nested list benchmark now performs about ~20% slower . I'm fine with this, as we weren't always reading values correctly anyways.\r\n   \r\n   I suspect the main perf loss is from having to peek into JSON values in order to make the nesting work.\r\n   By this, I mean that if we have `{\"a\": [_, _, _]}`, we extract `a` values into a `Vec<Value>`, i.e. `[_, _, _]`.\r\n   By extracting values, we are able to then use the reader to read `&[Value]` without caring about its key (`a`).\r\n   The downside of this approach is that we have to clone values to get `Vec<Value>`, as I couldn't find an alternative.\r\n   \r\n   I could probably defer the extraction of `[_, _, _]` for later, but I was concerned that it was just going to make things messy.\r\n   I got lost a lot in the slough of complexity in this code.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T16:25:34.652+0000",
                    "updated": "2020-12-16T16:25:34.652+0000",
                    "started": "2020-12-16T16:25:34.651+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525113",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525114",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-746579024\n\n\n   CC @houqp \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T16:25:59.423+0000",
                    "updated": "2020-12-16T16:25:59.423+0000",
                    "started": "2020-12-16T16:25:59.423+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525114",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525116",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me edited a comment on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-746579024\n\n\n   CC @houqp @vertexclique (I didn't expand on the dictionary reader, but the first bug mentioned might be relevant to your work)\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T16:26:55.779+0000",
                    "updated": "2020-12-16T16:26:55.779+0000",
                    "started": "2020-12-16T16:26:55.778+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525116",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525127",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-746600179\n\n\n   https://issues.apache.org/jira/browse/ARROW-10770\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T16:38:49.873+0000",
                    "updated": "2020-12-16T16:38:49.873+0000",
                    "started": "2020-12-16T16:38:49.873+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525127",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525230",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544583058\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -1175,8 +1239,103 @@ impl Decoder {\n         }\n         Ok(Arc::new(builder.finish()) as ArrayRef)\n     }\n+\n+    /// Read the primitive list's values into ArrayData\n+    fn read_primitive_list_values<T>(&self, rows: &[Value]) -> ArrayDataRef\n+    where\n+        T: ArrowPrimitiveType + ArrowNumericType,\n+        T::Native: num::NumCast,\n+    {\n+        let values = rows\n+            .iter()\n+            .filter_map(|row| {\n+                // read values from list\n+                if let Value::Array(values) = row {\n+                    Some(\n+                        values\n+                            .iter()\n+                            .map(|value| {\n+                                let v: Option<T::Native> =\n+                                    value.as_f64().and_then(num::cast::cast);\n+                                v\n+                            })\n+                            .collect::<Vec<Option<T::Native>>>(),\n+                    )\n+                } else if let Value::Number(value) = row {\n+                    // handle the scalar number case\n+                    let v: Option<T::Native> = value.as_f64().and_then(num::cast::cast);\n+                    v.map(|v| vec![Some(v)])\n+                } else {\n+                    None\n+                }\n+            })\n+            .flatten()\n+            .collect::<Vec<Option<T::Native>>>();\n+        let array = PrimitiveArray::<T>::from_iter(values.iter());\n+        array.data()\n+    }\n+}\n+\n+/// Reads a JSON value as a string, regardless of its type.\n+/// This is useful if the expected datatype is a string, in which case we preserve\n+/// all the values regardless of they type.\n+///\n+/// Applying `value.to_string()` unfortunately results in an escaped string, which\n+/// is not what we want.\n+#[inline(always)]\n+fn json_value_as_string(value: &Value) -> Option<String> {\n+    match value {\n+        Value::Null => None,\n+        Value::String(string) => Some(string.clone()),\n+        _ => Some(value.to_string()),\n+    }\n }\n \n+/// Flattens a list of JSON values, by flattening lists, and treating all other values as\n+/// single-value lists.\n+/// This is used to read into nested lists (list of list, list of struct) and non-dictionary lists.\n+#[inline]\n+fn flatten_json_values(values: &[Value]) -> Vec<Value> {\n+    values\n+        .iter()\n+        .map(|row| {\n\nReview comment:\n       Use flat_map?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T19:57:55.082+0000",
                    "updated": "2020-12-16T19:57:55.082+0000",
                    "started": "2020-12-16T19:57:55.082+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525230",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525232",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544583608\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -1175,8 +1239,103 @@ impl Decoder {\n         }\n         Ok(Arc::new(builder.finish()) as ArrayRef)\n     }\n+\n+    /// Read the primitive list's values into ArrayData\n+    fn read_primitive_list_values<T>(&self, rows: &[Value]) -> ArrayDataRef\n+    where\n+        T: ArrowPrimitiveType + ArrowNumericType,\n+        T::Native: num::NumCast,\n+    {\n+        let values = rows\n+            .iter()\n+            .filter_map(|row| {\n+                // read values from list\n+                if let Value::Array(values) = row {\n+                    Some(\n+                        values\n+                            .iter()\n+                            .map(|value| {\n+                                let v: Option<T::Native> =\n+                                    value.as_f64().and_then(num::cast::cast);\n+                                v\n+                            })\n+                            .collect::<Vec<Option<T::Native>>>(),\n+                    )\n+                } else if let Value::Number(value) = row {\n+                    // handle the scalar number case\n+                    let v: Option<T::Native> = value.as_f64().and_then(num::cast::cast);\n+                    v.map(|v| vec![Some(v)])\n+                } else {\n+                    None\n+                }\n+            })\n+            .flatten()\n+            .collect::<Vec<Option<T::Native>>>();\n+        let array = PrimitiveArray::<T>::from_iter(values.iter());\n+        array.data()\n+    }\n+}\n+\n+/// Reads a JSON value as a string, regardless of its type.\n+/// This is useful if the expected datatype is a string, in which case we preserve\n+/// all the values regardless of they type.\n+///\n+/// Applying `value.to_string()` unfortunately results in an escaped string, which\n+/// is not what we want.\n+#[inline(always)]\n+fn json_value_as_string(value: &Value) -> Option<String> {\n+    match value {\n+        Value::Null => None,\n+        Value::String(string) => Some(string.clone()),\n+        _ => Some(value.to_string()),\n+    }\n }\n \n+/// Flattens a list of JSON values, by flattening lists, and treating all other values as\n+/// single-value lists.\n+/// This is used to read into nested lists (list of list, list of struct) and non-dictionary lists.\n+#[inline]\n+fn flatten_json_values(values: &[Value]) -> Vec<Value> {\n+    values\n+        .iter()\n+        .map(|row| {\n+            if let Value::Array(values) = row {\n+                values.clone()\n\nReview comment:\n       Could return iterators here instead of cloning/ generating new vecs?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T19:58:54.342+0000",
                    "updated": "2020-12-16T19:58:54.342+0000",
                    "started": "2020-12-16T19:58:54.342+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525232",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525234",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544584145\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -1175,8 +1239,103 @@ impl Decoder {\n         }\n         Ok(Arc::new(builder.finish()) as ArrayRef)\n     }\n+\n+    /// Read the primitive list's values into ArrayData\n+    fn read_primitive_list_values<T>(&self, rows: &[Value]) -> ArrayDataRef\n+    where\n+        T: ArrowPrimitiveType + ArrowNumericType,\n+        T::Native: num::NumCast,\n+    {\n+        let values = rows\n+            .iter()\n+            .filter_map(|row| {\n+                // read values from list\n+                if let Value::Array(values) = row {\n+                    Some(\n+                        values\n+                            .iter()\n+                            .map(|value| {\n+                                let v: Option<T::Native> =\n+                                    value.as_f64().and_then(num::cast::cast);\n+                                v\n+                            })\n+                            .collect::<Vec<Option<T::Native>>>(),\n+                    )\n+                } else if let Value::Number(value) = row {\n+                    // handle the scalar number case\n+                    let v: Option<T::Native> = value.as_f64().and_then(num::cast::cast);\n+                    v.map(|v| vec![Some(v)])\n+                } else {\n+                    None\n+                }\n+            })\n+            .flatten()\n+            .collect::<Vec<Option<T::Native>>>();\n+        let array = PrimitiveArray::<T>::from_iter(values.iter());\n+        array.data()\n+    }\n+}\n+\n+/// Reads a JSON value as a string, regardless of its type.\n+/// This is useful if the expected datatype is a string, in which case we preserve\n+/// all the values regardless of they type.\n+///\n+/// Applying `value.to_string()` unfortunately results in an escaped string, which\n+/// is not what we want.\n+#[inline(always)]\n+fn json_value_as_string(value: &Value) -> Option<String> {\n+    match value {\n+        Value::Null => None,\n+        Value::String(string) => Some(string.clone()),\n+        _ => Some(value.to_string()),\n+    }\n }\n \n+/// Flattens a list of JSON values, by flattening lists, and treating all other values as\n+/// single-value lists.\n+/// This is used to read into nested lists (list of list, list of struct) and non-dictionary lists.\n+#[inline]\n+fn flatten_json_values(values: &[Value]) -> Vec<Value> {\n+    values\n+        .iter()\n+        .map(|row| {\n+            if let Value::Array(values) = row {\n+                values.clone()\n+            } else if let Value::Null = row {\n+                vec![Value::Null]\n+            } else {\n+                // we interpret a scalar as a single-value list to minimise data loss\n+                vec![row.clone()]\n+            }\n+        })\n+        .flatten()\n+        .collect()\n+}\n+\n+/// Flattens a list into string values, dropping Value::Null in the process.\n+/// This is useful for interpreting any JSON array as string, dropping nulls.\n+/// See `json_value_as_string`.\n+#[inline]\n+fn flatten_json_string_values(values: &[Value]) -> Vec<Option<String>> {\n+    values\n+        .iter()\n+        .filter_map(|row| {\n+            if let Value::Array(values) = row {\n+                Some(\n+                    values\n+                        .iter()\n\nReview comment:\n       Here as well, could be iterators?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T19:59:50.337+0000",
                    "updated": "2020-12-16T19:59:50.337+0000",
                    "started": "2020-12-16T19:59:50.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525234",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525235",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544585525\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -1175,8 +1239,103 @@ impl Decoder {\n         }\n         Ok(Arc::new(builder.finish()) as ArrayRef)\n     }\n+\n+    /// Read the primitive list's values into ArrayData\n+    fn read_primitive_list_values<T>(&self, rows: &[Value]) -> ArrayDataRef\n+    where\n+        T: ArrowPrimitiveType + ArrowNumericType,\n+        T::Native: num::NumCast,\n+    {\n+        let values = rows\n+            .iter()\n+            .filter_map(|row| {\n\nReview comment:\n       You could simplify the filter_map + flatten with flat_map + empty iter instead\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:02:13.599+0000",
                    "updated": "2020-12-16T20:02:13.599+0000",
                    "started": "2020-12-16T20:02:13.599+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525235",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525236",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544586844\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n+                            });\n+                            values.clone()\n+                        } else {\n+                            struct_index += 1;\n+                            vec![Value::Null]\n+                        }\n+                    })\n+                    .flatten()\n+                    .collect();\n+                let arrays =\n+                    self.build_struct_array(rows.as_slice(), fields.as_slice(), &[])?;\n+                let data_type = DataType::Struct(fields.clone());\n+                let buf = null_buffer.freeze();\n+                ArrayDataBuilder::new(data_type)\n+                    .len(rows.len())\n+                    .null_bit_buffer(buf)\n+                    .child_data(arrays.into_iter().map(|a| a.data()).collect())\n+                    .build()\n+            }\n+            DataType::Dictionary(_, _) => {\n+                todo!()\n+            }\n+            t => {\n+                return Err(ArrowError::JsonError(format!(\n+                    \"Nested list of {:?} not supported\",\n+                    t\n+                )));\n+            }\n+        };\n+        // build list\n+        let list_data = ArrayData::builder(DataType::List(Box::new(list_field.clone())))\n+            .len(list_len)\n+            .add_buffer(Buffer::from(offsets.to_byte_slice()))\n+            .add_child_data(array_data)\n+            .null_bit_buffer(list_nulls.freeze())\n+            .build();\n+        Ok(Arc::new(GenericListArray::<OffsetSize>::from(list_data)))\n     }\n \n+    /// Builds the child values of a `StructArray`, falling short of constructing the StructArray.\n+    /// The function does not construct the StructArray as some callers would want the child arrays.\n+    ///\n+    /// *Note*: The function is recursive, and will read nested structs.\n+    ///\n+    /// If `projection` is not empty, then all values are returned. The first level of projection\n+    /// occurs at the `RecordBatch` level. No further projection currently occurs, but would be\n+    /// useful if plucking values from a struct, e.g. getting `a.b.c.e` from `a.b.c.{d, e}`.\n     fn build_struct_array(\n         &self,\n         rows: &[Value],\n         struct_fields: &[Field],\n         projection: &[String],\n     ) -> Result<Vec<ArrayRef>> {\n-        let arrays: Result<Vec<ArrayRef>> =\n-            struct_fields\n-                .iter()\n-                .filter(|field| {\n-                    if projection.is_empty() {\n-                        return true;\n+        let arrays: Result<Vec<ArrayRef>> = struct_fields\n+            .iter()\n+            .filter(|field| {\n+                if projection.is_empty() {\n+                    return true;\n\nReview comment:\n       Maybe reads better as `projection.is_empty || projection.contains(...` instead?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:04:32.173+0000",
                    "updated": "2020-12-16T20:04:32.173+0000",
                    "started": "2020-12-16T20:04:32.173+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525236",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525238",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544587363\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n+                            });\n+                            values.clone()\n+                        } else {\n+                            struct_index += 1;\n+                            vec![Value::Null]\n+                        }\n+                    })\n+                    .flatten()\n+                    .collect();\n+                let arrays =\n+                    self.build_struct_array(rows.as_slice(), fields.as_slice(), &[])?;\n+                let data_type = DataType::Struct(fields.clone());\n+                let buf = null_buffer.freeze();\n+                ArrayDataBuilder::new(data_type)\n+                    .len(rows.len())\n+                    .null_bit_buffer(buf)\n+                    .child_data(arrays.into_iter().map(|a| a.data()).collect())\n+                    .build()\n+            }\n+            DataType::Dictionary(_, _) => {\n+                todo!()\n+            }\n+            t => {\n\nReview comment:\n       Maybe call this binding `datatype`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:05:23.210+0000",
                    "updated": "2020-12-16T20:05:23.210+0000",
                    "started": "2020-12-16T20:05:23.210+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525238",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525239",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544588101\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n+                            });\n+                            values.clone()\n+                        } else {\n+                            struct_index += 1;\n+                            vec![Value::Null]\n+                        }\n+                    })\n+                    .flatten()\n+                    .collect();\n+                let arrays =\n+                    self.build_struct_array(rows.as_slice(), fields.as_slice(), &[])?;\n+                let data_type = DataType::Struct(fields.clone());\n+                let buf = null_buffer.freeze();\n+                ArrayDataBuilder::new(data_type)\n+                    .len(rows.len())\n+                    .null_bit_buffer(buf)\n+                    .child_data(arrays.into_iter().map(|a| a.data()).collect())\n+                    .build()\n+            }\n+            DataType::Dictionary(_, _) => {\n+                todo!()\n\nReview comment:\n       Is this planned in this PR? Otherwise I think it may make sense to create an error with a link to a Arrow issue?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:06:36.700+0000",
                    "updated": "2020-12-16T20:06:36.700+0000",
                    "started": "2020-12-16T20:06:36.700+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525239",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525240",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-746938223\n\n\n   This looks great! I provided some suggestions.\r\n   I think main thing that could be improved is the filter_maps + flatten that could be simplified, and could avoid allocating intermediate `Vecs` as well.\r\n   \r\n   I think 20% speed is worth it for more correctness and functionality for now, probably it could be recovered later. \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:10:57.797+0000",
                    "updated": "2020-12-16T20:10:57.797+0000",
                    "started": "2020-12-16T20:10:57.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525240",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525241",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan edited a comment on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-746938223\n\n\n   This looks great! I provided some style suggestions.\r\n   I think main thing that could be improved is the filter_maps + flatten that could be simplified, and could avoid allocating intermediate `Vecs` as well.\r\n   \r\n   I think 20% speed is worth it for more correctness and functionality for now, probably it could be recovered later. \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:11:22.786+0000",
                    "updated": "2020-12-16T20:11:22.786+0000",
                    "started": "2020-12-16T20:11:22.785+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525241",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525246",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544601441\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n\nReview comment:\n       Could use enumerate?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:29:09.203+0000",
                    "updated": "2020-12-16T20:29:09.203+0000",
                    "started": "2020-12-16T20:29:09.203+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525246",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544602223\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n\nReview comment:\n       Enumerate + could return iterator instead of Vec?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:30:33.206+0000",
                    "updated": "2020-12-16T20:30:33.206+0000",
                    "started": "2020-12-16T20:30:33.205+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525247",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525253",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544606621\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n\nReview comment:\n       I ended up being forced to use vec because I was getting panics from \"Iterator must be sized\". We use `ExactSizeIterator`, which doesn't work when flattening lists because the exact number of flattened values can't be determined.\r\n   I'm not pleased with having to collect then iterate, but it was the only thing that seemed to work.\r\n   \r\n   I don't mind if you make some changes and push them onto my branch.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:38:14.795+0000",
                    "updated": "2020-12-16T20:38:14.795+0000",
                    "started": "2020-12-16T20:38:14.795+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525253",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525255",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544609090\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n\nReview comment:\n       Doesn't work, I have to keep track of the index but I iterate twice. So enumerate won't have the same effect.\r\n   At least from looking at the code, that's what I'm seeing. Look at line 895\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:42:34.484+0000",
                    "updated": "2020-12-16T20:42:34.484+0000",
                    "started": "2020-12-16T20:42:34.483+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525255",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525257",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "nevi-me commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544610321\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n+                            });\n+                            values.clone()\n+                        } else {\n+                            struct_index += 1;\n+                            vec![Value::Null]\n+                        }\n+                    })\n+                    .flatten()\n+                    .collect();\n+                let arrays =\n+                    self.build_struct_array(rows.as_slice(), fields.as_slice(), &[])?;\n+                let data_type = DataType::Struct(fields.clone());\n+                let buf = null_buffer.freeze();\n+                ArrayDataBuilder::new(data_type)\n+                    .len(rows.len())\n+                    .null_bit_buffer(buf)\n+                    .child_data(arrays.into_iter().map(|a| a.data()).collect())\n+                    .build()\n+            }\n+            DataType::Dictionary(_, _) => {\n+                todo!()\n\nReview comment:\n       I missed that, thanks. \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-16T20:44:51.229+0000",
                    "updated": "2020-12-16T20:44:51.229+0000",
                    "started": "2020-12-16T20:44:51.229+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525257",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525329",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#issuecomment-747119057\n\n\n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=h1) Report\n   > Merging [#8938](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=desc) (09aebf1) into [master](https://codecov.io/gh/apache/arrow/commit/d65ba4ec5daeb93ca5031f883d08d559b68753b2?el=desc) (d65ba4e) will **decrease** coverage by `0.04%`.\n   > The diff coverage is `66.20%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/8938/graphs/tree.svg?width=650&height=150&src=pr&token=LpTCFbqVT1)](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master    #8938      +/-   ##\n   ==========================================\n   - Coverage   83.25%   83.20%   -0.05%     \n   ==========================================\n     Files         196      196              \n     Lines       48116    48269     +153     \n   ==========================================\n   + Hits        40059    40164     +105     \n   - Misses       8057     8105      +48     \n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/arrow/src/json/reader.rs](https://codecov.io/gh/apache/arrow/pull/8938/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvanNvbi9yZWFkZXIucnM=) | `81.49% <66.20%> (-1.60%)` | :arrow_down: |\n   | [rust/arrow/src/array/builder.rs](https://codecov.io/gh/apache/arrow/pull/8938/diff?src=pr&el=tree#diff-cnVzdC9hcnJvdy9zcmMvYXJyYXkvYnVpbGRlci5ycw==) | `84.11% <0.00%> (-0.07%)` | :arrow_down: |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=footer). Last update [d65ba4e...09aebf1](https://codecov.io/gh/apache/arrow/pull/8938?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T00:19:29.600+0000",
                    "updated": "2020-12-17T00:19:29.600+0000",
                    "started": "2020-12-17T00:19:29.600+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525329",
                    "issueId": "13343229"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/worklog/525476",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #8938:\nURL: https://github.com/apache/arrow/pull/8938#discussion_r544980166\n\n\n\n##########\nFile path: rust/arrow/src/json/reader.rs\n##########\n@@ -888,265 +855,362 @@ impl Decoder {\n         ))\n     }\n \n-    fn build_list_array<T: ArrowPrimitiveType>(\n+    /// Build a nested GenericListArray from a list of unnested `Value`s\n+    fn build_nested_list_array<OffsetSize: OffsetSizeTrait>(\n         &self,\n         rows: &[Value],\n-        col_name: &str,\n-    ) -> Result<ArrayRef>\n-    where\n-        T::Native: num::NumCast,\n-    {\n-        let values_builder: PrimitiveBuilder<T> = PrimitiveBuilder::new(rows.len());\n-        let mut builder = ListBuilder::new(values_builder);\n-        for row in rows {\n-            if let Some(value) = row.get(&col_name) {\n-                // value can be an array or a scalar\n-                let vals: Vec<Option<f64>> = if let Value::Number(value) = value {\n-                    vec![value.as_f64()]\n-                } else if let Value::Array(n) = value {\n-                    n.iter().map(|v: &Value| v.as_f64()).collect()\n-                } else if let Value::Null = value {\n-                    vec![None]\n-                } else {\n-                    return Err(ArrowError::JsonError(\n-                        \"3Only scalars are currently supported in JSON arrays\"\n-                            .to_string(),\n-                    ));\n-                };\n-                for val in vals {\n-                    match val {\n-                        Some(v) => match num::cast::cast(v) {\n-                            Some(v) => builder.values().append_value(v)?,\n-                            None => builder.values().append_null()?,\n-                        },\n-                        None => builder.values().append_null()?,\n-                    };\n-                }\n+        list_field: &Field,\n+    ) -> Result<ArrayRef> {\n+        // build list offsets\n+        let mut cur_offset = OffsetSize::zero();\n+        let list_len = rows.len();\n+        let num_list_bytes = bit_util::ceil(list_len, 8);\n+        let mut offsets = Vec::with_capacity(list_len + 1);\n+        let mut list_nulls =\n+            MutableBuffer::new(num_list_bytes).with_bitset(num_list_bytes, false);\n+        offsets.push(cur_offset);\n+        rows.iter().enumerate().for_each(|(i, v)| {\n+            if let Value::Array(a) = v {\n+                cur_offset = cur_offset + OffsetSize::from_usize(a.len()).unwrap();\n+                bit_util::set_bit(list_nulls.data_mut(), i);\n+            } else if let Value::Null = v {\n+                // value is null, not incremented\n+            } else {\n+                cur_offset = cur_offset + OffsetSize::one();\n             }\n-            builder.append(true)?\n-        }\n-        Ok(Arc::new(builder.finish()))\n+            offsets.push(cur_offset);\n+        });\n+        let valid_len = cur_offset.to_usize().unwrap();\n+        let array_data = match list_field.data_type() {\n+            DataType::Null => NullArray::new(valid_len).data(),\n+            DataType::Boolean => {\n+                let num_bytes = bit_util::ceil(valid_len, 8);\n+                let mut bool_values =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut bool_nulls =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, true);\n+                let mut curr_index = 0;\n+                rows.iter().for_each(|v| {\n+                    if let Value::Array(vs) = v {\n+                        vs.iter().for_each(|value| {\n+                            if let Value::Bool(child) = value {\n+                                // if valid boolean, append value\n+                                if *child {\n+                                    bit_util::set_bit(bool_values.data_mut(), curr_index);\n+                                }\n+                            } else {\n+                                // null slot\n+                                bit_util::unset_bit(bool_nulls.data_mut(), curr_index);\n+                            }\n+                            curr_index += 1;\n+                        });\n+                    }\n+                });\n+                ArrayData::builder(list_field.data_type().clone())\n+                    .len(valid_len)\n+                    .add_buffer(bool_values.freeze())\n+                    .null_bit_buffer(bool_nulls.freeze())\n+                    .build()\n+            }\n+            DataType::Int8 => self.read_primitive_list_values::<Int8Type>(rows),\n+            DataType::Int16 => self.read_primitive_list_values::<Int16Type>(rows),\n+            DataType::Int32 => self.read_primitive_list_values::<Int32Type>(rows),\n+            DataType::Int64 => self.read_primitive_list_values::<Int64Type>(rows),\n+            DataType::UInt8 => self.read_primitive_list_values::<UInt8Type>(rows),\n+            DataType::UInt16 => self.read_primitive_list_values::<UInt16Type>(rows),\n+            DataType::UInt32 => self.read_primitive_list_values::<UInt32Type>(rows),\n+            DataType::UInt64 => self.read_primitive_list_values::<UInt64Type>(rows),\n+            DataType::Float16 => {\n+                return Err(ArrowError::JsonError(\"Float16 not supported\".to_string()))\n+            }\n+            DataType::Float32 => self.read_primitive_list_values::<Float32Type>(rows),\n+            DataType::Float64 => self.read_primitive_list_values::<Float64Type>(rows),\n+            DataType::Timestamp(_, _)\n+            | DataType::Date32(_)\n+            | DataType::Date64(_)\n+            | DataType::Time32(_)\n+            | DataType::Time64(_) => {\n+                return Err(ArrowError::JsonError(\n+                    \"Temporal types are not yet supported, see ARROW-4803\".to_string(),\n+                ))\n+            }\n+            DataType::Utf8 => {\n+                StringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::LargeUtf8 => {\n+                LargeStringArray::from_iter(flatten_json_string_values(rows).into_iter())\n+                    .data()\n+            }\n+            DataType::List(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i32>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::LargeList(field) => {\n+                let child = self\n+                    .build_nested_list_array::<i64>(&flatten_json_values(rows), field)?;\n+                child.data()\n+            }\n+            DataType::Struct(fields) => {\n+                // extract list values, with non-lists converted to Value::Null\n+                let len = rows.len();\n+                let num_bytes = bit_util::ceil(len, 8);\n+                let mut null_buffer =\n+                    MutableBuffer::new(num_bytes).with_bitset(num_bytes, false);\n+                let mut struct_index = 0;\n+                let rows: Vec<Value> = rows\n+                    .iter()\n+                    .map(|row| {\n+                        if let Value::Array(values) = row {\n+                            values.iter().for_each(|_| {\n+                                bit_util::set_bit(null_buffer.data_mut(), struct_index);\n+                                struct_index += 1;\n\nReview comment:\n       Makes sense. I also played a bit with the code, but it's hard to change the code to return iterators. Maybe it makes sense to create / push to a vec instead in this case?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-17T10:30:41.808+0000",
                    "updated": "2020-12-17T10:30:41.808+0000",
                    "started": "2020-12-17T10:30:41.808+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "525476",
                    "issueId": "13343229"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 13800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@1a0ee0e0[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5cc1a44b[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3f5a3a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@5247ac68[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@63e3ced6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@72da796[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@29ebe479[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@462029c0[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3b48daac[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5133db44[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@278d3537[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@6024762f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 13800,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Dec 21 18:26:27 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-21T18:26:27.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10770/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-11-30T05:32:16.000+0000",
        "updated": "2020-12-21T18:26:40.000+0000",
        "timeoriginalestimate": null,
        "description": "The JSON reader now supports reading nested structs, but we are still left with nested lists, which can be lists of lists, or lists of structs.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "3h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 13800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Support reading nested JSON lists",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13343229/comment/17253026",
                    "id": "17253026",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8938\n[https://github.com/apache/arrow/pull/8938]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-12-21T18:26:27.592+0000",
                    "updated": "2020-12-21T18:26:27.592+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0l1ao:",
        "customfield_12314139": null
    }
}