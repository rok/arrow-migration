{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13365558",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558",
    "key": "ARROW-11984",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/5",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/trivial.svg",
            "name": "Trivial",
            "id": "5"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334626",
                "id": "12334626",
                "name": "C++ - Gandiva"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=jpedroantunes",
            "name": "jpedroantunes",
            "key": "jpedroantunes",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34060",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34060",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34060",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34060"
            },
            "displayName": "Jo\u00e3o Pedro Antunes Ferreira",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 24600,
            "total": 24600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 24600,
            "total": 24600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11984/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 41,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/567216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#issuecomment-800573651\n\n\n   https://issues.apache.org/jira/browse/ARROW-11984\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-16T20:17:38.959+0000",
                    "updated": "2021-03-16T20:17:38.959+0000",
                    "started": "2021-03-16T20:17:38.959+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "567216",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "projjal commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r596529641\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n\nReview comment:\n       Return a hash for null values too.\n\n##########\nFile path: cpp/src/gandiva/tests/hash_test.cc\n##########\n@@ -147,4 +153,252 @@ TEST_F(TestHash, TestBuf) {\n   }\n }\n \n+TEST_F(TestHash, TestSha256Simple) {\n\nReview comment:\n       I think you should also add unit test for HashUtils::GetHash() with expected sha values.\r\n   You can also add java test in java/gandiva/ProjectorTest and match by generating sha using MessageDigest class.\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n+\n+    int tmp_buf_len = 4;\n+\n+    auto hex_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, tmp_buf_len));\n+\n+    auto result_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, result_buf_size));\n+\n+    CleanCharArray(result_buffer);\n+    CleanCharArray(hex_buffer);\n+\n+    if (hex_buffer == nullptr || result_buffer == nullptr) {\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory \"\n+                                       \"for the result buffers.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    for (unsigned int j = 0; j < result_length; j++) {\n+      unsigned char hex_number = result[j];\n+      snprintf(hex_buffer, tmp_buf_len, \"%02x\", hex_number);\n+      strncat(result_buffer, hex_buffer, tmp_buf_len);\n+    }\n+\n+    // Add the NULL character to shows the end of the string\n+    result_buffer[result_buf_size - 1] = '\\0';\n+\n+    // free the resources to avoid memory leaks\n+    EVP_MD_CTX_free(md_ctx);\n+    free(result);\n+\n+    *out_length = strlen(result_buffer);\n\nReview comment:\n       *out_length = result_buf_size\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n\nReview comment:\n       add a check result_length == hash_size\r\n   and result_buf_size == 2 * hash_size\n\n##########\nFile path: cpp/src/gandiva/function_registry_common.h\n##########\n@@ -199,6 +199,28 @@ typedef std::unordered_map<const FunctionSignature*, const NativeFunction*, KeyH\n                  DataTypeVector{TYPE(), int64()}, int64(), kResultNullNever, \\\n                  ARROW_STRINGIFY(NAME##WithSeed_##TYPE))\n \n+// HashSHA128 functions that :\n+// - NULL handling is of type NULL_NEVER\n+// - can return errors\n+//\n+// The function name includes the base name & input type name. gdv_fn_sha128_float64\n+#define HASH_SHA128_NULL_NEVER(NAME, ALIASES, TYPE)                           \\\n\nReview comment:\n       I think it is called SHA1 and not SHA128. The digest bit size is also 160 and not 128\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n\nReview comment:\n       Arrow doesn't use null terminated string so adding null character is not required. assigning out_length is enough.\n\n##########\nFile path: cpp/src/gandiva/tests/hash_test.cc\n##########\n@@ -147,4 +153,252 @@ TEST_F(TestHash, TestBuf) {\n   }\n }\n \n+TEST_F(TestHash, TestSha256Simple) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", int32());\n+  auto field_b = field(\"b\", int64());\n+  auto field_c = field(\"c\", float32());\n+  auto field_d = field(\"d\", float64());\n+  auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+  auto res_1 = field(\"res1\", utf8());\n+  auto res_2 = field(\"res2\", utf8());\n+  auto res_3 = field(\"res3\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256_1 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256_1, res_0);\n+\n+  auto node_b = TreeExprBuilder::MakeField(field_b);\n+  auto hashSha256_2 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_b}, utf8());\n+  auto expr_1 = TreeExprBuilder::MakeExpression(hashSha256_2, res_1);\n+\n+  auto node_c = TreeExprBuilder::MakeField(field_c);\n+  auto hashSha256_3 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_c}, utf8());\n+  auto expr_2 = TreeExprBuilder::MakeExpression(hashSha256_3, res_2);\n+\n+  auto node_d = TreeExprBuilder::MakeField(field_d);\n+  auto hashSha256_4 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_d}, utf8());\n+  auto expr_3 = TreeExprBuilder::MakeExpression(hashSha256_4, res_3);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t  TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 2;\n+  auto validity_array = {false, true};\n+\n+  auto array_int32 =\n+      MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+  auto array_int64 =\n+      MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+  auto array_float32 =\n+      MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+  auto array_float64 =\n+      MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t   {array_int32, array_int64,\n+\t\t\t  array_float32, array_float64});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha256Varlen) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", utf8());\n+  auto schema = arrow::schema({field_a});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256, res_0);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 3;\n+\n+  std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY \"\n+\t\t\t\t\t\t\t \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+  std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY \"\n+\t\t\t\t\t\t\t  \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+  auto array_a =\n+      MakeArrowArrayUtf8({\"foo\", first_string, second_string}, {false, true, true});\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  auto response = outputs.at(0);\n+  EXPECT_EQ(response->null_count(), 0);\n+  EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+  for (int i = 1; i < num_records; ++i) {\n+    const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+    EXPECT_NE(value_at_position,\n+\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+  }\n+}\n+\n+TEST_F(TestHash, TestSha128Simple) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", int32());\n+    auto field_b = field(\"b\", int64());\n+    auto field_c = field(\"c\", float32());\n+    auto field_d = field(\"d\", float64());\n+    auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+    auto res_1 = field(\"res1\", utf8());\n+    auto res_2 = field(\"res2\", utf8());\n+    auto res_3 = field(\"res3\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128_1 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128_1, res_0);\n+\n+    auto node_b = TreeExprBuilder::MakeField(field_b);\n+    auto hashSha128_2 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_b}, utf8());\n+    auto expr_1 = TreeExprBuilder::MakeExpression(hashSha128_2, res_1);\n+\n+    auto node_c = TreeExprBuilder::MakeField(field_c);\n+    auto hashSha128_3 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_c}, utf8());\n+    auto expr_2 = TreeExprBuilder::MakeExpression(hashSha128_3, res_2);\n+\n+    auto node_d = TreeExprBuilder::MakeField(field_d);\n+    auto hashSha128_4 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_d}, utf8());\n+    auto expr_3 = TreeExprBuilder::MakeExpression(hashSha128_4, res_3);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t\t\tTestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 2;\n+    auto validity_array = {false, true};\n+\n+    auto array_int32 =\n+            MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+    auto array_int64 =\n+            MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+    auto array_float32 =\n+            MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+    auto array_float64 =\n+            MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t\t {array_int32, array_int64,\n+\t\t\t array_float32, array_float64});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha128Varlen) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", utf8());\n+    auto schema = arrow::schema({field_a});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128, res_0);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 3;\n+\n+    std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t   \"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+    std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t\t\"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+    auto array_a =\n+            MakeArrowArrayUtf8({\"foo\", first_string, second_string},\n+\t\t\t\t\t\t\t   {false, true, true});\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    auto response = outputs.at(0);\n+    EXPECT_EQ(response->null_count(), 0);\n+    EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+    for (int i = 1; i < num_records; ++i) {\n+        const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+        EXPECT_NE(value_at_position,\n+\t\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+    }\n\nReview comment:\n       May be also add assertion that output are sized correctly, that is each output data is 40 and 64 length string for sha128 and sha256 resp.\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n\nReview comment:\n       -> \"Could not create context\"\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-18T04:24:11.293+0000",
                    "updated": "2021-03-18T04:24:11.293+0000",
                    "started": "2021-03-18T04:24:11.293+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568088",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568751",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597384802\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.h\n##########\n@@ -0,0 +1,54 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_SRC_HASH_UTILS_H_\n+#define ARROW_SRC_HASH_UTILS_H_\n+\n+#include <cstdlib>\n+#include <cstdint>\n+#include \"gandiva/visibility.h\"\n+#include \"openssl/evp.h\"\n+\n+namespace gandiva {\n+class GANDIVA_EXPORT HashUtils {\n+ public:\n+  static const char *HashUsingSha256(int64_t context,\n\nReview comment:\n       documentations for these methods?  The pattern here seems strange to have all static methods on the class why not just make these first class functions without the class?  At least a comment on that aspect would be worthwhile also.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:34:31.172+0000",
                    "updated": "2021-03-19T03:34:31.172+0000",
                    "started": "2021-03-19T03:34:31.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568751",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568752",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597385159\n\n\n\n##########\nFile path: cpp/src/gandiva/tests/hash_test.cc\n##########\n@@ -147,4 +153,252 @@ TEST_F(TestHash, TestBuf) {\n   }\n }\n \n+TEST_F(TestHash, TestSha256Simple) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", int32());\n+  auto field_b = field(\"b\", int64());\n+  auto field_c = field(\"c\", float32());\n+  auto field_d = field(\"d\", float64());\n+  auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+  auto res_1 = field(\"res1\", utf8());\n+  auto res_2 = field(\"res2\", utf8());\n+  auto res_3 = field(\"res3\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256_1 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256_1, res_0);\n+\n+  auto node_b = TreeExprBuilder::MakeField(field_b);\n+  auto hashSha256_2 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_b}, utf8());\n+  auto expr_1 = TreeExprBuilder::MakeExpression(hashSha256_2, res_1);\n+\n+  auto node_c = TreeExprBuilder::MakeField(field_c);\n+  auto hashSha256_3 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_c}, utf8());\n+  auto expr_2 = TreeExprBuilder::MakeExpression(hashSha256_3, res_2);\n+\n+  auto node_d = TreeExprBuilder::MakeField(field_d);\n+  auto hashSha256_4 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_d}, utf8());\n+  auto expr_3 = TreeExprBuilder::MakeExpression(hashSha256_4, res_3);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t  TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 2;\n+  auto validity_array = {false, true};\n+\n+  auto array_int32 =\n+      MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+  auto array_int64 =\n+      MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+  auto array_float32 =\n+      MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+  auto array_float64 =\n+      MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t   {array_int32, array_int64,\n+\t\t\t  array_float32, array_float64});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha256Varlen) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", utf8());\n+  auto schema = arrow::schema({field_a});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256, res_0);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 3;\n+\n+  std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY \"\n+\t\t\t\t\t\t\t \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+  std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY \"\n+\t\t\t\t\t\t\t  \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+  auto array_a =\n+      MakeArrowArrayUtf8({\"foo\", first_string, second_string}, {false, true, true});\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  auto response = outputs.at(0);\n+  EXPECT_EQ(response->null_count(), 0);\n+  EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+  for (int i = 1; i < num_records; ++i) {\n+    const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+    EXPECT_NE(value_at_position,\n+\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+  }\n+}\n+\n+TEST_F(TestHash, TestSha128Simple) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", int32());\n+    auto field_b = field(\"b\", int64());\n+    auto field_c = field(\"c\", float32());\n+    auto field_d = field(\"d\", float64());\n+    auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+    auto res_1 = field(\"res1\", utf8());\n+    auto res_2 = field(\"res2\", utf8());\n+    auto res_3 = field(\"res3\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128_1 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128_1, res_0);\n+\n+    auto node_b = TreeExprBuilder::MakeField(field_b);\n+    auto hashSha128_2 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_b}, utf8());\n+    auto expr_1 = TreeExprBuilder::MakeExpression(hashSha128_2, res_1);\n+\n+    auto node_c = TreeExprBuilder::MakeField(field_c);\n+    auto hashSha128_3 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_c}, utf8());\n+    auto expr_2 = TreeExprBuilder::MakeExpression(hashSha128_3, res_2);\n+\n+    auto node_d = TreeExprBuilder::MakeField(field_d);\n+    auto hashSha128_4 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_d}, utf8());\n+    auto expr_3 = TreeExprBuilder::MakeExpression(hashSha128_4, res_3);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t\t\tTestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 2;\n+    auto validity_array = {false, true};\n+\n+    auto array_int32 =\n+            MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+    auto array_int64 =\n+            MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+    auto array_float32 =\n+            MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+    auto array_float64 =\n+            MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t\t {array_int32, array_int64,\n+\t\t\t array_float32, array_float64});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha128Varlen) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", utf8());\n+    auto schema = arrow::schema({field_a});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128, res_0);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 3;\n+\n+    std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t   \"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+    std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t\t\"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+    auto array_a =\n+            MakeArrowArrayUtf8({\"foo\", first_string, second_string},\n+\t\t\t\t\t\t\t   {false, true, true});\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n\nReview comment:\n       I believe in Arrow we have ASSERT_OK, which should porbably be used (I don't think you want to continue if status isn't OK?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:35:46.374+0000",
                    "updated": "2021-03-19T03:35:46.374+0000",
                    "started": "2021-03-19T03:35:46.374+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568752",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568753",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597386124\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n\nReview comment:\n       constexpr?\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n\nReview comment:\n       constexpr?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:38:53.537+0000",
                    "updated": "2021-03-19T03:38:53.537+0000",
                    "started": "2021-03-19T03:38:53.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568753",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568756",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597387398\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n+\n+    int tmp_buf_len = 4;\n+\n+    auto hex_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, tmp_buf_len));\n+\n+    auto result_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, result_buf_size));\n+\n+    CleanCharArray(result_buffer);\n+    CleanCharArray(hex_buffer);\n+\n+    if (hex_buffer == nullptr || result_buffer == nullptr) {\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory \"\n+                                       \"for the result buffers.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    for (unsigned int j = 0; j < result_length; j++) {\n+      unsigned char hex_number = result[j];\n+      snprintf(hex_buffer, tmp_buf_len, \"%02x\", hex_number);\n\nReview comment:\n       it seems like you should snprintf to the final result_buffer directly and update the pointer using the returned value? (you porbably also want to at least DCHECK the result. \n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:43:36.519+0000",
                    "updated": "2021-03-19T03:43:36.519+0000",
                    "started": "2021-03-19T03:43:36.519+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568756",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568758",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597388281\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n\nReview comment:\n       this formatting looks strange.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:46:46.433+0000",
                    "updated": "2021-03-19T03:46:46.433+0000",
                    "started": "2021-03-19T03:46:46.433+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568758",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568760",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597389422\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n+    }                                                                                 \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);             \\\n+    const char *result = gandiva::HashUtils::HashUsingSha128(context,                 \\\n+                                                               &value_as_long,        \\\n+                                                               sizeof(value_as_long), \\\n+                                                               out_length);           \\\n+                                                                                      \\\n+    return result;                                                                    \\\n+  }                                                                                   \\\n+\n+#define SHA128_HASH_FUNCTION_BUF(TYPE)                                             \\\n+  GANDIVA_EXPORT                                                                   \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context,                                \\\n+                                        gdv_##TYPE value,                          \\\n+                                        int32_t value_length,                      \\\n+                                        bool value_validity,                       \\\n+                                        int32_t *out_length) {                     \\\n+    if (!value_validity) {                                                         \\\n+      *out_length = 0;                                                             \\\n+      return \"\";                                                                   \\\n+    }                                                                              \\\n+    return gandiva::HashUtils::HashUsingSha128(context, value,                     \\\n+    value_length, out_length);                                                     \\\n+  }\n+\n+#define SHA256_HASH_FUNCTION(TYPE)                                                      \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context, gdv_##TYPE value,                   \\\n+                                        bool validity, int32_t *out_length) {           \\\n+    if (!validity) {                                                                    \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);               \\\n+    const char *result = gandiva::HashUtils::HashUsingSha256(context,                   \\\n+                                                               &value_as_long,          \\\n\nReview comment:\n       it looks like this is a void*?  Why is the doubletolong conversion necessary?\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:50:34.812+0000",
                    "updated": "2021-03-19T03:50:34.812+0000",
                    "started": "2021-03-19T03:50:34.811+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568760",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568762",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597389947\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n+    }                                                                                 \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);             \\\n+    const char *result = gandiva::HashUtils::HashUsingSha128(context,                 \\\n+                                                               &value_as_long,        \\\n+                                                               sizeof(value_as_long), \\\n+                                                               out_length);           \\\n+                                                                                      \\\n+    return result;                                                                    \\\n+  }                                                                                   \\\n+\n+#define SHA128_HASH_FUNCTION_BUF(TYPE)                                             \\\n+  GANDIVA_EXPORT                                                                   \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context,                                \\\n+                                        gdv_##TYPE value,                          \\\n+                                        int32_t value_length,                      \\\n+                                        bool value_validity,                       \\\n+                                        int32_t *out_length) {                     \\\n+    if (!value_validity) {                                                         \\\n+      *out_length = 0;                                                             \\\n+      return \"\";                                                                   \\\n+    }                                                                              \\\n+    return gandiva::HashUtils::HashUsingSha128(context, value,                     \\\n+    value_length, out_length);                                                     \\\n+  }\n+\n+#define SHA256_HASH_FUNCTION(TYPE)                                                      \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context, gdv_##TYPE value,                   \\\n+                                        bool validity, int32_t *out_length) {           \\\n+    if (!validity) {                                                                    \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);               \\\n+    const char *result = gandiva::HashUtils::HashUsingSha256(context,                   \\\n+                                                               &value_as_long,          \\\n+                                                               sizeof(value_as_long),   \\\n+                                                               out_length);             \\\n+    return result;                                                                      \\\n+  }                                                                                     \\\n+\n+#define SHA256_HASH_FUNCTION_BUF(TYPE)                                                  \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context,                                     \\\n+                                        gdv_##TYPE value,                               \\\n+                                        int32_t value_length,                           \\\n+                                        bool value_validity,                            \\\n+                                        int32_t *out_length) {                          \\\n+    if (!value_validity) {                                                              \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    return gandiva::HashUtils::HashUsingSha256(context, value,                          \\\n+    value_length, out_length);                                                          \\\n+  }\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_NUMERIC_BOOL_DATE_PARAMS(INNER) \\\n+  INNER(int8)                          \\\n+  INNER(int16)                         \\\n+  INNER(int32)                         \\\n+  INNER(int64)                         \\\n+  INNER(uint8)                         \\\n+  INNER(uint16)                        \\\n+  INNER(uint32)                        \\\n+  INNER(uint64)                        \\\n+  INNER(float32)                       \\\n+  INNER(float64)                       \\\n+  INNER(boolean)                       \\\n+  INNER(date64)                        \\\n+  INNER(date32)                        \\\n+  INNER(time32)                        \\\n+  INNER(timestamp)\n+\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_VAR_LEN_PARAMS(INNER) \\\n+  INNER(utf8)                     \\\n+  INNER(binary)\n+\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA256_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA256_HASH_FUNCTION_BUF)\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA128_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA128_HASH_FUNCTION_BUF)\n+\n+#undef SHA_NUMERIC_BOOL_DATE_PARAMS\n+#undef SHA_VAR_LEN_PARAMS\n+\n+// Add functions for decimal128\n+GANDIVA_EXPORT\n+const char* gdv_fn_sha256_decimal128(int64_t context, int64_t x_high, uint64_t x_low,\n+                                     int32_t x_precision, int32_t x_scale,\n\nReview comment:\n       precision and scale don't look like they are being used.  If these parameters are necessary to fit into gandivas framework.  Commenting them out as int32_t /*x_precision*/ would make these clearer.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:52:56.256+0000",
                    "updated": "2021-03-19T03:52:56.256+0000",
                    "started": "2021-03-19T03:52:56.255+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568762",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "emkornfield commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597390160\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n+    }                                                                                 \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);             \\\n+    const char *result = gandiva::HashUtils::HashUsingSha128(context,                 \\\n+                                                               &value_as_long,        \\\n+                                                               sizeof(value_as_long), \\\n+                                                               out_length);           \\\n+                                                                                      \\\n+    return result;                                                                    \\\n+  }                                                                                   \\\n+\n+#define SHA128_HASH_FUNCTION_BUF(TYPE)                                             \\\n+  GANDIVA_EXPORT                                                                   \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context,                                \\\n+                                        gdv_##TYPE value,                          \\\n+                                        int32_t value_length,                      \\\n+                                        bool value_validity,                       \\\n+                                        int32_t *out_length) {                     \\\n+    if (!value_validity) {                                                         \\\n+      *out_length = 0;                                                             \\\n+      return \"\";                                                                   \\\n+    }                                                                              \\\n+    return gandiva::HashUtils::HashUsingSha128(context, value,                     \\\n+    value_length, out_length);                                                     \\\n+  }\n+\n+#define SHA256_HASH_FUNCTION(TYPE)                                                      \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context, gdv_##TYPE value,                   \\\n+                                        bool validity, int32_t *out_length) {           \\\n+    if (!validity) {                                                                    \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);               \\\n+    const char *result = gandiva::HashUtils::HashUsingSha256(context,                   \\\n+                                                               &value_as_long,          \\\n+                                                               sizeof(value_as_long),   \\\n+                                                               out_length);             \\\n+    return result;                                                                      \\\n+  }                                                                                     \\\n+\n+#define SHA256_HASH_FUNCTION_BUF(TYPE)                                                  \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context,                                     \\\n+                                        gdv_##TYPE value,                               \\\n+                                        int32_t value_length,                           \\\n+                                        bool value_validity,                            \\\n+                                        int32_t *out_length) {                          \\\n+    if (!value_validity) {                                                              \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    return gandiva::HashUtils::HashUsingSha256(context, value,                          \\\n+    value_length, out_length);                                                          \\\n+  }\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_NUMERIC_BOOL_DATE_PARAMS(INNER) \\\n+  INNER(int8)                          \\\n+  INNER(int16)                         \\\n+  INNER(int32)                         \\\n+  INNER(int64)                         \\\n+  INNER(uint8)                         \\\n+  INNER(uint16)                        \\\n+  INNER(uint32)                        \\\n+  INNER(uint64)                        \\\n+  INNER(float32)                       \\\n+  INNER(float64)                       \\\n+  INNER(boolean)                       \\\n+  INNER(date64)                        \\\n+  INNER(date32)                        \\\n+  INNER(time32)                        \\\n+  INNER(timestamp)\n+\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_VAR_LEN_PARAMS(INNER) \\\n+  INNER(utf8)                     \\\n+  INNER(binary)\n+\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA256_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA256_HASH_FUNCTION_BUF)\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA128_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA128_HASH_FUNCTION_BUF)\n+\n+#undef SHA_NUMERIC_BOOL_DATE_PARAMS\n+#undef SHA_VAR_LEN_PARAMS\n+\n+// Add functions for decimal128\n+GANDIVA_EXPORT\n+const char* gdv_fn_sha256_decimal128(int64_t context, int64_t x_high, uint64_t x_low,\n+                                     int32_t x_precision, int32_t x_scale,\n+                                     gdv_boolean x_isvalid, int32_t *out_length) {\n+  if (!x_isvalid) {\n+      *out_length = 0;\n+      return \"\";\n+  }\n+\n+  const auto &decimal_128 = gandiva::BasicDecimal128(x_high, x_low);\n+  return gandiva::HashUtils::HashUsingSha256(context, decimal_128.ToBytes().data(),\n+                                             16, out_length);\n+}\n+\n+GANDIVA_EXPORT\n+const char* gdv_fn_sha128_decimal128(int64_t context, int64_t x_high, uint64_t x_low,\n+                                     int32_t x_precision, int32_t x_scale,\n+                                     gdv_boolean x_isvalid, int32_t *out_length) {\n+  if (!x_isvalid) {\n+    *out_length = 0;\n+    return \"\";\n+  }\n+\n+  const auto &decimal_128 = gandiva::BasicDecimal128(x_high, x_low);\n\nReview comment:\n       This seems like a strange formulation?  Why note BasicDecimal128 decimal_128(x_high, x_low);\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T03:53:48.547+0000",
                    "updated": "2021-03-19T03:53:48.547+0000",
                    "started": "2021-03-19T03:53:48.547+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568764",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568954",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597711030\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n\nReview comment:\n       Added the implementation for the SHA hashes in null values.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T14:13:49.528+0000",
                    "updated": "2021-03-19T14:13:49.528+0000",
                    "started": "2021-03-19T14:13:49.528+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568954",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568955",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597711349\n\n\n\n##########\nFile path: cpp/src/gandiva/tests/hash_test.cc\n##########\n@@ -147,4 +153,252 @@ TEST_F(TestHash, TestBuf) {\n   }\n }\n \n+TEST_F(TestHash, TestSha256Simple) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", int32());\n+  auto field_b = field(\"b\", int64());\n+  auto field_c = field(\"c\", float32());\n+  auto field_d = field(\"d\", float64());\n+  auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+  auto res_1 = field(\"res1\", utf8());\n+  auto res_2 = field(\"res2\", utf8());\n+  auto res_3 = field(\"res3\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256_1 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256_1, res_0);\n+\n+  auto node_b = TreeExprBuilder::MakeField(field_b);\n+  auto hashSha256_2 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_b}, utf8());\n+  auto expr_1 = TreeExprBuilder::MakeExpression(hashSha256_2, res_1);\n+\n+  auto node_c = TreeExprBuilder::MakeField(field_c);\n+  auto hashSha256_3 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_c}, utf8());\n+  auto expr_2 = TreeExprBuilder::MakeExpression(hashSha256_3, res_2);\n+\n+  auto node_d = TreeExprBuilder::MakeField(field_d);\n+  auto hashSha256_4 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_d}, utf8());\n+  auto expr_3 = TreeExprBuilder::MakeExpression(hashSha256_4, res_3);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t  TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 2;\n+  auto validity_array = {false, true};\n+\n+  auto array_int32 =\n+      MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+  auto array_int64 =\n+      MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+  auto array_float32 =\n+      MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+  auto array_float64 =\n+      MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t   {array_int32, array_int64,\n+\t\t\t  array_float32, array_float64});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha256Varlen) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", utf8());\n+  auto schema = arrow::schema({field_a});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256, res_0);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 3;\n+\n+  std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY \"\n+\t\t\t\t\t\t\t \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+  std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY \"\n+\t\t\t\t\t\t\t  \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+  auto array_a =\n+      MakeArrowArrayUtf8({\"foo\", first_string, second_string}, {false, true, true});\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  auto response = outputs.at(0);\n+  EXPECT_EQ(response->null_count(), 0);\n+  EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+  for (int i = 1; i < num_records; ++i) {\n+    const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+    EXPECT_NE(value_at_position,\n+\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+  }\n+}\n+\n+TEST_F(TestHash, TestSha128Simple) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", int32());\n+    auto field_b = field(\"b\", int64());\n+    auto field_c = field(\"c\", float32());\n+    auto field_d = field(\"d\", float64());\n+    auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+    auto res_1 = field(\"res1\", utf8());\n+    auto res_2 = field(\"res2\", utf8());\n+    auto res_3 = field(\"res3\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128_1 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128_1, res_0);\n+\n+    auto node_b = TreeExprBuilder::MakeField(field_b);\n+    auto hashSha128_2 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_b}, utf8());\n+    auto expr_1 = TreeExprBuilder::MakeExpression(hashSha128_2, res_1);\n+\n+    auto node_c = TreeExprBuilder::MakeField(field_c);\n+    auto hashSha128_3 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_c}, utf8());\n+    auto expr_2 = TreeExprBuilder::MakeExpression(hashSha128_3, res_2);\n+\n+    auto node_d = TreeExprBuilder::MakeField(field_d);\n+    auto hashSha128_4 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_d}, utf8());\n+    auto expr_3 = TreeExprBuilder::MakeExpression(hashSha128_4, res_3);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t\t\tTestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 2;\n+    auto validity_array = {false, true};\n+\n+    auto array_int32 =\n+            MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+    auto array_int64 =\n+            MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+    auto array_float32 =\n+            MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+    auto array_float64 =\n+            MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t\t {array_int32, array_int64,\n+\t\t\t array_float32, array_float64});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha128Varlen) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", utf8());\n+    auto schema = arrow::schema({field_a});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128, res_0);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 3;\n+\n+    std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t   \"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+    std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t\t\"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+    auto array_a =\n+            MakeArrowArrayUtf8({\"foo\", first_string, second_string},\n+\t\t\t\t\t\t\t   {false, true, true});\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    auto response = outputs.at(0);\n+    EXPECT_EQ(response->null_count(), 0);\n+    EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+    for (int i = 1; i < num_records; ++i) {\n+        const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+        EXPECT_NE(value_at_position,\n+\t\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+    }\n\nReview comment:\n       Added the asserts for the hash size in the integration tests.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T14:14:14.871+0000",
                    "updated": "2021-03-19T14:14:14.871+0000",
                    "started": "2021-03-19T14:14:14.870+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568955",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568956",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597711666\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n\nReview comment:\n       I fixed it.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T14:14:40.172+0000",
                    "updated": "2021-03-19T14:14:40.172+0000",
                    "started": "2021-03-19T14:14:40.172+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568956",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568958",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597712192\n\n\n\n##########\nFile path: cpp/src/gandiva/function_registry_common.h\n##########\n@@ -199,6 +199,28 @@ typedef std::unordered_map<const FunctionSignature*, const NativeFunction*, KeyH\n                  DataTypeVector{TYPE(), int64()}, int64(), kResultNullNever, \\\n                  ARROW_STRINGIFY(NAME##WithSeed_##TYPE))\n \n+// HashSHA128 functions that :\n+// - NULL handling is of type NULL_NEVER\n+// - can return errors\n+//\n+// The function name includes the base name & input type name. gdv_fn_sha128_float64\n+#define HASH_SHA128_NULL_NEVER(NAME, ALIASES, TYPE)                           \\\n\nReview comment:\n       Already fixed.\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n\nReview comment:\n       Fixed.\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n\nReview comment:\n       Checks added.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T14:15:46.482+0000",
                    "updated": "2021-03-19T14:15:46.482+0000",
                    "started": "2021-03-19T14:15:46.482+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568958",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/568960",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597712805\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n+\n+    int tmp_buf_len = 4;\n+\n+    auto hex_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, tmp_buf_len));\n+\n+    auto result_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, result_buf_size));\n+\n+    CleanCharArray(result_buffer);\n+    CleanCharArray(hex_buffer);\n+\n+    if (hex_buffer == nullptr || result_buffer == nullptr) {\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory \"\n+                                       \"for the result buffers.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    for (unsigned int j = 0; j < result_length; j++) {\n+      unsigned char hex_number = result[j];\n+      snprintf(hex_buffer, tmp_buf_len, \"%02x\", hex_number);\n+      strncat(result_buffer, hex_buffer, tmp_buf_len);\n+    }\n+\n+    // Add the NULL character to shows the end of the string\n+    result_buffer[result_buf_size - 1] = '\\0';\n+\n+    // free the resources to avoid memory leaks\n+    EVP_MD_CTX_free(md_ctx);\n+    free(result);\n+\n+    *out_length = strlen(result_buffer);\n\nReview comment:\n       Suggestion applied.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T14:16:02.836+0000",
                    "updated": "2021-03-19T14:16:02.836+0000",
                    "started": "2021-03-19T14:16:02.835+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "568960",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/569012",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597852222\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n\nReview comment:\n       Added\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n\nReview comment:\n       Added\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T17:22:02.646+0000",
                    "updated": "2021-03-19T17:22:02.646+0000",
                    "started": "2021-03-19T17:22:02.646+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569012",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/569013",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597852581\n\n\n\n##########\nFile path: cpp/src/gandiva/tests/hash_test.cc\n##########\n@@ -147,4 +153,252 @@ TEST_F(TestHash, TestBuf) {\n   }\n }\n \n+TEST_F(TestHash, TestSha256Simple) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", int32());\n+  auto field_b = field(\"b\", int64());\n+  auto field_c = field(\"c\", float32());\n+  auto field_d = field(\"d\", float64());\n+  auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+  auto res_1 = field(\"res1\", utf8());\n+  auto res_2 = field(\"res2\", utf8());\n+  auto res_3 = field(\"res3\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256_1 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256_1, res_0);\n+\n+  auto node_b = TreeExprBuilder::MakeField(field_b);\n+  auto hashSha256_2 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_b}, utf8());\n+  auto expr_1 = TreeExprBuilder::MakeExpression(hashSha256_2, res_1);\n+\n+  auto node_c = TreeExprBuilder::MakeField(field_c);\n+  auto hashSha256_3 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_c}, utf8());\n+  auto expr_2 = TreeExprBuilder::MakeExpression(hashSha256_3, res_2);\n+\n+  auto node_d = TreeExprBuilder::MakeField(field_d);\n+  auto hashSha256_4 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_d}, utf8());\n+  auto expr_3 = TreeExprBuilder::MakeExpression(hashSha256_4, res_3);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t  TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 2;\n+  auto validity_array = {false, true};\n+\n+  auto array_int32 =\n+      MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+  auto array_int64 =\n+      MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+  auto array_float32 =\n+      MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+  auto array_float64 =\n+      MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t   {array_int32, array_int64,\n+\t\t\t  array_float32, array_float64});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+  EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha256Varlen) {\n+  // schema for input fields\n+  auto field_a = field(\"a\", utf8());\n+  auto schema = arrow::schema({field_a});\n+\n+  // output fields\n+  auto res_0 = field(\"res0\", utf8());\n+\n+  // build expressions.\n+  // hashSHA256(a)\n+  auto node_a = TreeExprBuilder::MakeField(field_a);\n+  auto hashSha256 = TreeExprBuilder::MakeFunction(\"hashSHA256\",\n+\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+  auto expr_0 = TreeExprBuilder::MakeExpression(hashSha256, res_0);\n+\n+  // Build a projector for the expressions.\n+  std::shared_ptr<Projector> projector;\n+  auto status =\n+      Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+  EXPECT_TRUE(status.ok()) << status.message();\n+\n+  // Create a row-batch with some sample data\n+  int num_records = 3;\n+\n+  std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY \"\n+\t\t\t\t\t\t\t \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+  std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY \"\n+\t\t\t\t\t\t\t  \"[\u02c8\u028fpsil\u0254n], Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+  auto array_a =\n+      MakeArrowArrayUtf8({\"foo\", first_string, second_string}, {false, true, true});\n+\n+  // prepare input record batch\n+  auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+  // Evaluate expression\n+  arrow::ArrayVector outputs;\n+  status = projector->Evaluate(*in_batch, pool_, &outputs);\n+  EXPECT_TRUE(status.ok());\n+\n+  auto response = outputs.at(0);\n+  EXPECT_EQ(response->null_count(), 0);\n+  EXPECT_EQ(response->GetScalar(0).ValueOrDie()->ToString(), \"\");\n+  for (int i = 1; i < num_records; ++i) {\n+    const auto &value_at_position = response->GetScalar(i).ValueOrDie()->ToString();\n+    EXPECT_NE(value_at_position,\n+\t\t\t  response->GetScalar(i - 1).ValueOrDie()->ToString());\n+  }\n+}\n+\n+TEST_F(TestHash, TestSha128Simple) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", int32());\n+    auto field_b = field(\"b\", int64());\n+    auto field_c = field(\"c\", float32());\n+    auto field_d = field(\"d\", float64());\n+    auto schema = arrow::schema({field_a, field_b, field_c, field_d});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+    auto res_1 = field(\"res1\", utf8());\n+    auto res_2 = field(\"res2\", utf8());\n+    auto res_3 = field(\"res3\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128_1 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128_1, res_0);\n+\n+    auto node_b = TreeExprBuilder::MakeField(field_b);\n+    auto hashSha128_2 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_b}, utf8());\n+    auto expr_1 = TreeExprBuilder::MakeExpression(hashSha128_2, res_1);\n+\n+    auto node_c = TreeExprBuilder::MakeField(field_c);\n+    auto hashSha128_3 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_c}, utf8());\n+    auto expr_2 = TreeExprBuilder::MakeExpression(hashSha128_3, res_2);\n+\n+    auto node_d = TreeExprBuilder::MakeField(field_d);\n+    auto hashSha128_4 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t  {node_d}, utf8());\n+    auto expr_3 = TreeExprBuilder::MakeExpression(hashSha128_4, res_3);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0, expr_1, expr_2, expr_3},\n+\t\t\t\t\t\t\tTestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 2;\n+    auto validity_array = {false, true};\n+\n+    auto array_int32 =\n+            MakeArrowArrayInt32({1, 0}, validity_array);\n+\n+    auto array_int64 =\n+            MakeArrowArrayInt64({1, 0}, validity_array);\n+\n+    auto array_float32 =\n+            MakeArrowArrayFloat32({1.0, 0.0}, validity_array);\n+\n+    auto array_float64 =\n+            MakeArrowArrayFloat64({1.0, 0.0}, validity_array);\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records,\n+\t\t\t\t\t\t\t\t\t\t\t {array_int32, array_int64,\n+\t\t\t array_float32, array_float64});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n+\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(0), outputs.at(1));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(1), outputs.at(2));\n+    EXPECT_ARROW_ARRAY_EQUALS(outputs.at(2), outputs.at(3));\n+}\n+\n+TEST_F(TestHash, TestSha128Varlen) {\n+    // schema for input fields\n+    auto field_a = field(\"a\", utf8());\n+    auto schema = arrow::schema({field_a});\n+\n+    // output fields\n+    auto res_0 = field(\"res0\", utf8());\n+\n+    // build expressions.\n+    // hashSHA128(a)\n+    auto node_a = TreeExprBuilder::MakeField(field_a);\n+    auto hashSha128 = TreeExprBuilder::MakeFunction(\"hashSHA128\",\n+\t\t\t\t\t\t\t\t\t\t\t\t\t{node_a}, utf8());\n+    auto expr_0 = TreeExprBuilder::MakeExpression(hashSha128, res_0);\n+\n+    // Build a projector for the expressions.\n+    std::shared_ptr<Projector> projector;\n+    auto status =\n+            Projector::Make(schema, {expr_0}, TestConfiguration(), &projector);\n+    EXPECT_TRUE(status.ok()) << status.message();\n+\n+    // Create a row-batch with some sample data\n+    int num_records = 3;\n+\n+    std::string first_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131\u0283n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t   \"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251]\";\n+    std::string second_string = \"\u00f0i \u0131nt\u0259\u02c8n\u00e6\u0283\u0259n\u0259l f\u0259\u02c8n\u025bt\u0131k \u0259so\u028asi\u02c8e\u0131n\\nY [\u02c8\u028fpsil\u0254n], \"\n+\t\t\t\t\t\t\t\t\"Yen [j\u025bn], Yoga [\u02c8jo\u02d0g\u0251] \u30b3\u30f3\u30cb\u30c1\u30cf\";\n+\n+    auto array_a =\n+            MakeArrowArrayUtf8({\"foo\", first_string, second_string},\n+\t\t\t\t\t\t\t   {false, true, true});\n+\n+    // prepare input record batch\n+    auto in_batch = arrow::RecordBatch::Make(schema, num_records, {array_a});\n+\n+    // Evaluate expression\n+    arrow::ArrayVector outputs;\n+    status = projector->Evaluate(*in_batch, pool_, &outputs);\n+    EXPECT_TRUE(status.ok());\n\nReview comment:\n       Changed the EXPECT_TRUE to ASSERT_OK\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T17:22:25.545+0000",
                    "updated": "2021-03-19T17:22:25.545+0000",
                    "started": "2021-03-19T17:22:25.545+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569013",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/569014",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597853314\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.h\n##########\n@@ -0,0 +1,54 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_SRC_HASH_UTILS_H_\n+#define ARROW_SRC_HASH_UTILS_H_\n+\n+#include <cstdlib>\n+#include <cstdint>\n+#include \"gandiva/visibility.h\"\n+#include \"openssl/evp.h\"\n+\n+namespace gandiva {\n+class GANDIVA_EXPORT HashUtils {\n+ public:\n+  static const char *HashUsingSha256(int64_t context,\n\nReview comment:\n       I removed the class and changed the functions to first class and I added the documentation for the functions.\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T17:23:18.874+0000",
                    "updated": "2021-03-19T17:23:18.874+0000",
                    "started": "2021-03-19T17:23:18.874+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569014",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/569015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597853507\n\n\n\n##########\nFile path: cpp/src/gandiva/hash_utils.cc\n##########\n@@ -0,0 +1,137 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <cstring>\n+#include \"openssl/evp.h\"\n+#include \"gandiva/hash_utils.h\"\n+#include \"gandiva/execution_context.h\"\n+#include \"gandiva/gdv_function_stubs.h\"\n+\n+namespace gandiva {\n+  const char* HashUtils::HashUsingSha256(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha256_result_length = 65;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha256(),\n+\t\t\t\t\t\t\t  sha256_result_length, out_length);\n+  }\n+  const char* HashUtils::HashUsingSha128(int64_t context,\n+                                         const void* message,\n+                                         size_t message_length,\n+                                         int32_t *out_length) {\n+    // The buffer size is the hash size + null character\n+    int sha128_result_length = 41;\n+    return HashUtils::GetHash(context, message, message_length, EVP_sha1(),\n+\t\t\t\t\t\t\t  sha128_result_length, out_length);\n+  }\n+\n+  const char* HashUtils::GetHash(int64_t context,\n+                                 const void* message,\n+                                 size_t message_length,\n+                                 const EVP_MD *hash_type,\n+                                 int result_buf_size,\n+                                 int32_t *out_length) {\n+    EVP_MD_CTX *md_ctx = EVP_MD_CTX_new();\n+\n+    if (md_ctx == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      return \"\";\n+    }\n+\n+    int evp_success_status = 1;\n+\n+    if (EVP_DigestInit_ex(md_ctx, hash_type, nullptr) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash \"\n+\t\t\t\t\t\t\t\t\t   \"for the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    if (EVP_DigestUpdate(md_ctx, message, message_length) != evp_success_status) {\n+      HashUtils::ErrorMessage(context, \"Could not obtain the hash for \"\n+\t\t\t\t\t\t\t\t\t   \"the defined value.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    int hash_size = EVP_MD_size(hash_type);\n+    auto* result = static_cast<unsigned char*>(OPENSSL_malloc(hash_size));\n+\n+    if (result == nullptr) {\n+      HashUtils::ErrorMessage(context, \"Could not allocate memory \"\n+\t\t\t\t\t\t\t\t\t   \"for SHA processing.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    unsigned int result_length;\n+    EVP_DigestFinal_ex(md_ctx, result, &result_length);\n+\n+    int tmp_buf_len = 4;\n+\n+    auto hex_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, tmp_buf_len));\n+\n+    auto result_buffer =\n+        reinterpret_cast<char*>(gdv_fn_context_arena_malloc(context, result_buf_size));\n+\n+    CleanCharArray(result_buffer);\n+    CleanCharArray(hex_buffer);\n+\n+    if (hex_buffer == nullptr || result_buffer == nullptr) {\n+      gdv_fn_context_set_error_msg(context, \"Could not allocate memory \"\n+                                       \"for the result buffers.\");\n+      EVP_MD_CTX_free(md_ctx);\n+      return \"\";\n+    }\n+\n+    for (unsigned int j = 0; j < result_length; j++) {\n+      unsigned char hex_number = result[j];\n+      snprintf(hex_buffer, tmp_buf_len, \"%02x\", hex_number);\n\nReview comment:\n       Suggestion applied\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T17:23:41.793+0000",
                    "updated": "2021-03-19T17:23:41.793+0000",
                    "started": "2021-03-19T17:23:41.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569015",
                    "issueId": "13365558"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/worklog/569016",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "anthonylouisbsb commented on a change in pull request #9707:\nURL: https://github.com/apache/arrow/pull/9707#discussion_r597854220\n\n\n\n##########\nFile path: cpp/src/gandiva/gdv_function_stubs.cc\n##########\n@@ -122,6 +123,133 @@ int32_t gdv_fn_populate_varlen_vector(int64_t context_ptr, int8_t* data_ptr,\n   return 0;\n }\n \n+#define SHA128_HASH_FUNCTION(TYPE)                                                    \\\n+  GANDIVA_EXPORT                                                                      \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context, gdv_##TYPE value,                 \\\n+                                        bool validity, int32_t *out_length) {         \\\n+    if (!validity) {                                                                  \\\n+      *out_length = 0;                                                                \\\n+      return \"\";                                                                      \\\n+    }                                                                                 \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);             \\\n+    const char *result = gandiva::HashUtils::HashUsingSha128(context,                 \\\n+                                                               &value_as_long,        \\\n+                                                               sizeof(value_as_long), \\\n+                                                               out_length);           \\\n+                                                                                      \\\n+    return result;                                                                    \\\n+  }                                                                                   \\\n+\n+#define SHA128_HASH_FUNCTION_BUF(TYPE)                                             \\\n+  GANDIVA_EXPORT                                                                   \\\n+  const char *gdv_fn_sha128_##TYPE(int64_t context,                                \\\n+                                        gdv_##TYPE value,                          \\\n+                                        int32_t value_length,                      \\\n+                                        bool value_validity,                       \\\n+                                        int32_t *out_length) {                     \\\n+    if (!value_validity) {                                                         \\\n+      *out_length = 0;                                                             \\\n+      return \"\";                                                                   \\\n+    }                                                                              \\\n+    return gandiva::HashUtils::HashUsingSha128(context, value,                     \\\n+    value_length, out_length);                                                     \\\n+  }\n+\n+#define SHA256_HASH_FUNCTION(TYPE)                                                      \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context, gdv_##TYPE value,                   \\\n+                                        bool validity, int32_t *out_length) {           \\\n+    if (!validity) {                                                                    \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+    auto value_as_long = gandiva::HashUtils::DoubleToLong((double)value);               \\\n+    const char *result = gandiva::HashUtils::HashUsingSha256(context,                   \\\n+                                                               &value_as_long,          \\\n+                                                               sizeof(value_as_long),   \\\n+                                                               out_length);             \\\n+    return result;                                                                      \\\n+  }                                                                                     \\\n+\n+#define SHA256_HASH_FUNCTION_BUF(TYPE)                                                  \\\n+  GANDIVA_EXPORT                                                                        \\\n+  const char *gdv_fn_sha256_##TYPE(int64_t context,                                     \\\n+                                        gdv_##TYPE value,                               \\\n+                                        int32_t value_length,                           \\\n+                                        bool value_validity,                            \\\n+                                        int32_t *out_length) {                          \\\n+    if (!value_validity) {                                                              \\\n+      *out_length = 0;                                                                  \\\n+      return \"\";                                                                        \\\n+    }                                                                                   \\\n+                                                                                        \\\n+    return gandiva::HashUtils::HashUsingSha256(context, value,                          \\\n+    value_length, out_length);                                                          \\\n+  }\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_NUMERIC_BOOL_DATE_PARAMS(INNER) \\\n+  INNER(int8)                          \\\n+  INNER(int16)                         \\\n+  INNER(int32)                         \\\n+  INNER(int64)                         \\\n+  INNER(uint8)                         \\\n+  INNER(uint16)                        \\\n+  INNER(uint32)                        \\\n+  INNER(uint64)                        \\\n+  INNER(float32)                       \\\n+  INNER(float64)                       \\\n+  INNER(boolean)                       \\\n+  INNER(date64)                        \\\n+  INNER(date32)                        \\\n+  INNER(time32)                        \\\n+  INNER(timestamp)\n+\n+\n+// Expand inner macro for all numeric types.\n+#define SHA_VAR_LEN_PARAMS(INNER) \\\n+  INNER(utf8)                     \\\n+  INNER(binary)\n+\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA256_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA256_HASH_FUNCTION_BUF)\n+\n+SHA_NUMERIC_BOOL_DATE_PARAMS(SHA128_HASH_FUNCTION)\n+SHA_VAR_LEN_PARAMS(SHA128_HASH_FUNCTION_BUF)\n+\n+#undef SHA_NUMERIC_BOOL_DATE_PARAMS\n+#undef SHA_VAR_LEN_PARAMS\n+\n+// Add functions for decimal128\n+GANDIVA_EXPORT\n+const char* gdv_fn_sha256_decimal128(int64_t context, int64_t x_high, uint64_t x_low,\n+                                     int32_t x_precision, int32_t x_scale,\n+                                     gdv_boolean x_isvalid, int32_t *out_length) {\n+  if (!x_isvalid) {\n+      *out_length = 0;\n+      return \"\";\n+  }\n+\n+  const auto &decimal_128 = gandiva::BasicDecimal128(x_high, x_low);\n+  return gandiva::HashUtils::HashUsingSha256(context, decimal_128.ToBytes().data(),\n+                                             16, out_length);\n+}\n+\n+GANDIVA_EXPORT\n+const char* gdv_fn_sha128_decimal128(int64_t context, int64_t x_high, uint64_t x_low,\n+                                     int32_t x_precision, int32_t x_scale,\n+                                     gdv_boolean x_isvalid, int32_t *out_length) {\n+  if (!x_isvalid) {\n+    *out_length = 0;\n+    return \"\";\n+  }\n+\n+  const auto &decimal_128 = gandiva::BasicDecimal128(x_high, x_low);\n\nReview comment:\n       I changed to `const BasicDecimal128 decimal_128(x_high, x_low)`\n\n\n\n\n-- \nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-19T17:24:44.763+0000",
                    "updated": "2021-03-19T17:24:44.763+0000",
                    "started": "2021-03-19T17:24:44.762+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "569016",
                    "issueId": "13365558"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/5",
            "id": "5",
            "description": "General wishlist item.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Wish",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 24600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@43069daa[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1ae05ce8[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15f57bb6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@d6a62fc[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7b8371ad[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@534e3af0[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@6dd8c3e4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@337b3121[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@539530fa[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@71ae19c2[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5ac223f0[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@305ae3b0[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 24600,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Apr 12 15:41:54 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-04-12T15:41:54.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11984/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-03-16T14:57:08.000+0000",
        "updated": "2021-04-12T15:41:54.000+0000",
        "timeoriginalestimate": null,
        "description": "Implement Gandiva C++ functions to process SHA128 and SHA256 algorithms on numeric and string fields.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "6h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 24600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++][Gandiva] Implement SHA1 and SHA256 functions ",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13365558/comment/17319519",
                    "id": "17319519",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 9707\n[https://github.com/apache/arrow/pull/9707]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=praveenbingo",
                        "name": "praveenbingo",
                        "key": "praveenbingo",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Praveen Kumar",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2021-04-12T15:41:54.516+0000",
                    "updated": "2021-04-12T15:41:54.516+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0oufc:",
        "customfield_12314139": null
    }
}