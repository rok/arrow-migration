{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13480029",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029",
    "key": "ARROW-17610",
    "fields": {
        "fixVersions": [],
        "resolution": null,
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/3",
            "description": "This issue is being actively worked on at the moment by the assignee.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/inprogress.png",
            "name": "In Progress",
            "id": "3",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/4",
                "id": 4,
                "key": "indeterminate",
                "colorName": "yellow",
                "name": "In Progress"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=rtpsw",
            "name": "rtpsw",
            "key": "JIRAUSER284707",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=JIRAUSER284707&avatarId=49322",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=JIRAUSER284707&avatarId=49322",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=JIRAUSER284707&avatarId=49322",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=JIRAUSER284707&avatarId=49322"
            },
            "displayName": "Yaron Gvili",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18600,
            "total": 18600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17610/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 31,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/806094",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw opened a new pull request, #14041:\nURL: https://github.com/apache/arrow/pull/14041\n\n   See https://issues.apache.org/jira/browse/ARROW-17610\n\n\n",
                    "created": "2022-09-05T06:55:25.648+0000",
                    "updated": "2022-09-05T06:55:25.648+0000",
                    "started": "2022-09-05T06:55:25.648+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806094",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/806095",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1236608263\n\n   https://issues.apache.org/jira/browse/ARROW-17610\n\n\n",
                    "created": "2022-09-05T06:55:58.774+0000",
                    "updated": "2022-09-05T06:55:58.774+0000",
                    "started": "2022-09-05T06:55:58.773+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806095",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/806283",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1237810404\n\n   @westonpace, I see you were involved in the [`Enumerated` code](https://github.com/apache/arrow/blame/master/cpp/src/arrow/util/async_generator.h#L1501-L1506) and I'd like to ask about it.\r\n   \r\n   Why `int`, and not `int64_t` for the index type? When I tried to change to `int64_t`, I observed failures in `arrow-dataset-datasdt-test` like:\r\n   ```\r\n   [ RUN      ] TestEndToEnd.EndToEndSingleDataset\r\n   /mnt/user1/tscontract/github/rtpsw/arrow/cpp/src/arrow/dataset/dataset_test.cc:468: Failure\r\n   Failed\r\n   '_error_or_value141.status()' failed with Invalid: Referenced field __fragment_index was int64 but should have been int32\r\n   [  FAILED  ] TestEndToEnd.EndToEndSingleDataset (6 ms)\r\n   ```\r\n   which could probably be fixed in the tester.\r\n   \r\n   Also, why `int` and not `int32_t`?\n\n\n",
                    "created": "2022-09-06T08:14:53.667+0000",
                    "updated": "2022-09-06T08:14:53.667+0000",
                    "started": "2022-09-06T08:14:53.667+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "806283",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807015",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r965898567\n\n\n##########\ncpp/src/arrow/compute/exec/options.h:\n##########\n@@ -77,6 +77,34 @@ class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n   int64_t max_batch_size;\n };\n \n+/// \\brief An extended Source node which accepts a schema\n+///\n+/// ItMaker is a maker of an iterator of tabular data.\n\nReview Comment:\n   Why are we taking in a factory?  It seems that `it_maker` is called exactly once, when the node is created.  So what is the advantage to accepting, for example, `std::function<Iterator<std::shared_ptr<ExecBatch>>()>` instead of `Iterator<std::shared_ptr<ExecBatch>>`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   Why are we enumerating and then unenumerating all these generators?\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n\nReview Comment:\n   Couldn't we default to some kind of default IO executor here?\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n\nReview Comment:\n   I think there are probably many places that would fail today if we had more than 2Bi batches.  That sort of scale is usually larger than a single node I think.\n\n\n\n",
                    "created": "2022-09-08T12:36:47.186+0000",
                    "updated": "2022-09-08T12:36:47.186+0000",
                    "started": "2022-09-08T12:36:47.186+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807015",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807075",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r966123088\n\n\n##########\ncpp/src/arrow/compute/exec/options.h:\n##########\n@@ -77,6 +77,34 @@ class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n   int64_t max_batch_size;\n };\n \n+/// \\brief An extended Source node which accepts a schema\n+///\n+/// ItMaker is a maker of an iterator of tabular data.\n\nReview Comment:\n   My (hopefully not wrong) understanding is that options should have value semantics, so that they could be safely copied or passed multiple times as an argument. A factory preserves this semantics whereas an iterator doesn't, because it is stateful.\n\n\n\n",
                    "created": "2022-09-08T15:37:11.575+0000",
                    "updated": "2022-09-08T15:37:11.575+0000",
                    "started": "2022-09-08T15:37:11.575+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807075",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807078",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r966128176\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n\nReview Comment:\n   IIRC, I ran into a runtime problem when creating a generator using a null executor. I'm not sure whether the alternative of using the default executor would work well for generators intended for IO, rather than CPU, work. I'm also not aware of a default IO executor, but if there is one then I'd try using it here.\n\n\n\n",
                    "created": "2022-09-08T15:41:47.019+0000",
                    "updated": "2022-09-08T15:41:47.019+0000",
                    "started": "2022-09-08T15:41:47.019+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807078",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807079",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r966131169\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n\nReview Comment:\n   I agree and thought about it too. However, note that `Enumerated` isn't specific for batches; it can enumerate anything coming out of an iterator, which might emit more than 2B items. I'm fine leaving it `int`, though I'd prefer `int32_t`.\n\n\n\n",
                    "created": "2022-09-08T15:44:37.337+0000",
                    "updated": "2022-09-08T15:44:37.337+0000",
                    "started": "2022-09-08T15:44:37.337+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807079",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807080",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r966134778\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   The problem is that a background generator, which is useful for overlapped IO, does not guarantee in-order delivery. My solution is to enumerate at the iterator, which does guarantee order, then apply the background generator, and finally sort by the enumeration. Though there might be a better way to do overlapped IO; I'd be interested in alternatives.\n\n\n\n",
                    "created": "2022-09-08T15:48:02.542+0000",
                    "updated": "2022-09-08T15:48:02.542+0000",
                    "started": "2022-09-08T15:48:02.542+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807080",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r967704194\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   It turns out my solution doesn't solve the problem - as before, I still see infrequent cases of out-of-order delivery when the IO-context has multiple threads. Even after examining a fair amount of Arrow code related to generators, and trying a couple of things, I still have no good idea how to fix this. OTOH, it looks like I'm not the only one, because there is an existing [unit test involving `SourceNode`](https://github.com/apache/arrow/blob/f184255cbb9bf911ea2a04910f711e1a924b12b8/cpp/src/arrow/compute/exec/plan_test.cc#L1429-L1459) that checks result batches match while ignoring their order. This suggests the possibility that the out-of-order-batches problem originates in `SourceNode`. I won't try to fix this problem in this PR and will instead resort to ignoring order in the unit tests.\n\n\n\n",
                    "created": "2022-09-10T21:18:53.406+0000",
                    "updated": "2022-09-10T21:18:53.406+0000",
                    "started": "2022-09-10T21:18:53.405+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807685",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807686",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r967704194\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   It turns out my solution doesn't solve the problem - as before, I still see infrequent cases of out-of-order delivery when the IO-context has multiple threads. Even after examining a fair amount of Arrow code related to generators, and trying a couple of things, I still have no good idea how to fix this. OTOH, it looks like I'm not the only one, because there is an existing [unit test involving `SourceNode`](https://github.com/apache/arrow/blob/f184255cbb9bf911ea2a04910f711e1a924b12b8/cpp/src/arrow/compute/exec/plan_test.cc#L1429-L1459) that [checks result batches match while ignoring their order](https://github.com/apache/arrow/blob/f184255cbb9bf911ea2a04910f711e1a924b12b8/cpp/src/arrow/compute/exec/plan_test.cc#L1457-L1458). This suggests the possibility that the out-of-order-batches problem originates in `SourceNode`. I won't try to fix this problem in this PR and will instead resort to ignoring order in the unit tests.\n\n\n\n",
                    "created": "2022-09-10T21:19:42.924+0000",
                    "updated": "2022-09-10T21:19:42.924+0000",
                    "started": "2022-09-10T21:19:42.923+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807686",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807691",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r967704194\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   It turns out my solution doesn't solve the problem - as before, I still see infrequent cases of out-of-order delivery when the IO-context has multiple threads. Even after examining a fair amount of Arrow code related to generators, and trying a couple of things, I still have no good idea how to fix this. OTOH, it looks like I'm not the only one, because there is an [existing multi-threaded unit test involving `SourceNode`](https://github.com/apache/arrow/blob/f184255cbb9bf911ea2a04910f711e1a924b12b8/cpp/src/arrow/compute/exec/plan_test.cc#L1429-L1459) that [checks result batches match while ignoring their order](https://github.com/apache/arrow/blob/f184255cbb9bf911ea2a04910f711e1a924b12b8/cpp/src/arrow/compute/exec/plan_test.cc#L1457-L1458). This suggests the possibility that the out-of-order-batches problem originates in `SourceNode`. I won't try to fix this problem in this PR and will instead resort to ignoring order in the unit tests.\n\n\n\n",
                    "created": "2022-09-10T21:30:35.430+0000",
                    "updated": "2022-09-10T21:30:35.430+0000",
                    "started": "2022-09-10T21:30:35.430+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807691",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/807716",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1242900287\n\n   The recent commit adds support for a maker of `RecordBatchReader`, since it is now a `RecordBatch` iterator.\n\n\n",
                    "created": "2022-09-11T06:52:52.557+0000",
                    "updated": "2022-09-11T06:52:52.557+0000",
                    "started": "2022-09-11T06:52:52.556+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "807716",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/808149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r969268853\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n+\n+    return Status::OK();\n+  }\n+\n+  template <typename Item>\n+  static Iterator<Enumerated<Item>> MakeEnumeratedIterator(Iterator<Item> it) {\n+    // TODO: Should Enumerated<>.index be changed to int64_t? Currently, this change\n+    // causes dataset unit-test failures\n+    using index_t = decltype(Enumerated<Item>{}.index);\n+    struct {\n+      index_t index = 0;\n+      Enumerated<Item> operator()(const Item& item) {\n+        return Enumerated<Item>{item, index++, false};\n+      }\n+    } enumerator;\n+    return MakeMapIterator(std::move(enumerator), std::move(it));\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeUnenumeratedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& enum_gen) {\n+    using Enum = Enumerated<Item>;\n+    return MakeMappedGenerator(enum_gen, [](const Enum& e) { return e.value; });\n+  }\n+\n+  template <typename Item>\n+  static arrow::AsyncGenerator<Item> MakeOrderedGenerator(\n+      const arrow::AsyncGenerator<Enumerated<Item>>& unordered_gen) {\n+    using Enum = Enumerated<Item>;\n+    auto enum_gen = MakeSequencingGenerator(\n+        unordered_gen,\n+        /*compare=*/[](const Enum& a, const Enum& b) { return a.index > b.index; },\n+        /*is_next=*/[](const Enum& a, const Enum& b) { return a.index + 1 == b.index; },\n+        /*initial_value=*/Enum{{}, 0});\n+    return MakeUnenumeratedGenerator(enum_gen);\n+  }\n+};\n+\n+struct RecordBatchSourceNode\n+    : public SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions> {\n+  using RecordBatchSchemaSourceNode =\n+      SchemaSourceNode<RecordBatchSourceNode, RecordBatchSourceNodeOptions>;\n+\n+  using RecordBatchSchemaSourceNode::RecordBatchSchemaSourceNode;\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    return RecordBatchSchemaSourceNode::Make(plan, inputs, options);\n+  }\n+\n+  const char* kind_name() const override { return kKindName; }\n+\n+  static Result<arrow::AsyncGenerator<util::optional<ExecBatch>>> MakeGenerator(\n+      Iterator<std::shared_ptr<RecordBatch>>& batch_it,\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema) {\n+    auto to_exec_batch =\n+        [schema](const std::shared_ptr<RecordBatch>& batch) -> util::optional<ExecBatch> {\n+      if (batch == NULLPTR || *batch->schema() != *schema) {\n+        return util::nullopt;\n+      }\n+      return util::optional<ExecBatch>(ExecBatch(*batch));\n+    };\n+    auto exec_batch_it = MakeMapIterator(to_exec_batch, std::move(batch_it));\n+    auto enum_it = MakeEnumeratedIterator(std::move(exec_batch_it));\n+    ARROW_ASSIGN_OR_RAISE(auto enum_gen,\n+                          MakeBackgroundGenerator(std::move(enum_it), io_executor));\n+    return MakeUnenumeratedGenerator(std::move(enum_gen));\n\nReview Comment:\n   Note that there is an [archived Apache Arrow Dev discussion of the batch ordering issue](https://lists.apache.org/thread/hw50v4qllqh9f0qxtv3xc25w0cq9l2og).\n\n\n\n",
                    "created": "2022-09-13T07:49:50.327+0000",
                    "updated": "2022-09-13T07:49:50.327+0000",
                    "started": "2022-09-13T07:49:50.326+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "808149",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/810473",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1252743524\n\n   Ping @westonpace\n\n\n",
                    "created": "2022-09-20T18:21:22.628+0000",
                    "updated": "2022-09-20T18:21:22.628+0000",
                    "started": "2022-09-20T18:21:22.627+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810473",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/810897",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "westonpace commented on code in PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#discussion_r976781115\n\n\n##########\ncpp/src/arrow/compute/exec/plan_test.cc:\n##########\n@@ -296,6 +296,148 @@ TEST(ExecPlanExecution, TableSourceSinkError) {\n               Raises(StatusCode::Invalid, HasSubstr(\"batch_size > 0\")));\n }\n \n+TEST(ExecPlanExecution, ArrayVectorSourceSink) {\n+  for (int num_threads : {1, 4}) {\n+    ASSERT_OK_AND_ASSIGN(auto io_executor,\n+                         arrow::internal::ThreadPool::Make(num_threads));\n+    ExecContext exec_context(default_memory_pool(), io_executor.get());\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(&exec_context));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    auto exp_batches = MakeBasicBatches();\n+    ASSERT_OK_AND_ASSIGN(auto arrayvecs, ToArrayVectors(exp_batches));\n+    auto arrayvec_it_maker = [&arrayvecs]() {\n+      return MakeVectorIterator<std::shared_ptr<ArrayVector>>(arrayvecs);\n+    };\n+\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"array_source\", ArrayVectorSourceNodeOptions{exp_batches.schema,\n+                                                                    arrayvec_it_maker}},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}},\n+                  })\n+                  .AddToPlan(plan.get()));\n+\n+    ASSERT_THAT(StartAndCollect(plan.get(), sink_gen),\n+                Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches))));\n+  }\n+}\n+\n+TEST(ExecPlanExecution, ArrayVectorSourceSinkError) {\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+  std::shared_ptr<Schema> no_schema;\n+\n+  auto exp_batches = MakeBasicBatches();\n+  ASSERT_OK_AND_ASSIGN(auto arrayvecs, ToArrayVectors(exp_batches));\n+  auto arrayvec_it_maker = [&arrayvecs]() {\n+    return MakeVectorIterator<std::shared_ptr<ArrayVector>>(arrayvecs);\n+  };\n+\n+  auto null_executor_options =\n+      ArrayVectorSourceNodeOptions{exp_batches.schema, arrayvec_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"array_source\", plan.get(), {}, null_executor_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+\n+  auto null_schema_options = ArrayVectorSourceNodeOptions{no_schema, arrayvec_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"array_source\", plan.get(), {}, null_schema_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+}\n+\n+TEST(ExecPlanExecution, ExecBatchSourceSink) {\n+  for (int num_threads : {1, 4}) {\n+    ASSERT_OK_AND_ASSIGN(auto io_executor,\n+                         arrow::internal::ThreadPool::Make(num_threads));\n+    ExecContext exec_context(default_memory_pool(), io_executor.get());\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(&exec_context));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    auto exp_batches = MakeBasicBatches();\n+    ASSERT_OK_AND_ASSIGN(auto exec_batches, ToExecBatches(exp_batches));\n+    auto exec_batch_it_maker = [&exec_batches]() {\n+      return MakeVectorIterator<std::shared_ptr<ExecBatch>>(exec_batches);\n+    };\n+\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"exec_source\", ExecBatchSourceNodeOptions{exp_batches.schema,\n\nReview Comment:\n   Hmm, I'm don't know that `exec_source` or `record_source` are very clear out of context.  How about `batch_source` and `exec_batch_source`?\n\n\n\n##########\ncpp/src/arrow/compute/exec/plan_test.cc:\n##########\n@@ -296,6 +296,148 @@ TEST(ExecPlanExecution, TableSourceSinkError) {\n               Raises(StatusCode::Invalid, HasSubstr(\"batch_size > 0\")));\n }\n \n+TEST(ExecPlanExecution, ArrayVectorSourceSink) {\n+  for (int num_threads : {1, 4}) {\n\nReview Comment:\n   Testing with a different number of threads is probably overkill for this feature.  I'm guessing this was from testing ordered sources?  It's a nit but it might be nice to remove this excess complexity.\n\n\n\n##########\ncpp/src/arrow/compute/exec/plan_test.cc:\n##########\n@@ -296,6 +296,148 @@ TEST(ExecPlanExecution, TableSourceSinkError) {\n               Raises(StatusCode::Invalid, HasSubstr(\"batch_size > 0\")));\n }\n \n+TEST(ExecPlanExecution, ArrayVectorSourceSink) {\n+  for (int num_threads : {1, 4}) {\n+    ASSERT_OK_AND_ASSIGN(auto io_executor,\n+                         arrow::internal::ThreadPool::Make(num_threads));\n+    ExecContext exec_context(default_memory_pool(), io_executor.get());\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(&exec_context));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    auto exp_batches = MakeBasicBatches();\n+    ASSERT_OK_AND_ASSIGN(auto arrayvecs, ToArrayVectors(exp_batches));\n+    auto arrayvec_it_maker = [&arrayvecs]() {\n+      return MakeVectorIterator<std::shared_ptr<ArrayVector>>(arrayvecs);\n+    };\n+\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"array_source\", ArrayVectorSourceNodeOptions{exp_batches.schema,\n+                                                                    arrayvec_it_maker}},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}},\n+                  })\n+                  .AddToPlan(plan.get()));\n+\n+    ASSERT_THAT(StartAndCollect(plan.get(), sink_gen),\n+                Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches))));\n+  }\n+}\n+\n+TEST(ExecPlanExecution, ArrayVectorSourceSinkError) {\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+  std::shared_ptr<Schema> no_schema;\n+\n+  auto exp_batches = MakeBasicBatches();\n+  ASSERT_OK_AND_ASSIGN(auto arrayvecs, ToArrayVectors(exp_batches));\n+  auto arrayvec_it_maker = [&arrayvecs]() {\n+    return MakeVectorIterator<std::shared_ptr<ArrayVector>>(arrayvecs);\n+  };\n+\n+  auto null_executor_options =\n+      ArrayVectorSourceNodeOptions{exp_batches.schema, arrayvec_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"array_source\", plan.get(), {}, null_executor_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+\n+  auto null_schema_options = ArrayVectorSourceNodeOptions{no_schema, arrayvec_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"array_source\", plan.get(), {}, null_schema_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+}\n+\n+TEST(ExecPlanExecution, ExecBatchSourceSink) {\n+  for (int num_threads : {1, 4}) {\n+    ASSERT_OK_AND_ASSIGN(auto io_executor,\n+                         arrow::internal::ThreadPool::Make(num_threads));\n+    ExecContext exec_context(default_memory_pool(), io_executor.get());\n+    ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make(&exec_context));\n+    AsyncGenerator<util::optional<ExecBatch>> sink_gen;\n+\n+    auto exp_batches = MakeBasicBatches();\n+    ASSERT_OK_AND_ASSIGN(auto exec_batches, ToExecBatches(exp_batches));\n+    auto exec_batch_it_maker = [&exec_batches]() {\n+      return MakeVectorIterator<std::shared_ptr<ExecBatch>>(exec_batches);\n+    };\n+\n+    ASSERT_OK(Declaration::Sequence(\n+                  {\n+                      {\"exec_source\", ExecBatchSourceNodeOptions{exp_batches.schema,\n+                                                                 exec_batch_it_maker}},\n+                      {\"sink\", SinkNodeOptions{&sink_gen}},\n+                  })\n+                  .AddToPlan(plan.get()));\n+\n+    ASSERT_THAT(StartAndCollect(plan.get(), sink_gen),\n+                Finishes(ResultWith(UnorderedElementsAreArray(exp_batches.batches))));\n+  }\n+}\n+\n+TEST(ExecPlanExecution, ExecBatchSourceSinkError) {\n+  ASSERT_OK_AND_ASSIGN(auto plan, ExecPlan::Make());\n+  std::shared_ptr<Schema> no_schema;\n+\n+  auto exp_batches = MakeBasicBatches();\n+  ASSERT_OK_AND_ASSIGN(auto exec_batches, ToExecBatches(exp_batches));\n+  auto exec_batch_it_maker = [&exec_batches]() {\n+    return MakeVectorIterator<std::shared_ptr<ExecBatch>>(exec_batches);\n+  };\n+\n+  auto null_executor_options =\n+      ExecBatchSourceNodeOptions{exp_batches.schema, exec_batch_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"exec_source\", plan.get(), {}, null_executor_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+\n+  auto null_schema_options = ExecBatchSourceNodeOptions{no_schema, exec_batch_it_maker};\n+  ASSERT_THAT(MakeExecNode(\"exec_source\", plan.get(), {}, null_schema_options),\n+              Raises(StatusCode::Invalid, HasSubstr(\"not null\")));\n+}\n+\n+TEST(ExecPlanExecution, RecordBatchSourceSink) {\n\nReview Comment:\n   I think there's a lot of duplication between these three sources.  Would it be possible to turn these into some kind of parameterized test?\n\n\n\n##########\ncpp/src/arrow/compute/exec/source_node.cc:\n##########\n@@ -291,13 +291,194 @@ struct TableSourceNode : public SourceNode {\n   }\n };\n \n+template <typename This, typename Options>\n+struct SchemaSourceNode : public SourceNode {\n+  SchemaSourceNode(ExecPlan* plan, std::shared_ptr<Schema> schema,\n+                   arrow::AsyncGenerator<util::optional<ExecBatch>> generator)\n+      : SourceNode(plan, schema, generator) {}\n+\n+  static Result<ExecNode*> Make(ExecPlan* plan, std::vector<ExecNode*> inputs,\n+                                const ExecNodeOptions& options) {\n+    RETURN_NOT_OK(ValidateExecNodeInputs(plan, inputs, 0, This::kKindName));\n+    const auto& cast_options = checked_cast<const Options&>(options);\n+    auto& it_maker = cast_options.it_maker;\n+    auto& schema = cast_options.schema;\n+\n+    auto io_executor = plan->exec_context()->executor();\n+    auto it = it_maker();\n+\n+    RETURN_NOT_OK(ValidateSchemaSourceNodeInput(io_executor, schema, This::kKindName));\n+    ARROW_ASSIGN_OR_RAISE(auto generator, This::MakeGenerator(it, io_executor, schema));\n+    return plan->EmplaceNode<This>(plan, schema, generator);\n+  }\n+\n+  static arrow::Status ValidateSchemaSourceNodeInput(\n+      arrow::internal::Executor* io_executor, const std::shared_ptr<Schema>& schema,\n+      const char* kKindName) {\n+    if (schema == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires schema which is not null\");\n+    }\n+    if (io_executor == NULLPTR) {\n+      return Status::Invalid(kKindName, \" requires IO-executor which is not null\");\n+    }\n\nReview Comment:\n   `default_io_context().executor()` should work.  Or, more directly, `io::internal::GetIOThreadPool()`\n\n\n\n##########\ncpp/src/arrow/compute/exec/options.h:\n##########\n@@ -77,6 +78,34 @@ class ARROW_EXPORT TableSourceNodeOptions : public ExecNodeOptions {\n   int64_t max_batch_size;\n };\n \n+/// \\brief An extended Source node which accepts a schema\n+///\n+/// ItMaker is a maker of an iterator of tabular data.\n+template <typename ItMaker>\n+class ARROW_EXPORT SchemaSourceNodeOptions : public ExecNodeOptions {\n+ public:\n+  SchemaSourceNodeOptions(std::shared_ptr<Schema> schema, ItMaker it_maker)\n+      : schema(schema), it_maker(std::move(it_maker)) {}\n+\n+  // the schema of the record batches from the iterator\n+  std::shared_ptr<Schema> schema;\n+\n+  // maker of an iterator which acts as the data source\n+  ItMaker it_maker;\n+};\n+\n+/// \\brief An extended Source node which accepts a schema and array-vectors\n+using ArrayVectorIteratorMaker = std::function<Iterator<std::shared_ptr<ArrayVector>>()>;\n+using ArrayVectorSourceNodeOptions = SchemaSourceNodeOptions<ArrayVectorIteratorMaker>;\n+\n+using ExecBatchIteratorMaker = std::function<Iterator<std::shared_ptr<ExecBatch>>()>;\n\nReview Comment:\n   It might be nice to have just `Iterator<ExecBatch>` and drop the `shared_ptr` but I suppose we would need to introduce an \"end batch\" concept.  Mostly an observation.  No action required.\n\n\n\n",
                    "created": "2022-09-21T17:06:01.017+0000",
                    "updated": "2022-09-21T17:06:01.017+0000",
                    "started": "2022-09-21T17:06:01.017+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810897",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/810948",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1254212121\n\n   @westonpace, any idea about the CI compilation errors? It's complaining (also) about code I haven't changed, which is suspicious.\n\n\n",
                    "created": "2022-09-21T20:48:15.943+0000",
                    "updated": "2022-09-21T20:48:15.943+0000",
                    "started": "2022-09-21T20:48:15.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "810948",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/811195",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1254955012\n\n   @rtpsw Looking at the number of lines changed here, it seems this PR got astray from git master at some point. Perhaps close this and open a new clean PR?\n\n\n",
                    "created": "2022-09-22T12:29:52.968+0000",
                    "updated": "2022-09-22T12:29:52.968+0000",
                    "started": "2022-09-22T12:29:52.968+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811195",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/811198",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw closed pull request #14041: ARROW-17610: [C++] Support additional source types in SourceNode\nURL: https://github.com/apache/arrow/pull/14041\n\n\n",
                    "created": "2022-09-22T12:31:20.995+0000",
                    "updated": "2022-09-22T12:31:20.995+0000",
                    "started": "2022-09-22T12:31:20.994+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811198",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/811216",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw opened a new pull request, #14207:\nURL: https://github.com/apache/arrow/pull/14207\n\n   See https://issues.apache.org/jira/browse/ARROW-17610\n\n\n",
                    "created": "2022-09-22T12:55:53.060+0000",
                    "updated": "2022-09-22T12:55:53.060+0000",
                    "started": "2022-09-22T12:55:53.059+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811216",
                    "issueId": "13480029"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13480029/worklog/811217",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "rtpsw commented on PR #14041:\nURL: https://github.com/apache/arrow/pull/14041#issuecomment-1254984903\n\n   Replaced by https://github.com/apache/arrow/pull/14207\n\n\n",
                    "created": "2022-09-22T12:56:12.264+0000",
                    "updated": "2022-09-22T12:56:12.264+0000",
                    "started": "2022-09-22T12:56:12.264+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "811217",
                    "issueId": "13480029"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 18600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@79e85a4[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e7f7b37[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@718cd98a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@144fb24f[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e91bd4c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@5a47d703[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4d101548[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@24a40b6f[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@17eca96a[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@73779b5b[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3e007a28[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@3afbe1f4[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18600,
        "customfield_12312520": null,
        "customfield_12312521": "2022-09-04 16:22:40.0",
        "customfield_12314422": null,
        "customfield_12314421": [
            "C++"
        ],
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": null,
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-17610/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2022-09-04T16:22:40.000+0000",
        "updated": "2022-11-06T14:03:36.000+0000",
        "timeoriginalestimate": null,
        "description": "This issue will add support for `ArrayVector`, `ExecBatch`, and `RecordBatch` sources in `SourceNode`. See [this thread|https://lists.apache.org/thread/9l23c0w48ywx314klbyshz8ntyzgs1zw] for context.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h 10m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Support additional source types in SourceNode",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [],
            "maxResults": 0,
            "total": 0,
            "startAt": 0
        },
        "customfield_12311820": "0|z18ayg:",
        "customfield_12314139": null
    }
}