{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13154241",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241",
    "key": "ARROW-2489",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12332956",
                "id": "12332956",
                "name": "C++ - Plasma"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333104",
                "id": "12333104",
                "name": "GPU"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 6000,
            "total": 6000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2489/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 10,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94295",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183535051\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Shouldn't PIMPLs be at least a `unique_ptr`?\r\n   \r\n   Note that we might should use something of the lines of http://brotherst-code.blogspot.de/2015/09/the-pimpl-idiom-youre-doing-it-wrong.html as we would still run into the problem of const correctness with PIMPLs otherwise. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-23T20:56:06.595+0000",
                    "updated": "2018-04-23T20:56:06.595+0000",
                    "started": "2018-04-23T20:56:06.594+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94295",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94308",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183541655\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Oh, that's an interesting issue. We may want to open a JIRA about that.\r\n   \r\n   As for the pointer kind: we will need `shared_ptr` to solve ARROW-2448. We can use `unique_ptr` in this PR and change it later if you prefer (but that'll probably change the ABI).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-23T21:20:53.745+0000",
                    "updated": "2018-04-23T21:20:53.745+0000",
                    "started": "2018-04-23T21:20:53.744+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94308",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94336",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183556731\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Yeah, we will need the shared_ptr so I'm in favor of leaving it. I wonder if there is a good way to get the PIIMPL const correctness with the shared pointer.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-23T22:31:08.810+0000",
                    "updated": "2018-04-23T22:31:08.810+0000",
                    "started": "2018-04-23T22:31:08.809+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94336",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94337",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183556731\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Yeah, we will need the shared_ptr so I'm in favor of leaving it. I wonder if there is a good way to get the PIMPL const correctness with the shared pointer.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-23T22:31:17.775+0000",
                    "updated": "2018-04-23T22:31:17.775+0000",
                    "started": "2018-04-23T22:31:17.775+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94337",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94338",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183556980\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   For `PlasmaClient` I don't think const-ness is a very useful piece of information. It's a thing that talks over the network (what is a const TCP connection?).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-23T22:32:25.783+0000",
                    "updated": "2018-04-23T22:32:25.783+0000",
                    "started": "2018-04-23T22:32:25.782+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94338",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94456",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183606190\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Yeah, I agree!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T05:09:02.869+0000",
                    "updated": "2018-04-24T05:09:02.869+0000",
                    "started": "2018-04-24T05:09:02.858+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94456",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94457",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "robertnishihara commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183606199\n \n \n\n ##########\n File path: cpp/src/plasma/client.cc\n ##########\n @@ -26,6 +26,7 @@\n #include <assert.h>\n #include <fcntl.h>\n #include <netinet/in.h>\n+#include <stdbool.h>\n \n Review comment:\n   We can probably remove this.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T05:09:07.980+0000",
                    "updated": "2018-04-24T05:09:07.980+0000",
                    "started": "2018-04-24T05:09:07.979+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94457",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94484",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183621196\n \n \n\n ##########\n File path: cpp/src/plasma/client.cc\n ##########\n @@ -26,6 +26,7 @@\n #include <assert.h>\n #include <fcntl.h>\n #include <netinet/in.h>\n+#include <stdbool.h>\n \n Review comment:\n   Merging this now, I'll remove the include in https://github.com/apache/arrow/pull/1939\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T06:53:49.279+0000",
                    "updated": "2018-04-24T06:53:49.279+0000",
                    "started": "2018-04-24T06:53:49.279+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94484",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94485",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pcmoritz closed pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/plasma/client.cc b/cpp/src/plasma/client.cc\nindex 015c9731a..733217d02 100644\n--- a/cpp/src/plasma/client.cc\n+++ b/cpp/src/plasma/client.cc\n@@ -26,6 +26,7 @@\n #include <assert.h>\n #include <fcntl.h>\n #include <netinet/in.h>\n+#include <stdbool.h>\n #include <stdio.h>\n #include <stdlib.h>\n #include <strings.h>\n@@ -34,10 +35,14 @@\n #include <sys/socket.h>\n #include <sys/types.h>\n #include <sys/un.h>\n+#include <time.h>\n #include <unistd.h>\n \n #include <algorithm>\n+#include <deque>\n #include <mutex>\n+#include <thread>\n+#include <unordered_map>\n #include <vector>\n \n #include \"arrow/buffer.h\"\n@@ -66,17 +71,43 @@ namespace plasma {\n \n using arrow::MutableBuffer;\n \n+typedef struct XXH64_state_s XXH64_state_t;\n+\n // Number of threads used for memcopy and hash computations.\n constexpr int64_t kThreadPoolSize = 8;\n constexpr int64_t kBytesInMB = 1 << 20;\n \n+// Use 100MB as an overestimate of the L3 cache size.\n+constexpr int64_t kL3CacheSizeBytes = 100000000;\n+\n+// ----------------------------------------------------------------------\n+// GPU support\n+\n+#ifdef PLASMA_GPU\n+struct GpuProcessHandle {\n+  /// Pointer to CUDA buffer that is backing this GPU object.\n+  std::shared_ptr<CudaBuffer> ptr;\n+  /// Number of client using this GPU object.\n+  int client_count;\n+};\n+\n+// This is necessary as IPC handles can only be mapped once per process.\n+// Thus if multiple clients in the same process get the same gpu object,\n+// they need to access the same mapped CudaBuffer.\n+static std::unordered_map<ObjectID, GpuProcessHandle*, UniqueIDHasher> gpu_object_map;\n+static std::mutex gpu_mutex;\n+#endif\n+\n+// ----------------------------------------------------------------------\n+// PlasmaBuffer\n+\n /// A Buffer class that automatically releases the backing plasma object\n /// when it goes out of scope.\n-class PlasmaBuffer : public Buffer {\n+class ARROW_NO_EXPORT PlasmaBuffer : public Buffer {\n  public:\n   ~PlasmaBuffer();\n \n-  PlasmaBuffer(PlasmaClient* client, const ObjectID& object_id,\n+  PlasmaBuffer(PlasmaClient::Impl* client, const ObjectID& object_id,\n                const std::shared_ptr<Buffer>& buffer)\n       : Buffer(buffer, 0, buffer->size()), client_(client), object_id_(object_id) {\n     if (buffer->is_mutable()) {\n@@ -85,11 +116,12 @@ class PlasmaBuffer : public Buffer {\n   }\n \n  private:\n-  PlasmaClient* client_;\n+  PlasmaClient::Impl* client_;\n   ObjectID object_id_;\n };\n \n-PlasmaBuffer::~PlasmaBuffer() { ARROW_UNUSED(client_->Release(object_id_)); }\n+// ----------------------------------------------------------------------\n+// PlasmaClient::Impl\n \n struct ObjectInUseEntry {\n   /// A count of the number of times this client has called PlasmaClient::Create\n@@ -105,33 +137,158 @@ struct ObjectInUseEntry {\n   bool is_sealed;\n };\n \n-#ifdef PLASMA_GPU\n-struct GpuProcessHandle {\n-  /// Pointer to CUDA buffer that is backing this GPU object.\n-  std::shared_ptr<CudaBuffer> ptr;\n-  /// Number of client using this GPU object.\n-  int client_count;\n+/// Configuration options for the plasma client.\n+struct PlasmaClientConfig {\n+  /// Number of release calls we wait until the object is actually released.\n+  /// This allows us to avoid invalidating the cpu cache on workers if objects\n+  /// are reused accross tasks.\n+  size_t release_delay;\n };\n \n-// This is necessary as IPC handles can only be mapped once per process.\n-// Thus if multiple clients in the same process get the same gpu object,\n-// they need to access the same mapped CudaBuffer.\n-static std::unordered_map<ObjectID, GpuProcessHandle*, UniqueIDHasher> gpu_object_map;\n-static std::mutex gpu_mutex;\n+struct ClientMmapTableEntry {\n+  /// The result of mmap for this file descriptor.\n+  uint8_t* pointer;\n+  /// The length of the memory-mapped file.\n+  size_t length;\n+  /// The number of objects in this memory-mapped file that are currently being\n+  /// used by the client. When this count reaches zeros, we unmap the file.\n+  int count;\n+};\n+\n+class PlasmaClient::Impl {\n+ public:\n+  Impl();\n+  ~Impl();\n+\n+  // PlasmaClient method implementations\n+\n+  Status Connect(const std::string& store_socket_name,\n+                 const std::string& manager_socket_name, int release_delay,\n+                 int num_retries = -1);\n+\n+  Status Create(const ObjectID& object_id, int64_t data_size, const uint8_t* metadata,\n+                int64_t metadata_size, std::shared_ptr<Buffer>* data, int device_num = 0);\n+\n+  Status Get(const std::vector<ObjectID>& object_ids, int64_t timeout_ms,\n+             std::vector<ObjectBuffer>* object_buffers);\n+\n+  Status Get(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n+             ObjectBuffer* object_buffers);\n+\n+  Status Release(const ObjectID& object_id);\n+\n+  Status Contains(const ObjectID& object_id, bool* has_object);\n+\n+  Status Abort(const ObjectID& object_id);\n+\n+  Status Seal(const ObjectID& object_id);\n+\n+  Status Delete(const ObjectID& object_id);\n+\n+  Status Evict(int64_t num_bytes, int64_t& num_bytes_evicted);\n+\n+  Status Hash(const ObjectID& object_id, uint8_t* digest);\n+\n+  Status Subscribe(int* fd);\n+\n+  Status GetNotification(int fd, ObjectID* object_id, int64_t* data_size,\n+                         int64_t* metadata_size);\n+\n+  Status Disconnect();\n+\n+  Status Fetch(int num_object_ids, const ObjectID* object_ids);\n+\n+  Status Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n+              int num_ready_objects, int64_t timeout_ms, int* num_objects_ready);\n+\n+  Status Transfer(const char* addr, int port, const ObjectID& object_id);\n+\n+  Status Info(const ObjectID& object_id, int* object_status);\n+\n+  int get_manager_fd() const;\n+\n+  Status FlushReleaseHistory();\n+\n+  bool IsInUse(const ObjectID& object_id);\n+\n+ private:\n+  /// This is a helper method for unmapping objects for which all references have\n+  /// gone out of scope, either by calling Release or Abort.\n+  ///\n+  /// @param object_id The object ID whose data we should unmap.\n+  Status UnmapObject(const ObjectID& object_id);\n+\n+  Status PerformRelease(const ObjectID& object_id);\n+\n+  /// Common helper for Get() variants\n+  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n+                    const std::function<std::shared_ptr<Buffer>(\n+                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n+                    ObjectBuffer* object_buffers);\n+\n+  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n+\n+  uint8_t* lookup_mmapped_file(int store_fd_val);\n+\n+  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n+                              bool is_sealed);\n+\n+  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n+                                    int64_t nbytes);\n+\n+  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n+\n+  /// File descriptor of the Unix domain socket that connects to the store.\n+  int store_conn_;\n+  /// File descriptor of the Unix domain socket that connects to the manager.\n+  int manager_conn_;\n+  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n+  /// is a hash table mapping a file descriptor to a struct containing the\n+  /// address of the corresponding memory-mapped file.\n+  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n+  /// A hash table of the object IDs that are currently being used by this\n+  /// client.\n+  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n+      objects_in_use_;\n+  /// Object IDs of the last few release calls. This is a deque and\n+  /// is used to delay releasing objects to see if they can be reused by\n+  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n+  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n+  /// cache.\n+  std::deque<ObjectID> release_history_;\n+  /// The number of bytes in the combined objects that are held in the release\n+  /// history doubly-linked list. If this is too large then the client starts\n+  /// releasing objects.\n+  int64_t in_use_object_bytes_;\n+  /// Configuration options for the plasma client.\n+  PlasmaClientConfig config_;\n+  /// The amount of memory available to the Plasma store. The client needs this\n+  /// information to make sure that it does not delay in releasing so much\n+  /// memory that the store is unable to evict enough objects to free up space.\n+  int64_t store_capacity_;\n+  /// Threadpool for parallel memcopy and hash computation.\n+  std::vector<std::thread> threadpool_;\n+\n+#ifdef PLASMA_GPU\n+  /// Cuda Device Manager.\n+  arrow::gpu::CudaDeviceManager* manager_;\n #endif\n+};\n+\n+PlasmaBuffer::~PlasmaBuffer() { ARROW_UNUSED(client_->Release(object_id_)); }\n \n-PlasmaClient::PlasmaClient() : threadpool_(kThreadPoolSize) {\n+PlasmaClient::Impl::Impl() : threadpool_(kThreadPoolSize) {\n #ifdef PLASMA_GPU\n   CudaDeviceManager::GetInstance(&manager_);\n #endif\n }\n \n-PlasmaClient::~PlasmaClient() {}\n+PlasmaClient::Impl::~Impl() {}\n \n // If the file descriptor fd has been mmapped in this client process before,\n // return the pointer that was returned by mmap, otherwise mmap it and store the\n // pointer in a hash table.\n-uint8_t* PlasmaClient::lookup_or_mmap(int fd, int store_fd_val, int64_t map_size) {\n+uint8_t* PlasmaClient::Impl::lookup_or_mmap(int fd, int store_fd_val, int64_t map_size) {\n   auto entry = mmap_table_.find(store_fd_val);\n   if (entry != mmap_table_.end()) {\n     close(fd);\n@@ -157,19 +314,19 @@ uint8_t* PlasmaClient::lookup_or_mmap(int fd, int store_fd_val, int64_t map_size\n \n // Get a pointer to a file that we know has been memory mapped in this client\n // process before.\n-uint8_t* PlasmaClient::lookup_mmapped_file(int store_fd_val) {\n+uint8_t* PlasmaClient::Impl::lookup_mmapped_file(int store_fd_val) {\n   auto entry = mmap_table_.find(store_fd_val);\n   ARROW_CHECK(entry != mmap_table_.end());\n   return entry->second.pointer;\n }\n \n-bool PlasmaClient::IsInUse(const ObjectID& object_id) {\n+bool PlasmaClient::Impl::IsInUse(const ObjectID& object_id) {\n   const auto elem = objects_in_use_.find(object_id);\n   return (elem != objects_in_use_.end());\n }\n \n-void PlasmaClient::increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                                          bool is_sealed) {\n+void PlasmaClient::Impl::increment_object_count(const ObjectID& object_id,\n+                                                PlasmaObject* object, bool is_sealed) {\n   // Increment the count of the object to track the fact that it is being used.\n   // The corresponding decrement should happen in PlasmaClient::Release.\n   auto elem = objects_in_use_.find(object_id);\n@@ -205,9 +362,9 @@ void PlasmaClient::increment_object_count(const ObjectID& object_id, PlasmaObjec\n   object_entry->count += 1;\n }\n \n-Status PlasmaClient::Create(const ObjectID& object_id, int64_t data_size,\n-                            const uint8_t* metadata, int64_t metadata_size,\n-                            std::shared_ptr<Buffer>* data, int device_num) {\n+Status PlasmaClient::Impl::Create(const ObjectID& object_id, int64_t data_size,\n+                                  const uint8_t* metadata, int64_t metadata_size,\n+                                  std::shared_ptr<Buffer>* data, int device_num) {\n   ARROW_LOG(DEBUG) << \"called plasma_create on conn \" << store_conn_ << \" with size \"\n                    << data_size << \" and metadata size \" << metadata_size;\n   RETURN_NOT_OK(\n@@ -271,7 +428,7 @@ Status PlasmaClient::Create(const ObjectID& object_id, int64_t data_size,\n   return Status::OK();\n }\n \n-Status PlasmaClient::GetBuffers(\n+Status PlasmaClient::Impl::GetBuffers(\n     const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n     const std::function<std::shared_ptr<Buffer>(\n         const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n@@ -397,8 +554,8 @@ Status PlasmaClient::GetBuffers(\n   return Status::OK();\n }\n \n-Status PlasmaClient::Get(const std::vector<ObjectID>& object_ids, int64_t timeout_ms,\n-                         std::vector<ObjectBuffer>* out) {\n+Status PlasmaClient::Impl::Get(const std::vector<ObjectID>& object_ids,\n+                               int64_t timeout_ms, std::vector<ObjectBuffer>* out) {\n   const auto wrap_buffer = [=](const ObjectID& object_id,\n                                const std::shared_ptr<Buffer>& buffer) {\n     return std::make_shared<PlasmaBuffer>(this, object_id, buffer);\n@@ -408,14 +565,14 @@ Status PlasmaClient::Get(const std::vector<ObjectID>& object_ids, int64_t timeou\n   return GetBuffers(&object_ids[0], num_objects, timeout_ms, wrap_buffer, &(*out)[0]);\n }\n \n-Status PlasmaClient::Get(const ObjectID* object_ids, int64_t num_objects,\n-                         int64_t timeout_ms, ObjectBuffer* out) {\n+Status PlasmaClient::Impl::Get(const ObjectID* object_ids, int64_t num_objects,\n+                               int64_t timeout_ms, ObjectBuffer* out) {\n   const auto wrap_buffer = [](const ObjectID& object_id,\n                               const std::shared_ptr<Buffer>& buffer) { return buffer; };\n   return GetBuffers(object_ids, num_objects, timeout_ms, wrap_buffer, out);\n }\n \n-Status PlasmaClient::UnmapObject(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::UnmapObject(const ObjectID& object_id) {\n   auto object_entry = objects_in_use_.find(object_id);\n   ARROW_CHECK(object_entry != objects_in_use_.end());\n   ARROW_CHECK(object_entry->second->count == 0);\n@@ -459,7 +616,7 @@ Status PlasmaClient::UnmapObject(const ObjectID& object_id) {\n /// releasing the object when the client is truly done with the object.\n ///\n /// @param object_id The object ID to attempt to release.\n-Status PlasmaClient::PerformRelease(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::PerformRelease(const ObjectID& object_id) {\n   // Decrement the count of the number of instances of this object that are\n   // being used by this client. The corresponding increment should have happened\n   // in PlasmaClient::Get.\n@@ -476,7 +633,7 @@ Status PlasmaClient::PerformRelease(const ObjectID& object_id) {\n   return Status::OK();\n }\n \n-Status PlasmaClient::Release(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::Release(const ObjectID& object_id) {\n   // If the client is already disconnected, ignore release requests.\n   if (store_conn_ < 0) {\n     return Status::OK();\n@@ -500,7 +657,7 @@ Status PlasmaClient::Release(const ObjectID& object_id) {\n   return Status::OK();\n }\n \n-Status PlasmaClient::FlushReleaseHistory() {\n+Status PlasmaClient::Impl::FlushReleaseHistory() {\n   // If the client is already disconnected, ignore the flush.\n   if (store_conn_ < 0) {\n     return Status::OK();\n@@ -515,7 +672,7 @@ Status PlasmaClient::FlushReleaseHistory() {\n }\n \n // This method is used to query whether the plasma store contains an object.\n-Status PlasmaClient::Contains(const ObjectID& object_id, bool* has_object) {\n+Status PlasmaClient::Impl::Contains(const ObjectID& object_id, bool* has_object) {\n   // Check if we already have a reference to the object.\n   if (objects_in_use_.count(object_id) > 0) {\n     *has_object = 1;\n@@ -540,9 +697,9 @@ static void ComputeBlockHash(const unsigned char* data, int64_t nbytes, uint64_t\n   *hash = XXH64_digest(&hash_state);\n }\n \n-bool PlasmaClient::compute_object_hash_parallel(XXH64_state_t* hash_state,\n-                                                const unsigned char* data,\n-                                                int64_t nbytes) {\n+bool PlasmaClient::Impl::compute_object_hash_parallel(XXH64_state_t* hash_state,\n+                                                      const unsigned char* data,\n+                                                      int64_t nbytes) {\n   // Note that this function will likely be faster if the address of data is\n   // aligned on a 64-byte boundary.\n   const int num_threads = kThreadPoolSize;\n@@ -576,7 +733,7 @@ bool PlasmaClient::compute_object_hash_parallel(XXH64_state_t* hash_state,\n   return true;\n }\n \n-uint64_t PlasmaClient::compute_object_hash(const ObjectBuffer& obj_buffer) {\n+uint64_t PlasmaClient::Impl::compute_object_hash(const ObjectBuffer& obj_buffer) {\n   DCHECK(obj_buffer.metadata);\n   DCHECK(obj_buffer.data);\n   XXH64_state_t hash_state;\n@@ -600,7 +757,7 @@ uint64_t PlasmaClient::compute_object_hash(const ObjectBuffer& obj_buffer) {\n   return XXH64_digest(&hash_state);\n }\n \n-Status PlasmaClient::Seal(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::Seal(const ObjectID& object_id) {\n   // Make sure this client has a reference to the object before sending the\n   // request to Plasma.\n   auto object_entry = objects_in_use_.find(object_id);\n@@ -626,7 +783,7 @@ Status PlasmaClient::Seal(const ObjectID& object_id) {\n   return Release(object_id);\n }\n \n-Status PlasmaClient::Abort(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::Abort(const ObjectID& object_id) {\n   auto object_entry = objects_in_use_.find(object_id);\n   ARROW_CHECK(object_entry != objects_in_use_.end())\n       << \"Plasma client called abort on an object without a reference to it\";\n@@ -655,7 +812,7 @@ Status PlasmaClient::Abort(const ObjectID& object_id) {\n   return ReadAbortReply(buffer.data(), buffer.size(), &id);\n }\n \n-Status PlasmaClient::Delete(const ObjectID& object_id) {\n+Status PlasmaClient::Impl::Delete(const ObjectID& object_id) {\n   RETURN_NOT_OK(FlushReleaseHistory());\n   // If the object is in used, client can't send the remove message.\n   if (objects_in_use_.count(object_id) > 0) {\n@@ -672,7 +829,7 @@ Status PlasmaClient::Delete(const ObjectID& object_id) {\n   }\n }\n \n-Status PlasmaClient::Evict(int64_t num_bytes, int64_t& num_bytes_evicted) {\n+Status PlasmaClient::Impl::Evict(int64_t num_bytes, int64_t& num_bytes_evicted) {\n   // Send a request to the store to evict objects.\n   RETURN_NOT_OK(SendEvictRequest(store_conn_, num_bytes));\n   // Wait for a response with the number of bytes actually evicted.\n@@ -682,7 +839,7 @@ Status PlasmaClient::Evict(int64_t num_bytes, int64_t& num_bytes_evicted) {\n   return ReadEvictReply(buffer.data(), buffer.size(), num_bytes_evicted);\n }\n \n-Status PlasmaClient::Hash(const ObjectID& object_id, uint8_t* digest) {\n+Status PlasmaClient::Impl::Hash(const ObjectID& object_id, uint8_t* digest) {\n   // Get the plasma object data. We pass in a timeout of 0 to indicate that\n   // the operation should timeout immediately.\n   std::vector<ObjectBuffer> object_buffers;\n@@ -697,7 +854,7 @@ Status PlasmaClient::Hash(const ObjectID& object_id, uint8_t* digest) {\n   return Status::OK();\n }\n \n-Status PlasmaClient::Subscribe(int* fd) {\n+Status PlasmaClient::Impl::Subscribe(int* fd) {\n   int sock[2];\n   // Create a non-blocking socket pair. This will only be used to send\n   // notifications from the Plasma store to the client.\n@@ -717,8 +874,8 @@ Status PlasmaClient::Subscribe(int* fd) {\n   return Status::OK();\n }\n \n-Status PlasmaClient::GetNotification(int fd, ObjectID* object_id, int64_t* data_size,\n-                                     int64_t* metadata_size) {\n+Status PlasmaClient::Impl::GetNotification(int fd, ObjectID* object_id,\n+                                           int64_t* data_size, int64_t* metadata_size) {\n   uint8_t* notification = read_message_async(fd);\n   if (notification == NULL) {\n     return Status::IOError(\"Failed to read object notification from Plasma socket\");\n@@ -737,9 +894,9 @@ Status PlasmaClient::GetNotification(int fd, ObjectID* object_id, int64_t* data_\n   return Status::OK();\n }\n \n-Status PlasmaClient::Connect(const std::string& store_socket_name,\n-                             const std::string& manager_socket_name, int release_delay,\n-                             int num_retries) {\n+Status PlasmaClient::Impl::Connect(const std::string& store_socket_name,\n+                                   const std::string& manager_socket_name,\n+                                   int release_delay, int num_retries) {\n   RETURN_NOT_OK(ConnectIpcSocketRetry(store_socket_name, num_retries, -1, &store_conn_));\n   if (manager_socket_name != \"\") {\n     RETURN_NOT_OK(\n@@ -757,7 +914,7 @@ Status PlasmaClient::Connect(const std::string& store_socket_name,\n   return Status::OK();\n }\n \n-Status PlasmaClient::Disconnect() {\n+Status PlasmaClient::Impl::Disconnect() {\n   // NOTE: We purposefully do not finish sending release calls for objects in\n   // use, so that we don't duplicate PlasmaClient::Release calls (when handling\n   // a SIGTERM, for example).\n@@ -773,18 +930,19 @@ Status PlasmaClient::Disconnect() {\n   return Status::OK();\n }\n \n-Status PlasmaClient::Transfer(const char* address, int port, const ObjectID& object_id) {\n+Status PlasmaClient::Impl::Transfer(const char* address, int port,\n+                                    const ObjectID& object_id) {\n   return SendDataRequest(manager_conn_, object_id, address, port);\n }\n \n-Status PlasmaClient::Fetch(int num_object_ids, const ObjectID* object_ids) {\n+Status PlasmaClient::Impl::Fetch(int num_object_ids, const ObjectID* object_ids) {\n   ARROW_CHECK(manager_conn_ >= 0);\n   return SendFetchRequest(manager_conn_, object_ids, num_object_ids);\n }\n \n-int PlasmaClient::get_manager_fd() const { return manager_conn_; }\n+int PlasmaClient::Impl::get_manager_fd() const { return manager_conn_; }\n \n-Status PlasmaClient::Info(const ObjectID& object_id, int* object_status) {\n+Status PlasmaClient::Impl::Info(const ObjectID& object_id, int* object_status) {\n   ARROW_CHECK(manager_conn_ >= 0);\n \n   RETURN_NOT_OK(SendStatusRequest(manager_conn_, &object_id, 1));\n@@ -796,9 +954,9 @@ Status PlasmaClient::Info(const ObjectID& object_id, int* object_status) {\n   return Status::OK();\n }\n \n-Status PlasmaClient::Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n-                          int num_ready_objects, int64_t timeout_ms,\n-                          int* num_objects_ready) {\n+Status PlasmaClient::Impl::Wait(int64_t num_object_requests,\n+                                ObjectRequest* object_requests, int num_ready_objects,\n+                                int64_t timeout_ms, int* num_objects_ready) {\n   ARROW_CHECK(manager_conn_ >= 0);\n   ARROW_CHECK(num_object_requests > 0);\n   ARROW_CHECK(num_ready_objects > 0);\n@@ -840,4 +998,94 @@ Status PlasmaClient::Wait(int64_t num_object_requests, ObjectRequest* object_req\n   return Status::OK();\n }\n \n+// ----------------------------------------------------------------------\n+// PlasmaClient\n+\n+PlasmaClient::PlasmaClient() : impl_(std::make_shared<PlasmaClient::Impl>()) {}\n+\n+PlasmaClient::~PlasmaClient() {}\n+\n+Status PlasmaClient::Connect(const std::string& store_socket_name,\n+                             const std::string& manager_socket_name, int release_delay,\n+                             int num_retries) {\n+  return impl_->Connect(store_socket_name, manager_socket_name, release_delay,\n+                        num_retries);\n+}\n+\n+Status PlasmaClient::Create(const ObjectID& object_id, int64_t data_size,\n+                            const uint8_t* metadata, int64_t metadata_size,\n+                            std::shared_ptr<Buffer>* data, int device_num) {\n+  return impl_->Create(object_id, data_size, metadata, metadata_size, data, device_num);\n+}\n+\n+Status PlasmaClient::Get(const std::vector<ObjectID>& object_ids, int64_t timeout_ms,\n+                         std::vector<ObjectBuffer>* object_buffers) {\n+  return impl_->Get(object_ids, timeout_ms, object_buffers);\n+}\n+\n+Status PlasmaClient::Get(const ObjectID* object_ids, int64_t num_objects,\n+                         int64_t timeout_ms, ObjectBuffer* object_buffers) {\n+  return impl_->Get(object_ids, num_objects, timeout_ms, object_buffers);\n+}\n+\n+Status PlasmaClient::Release(const ObjectID& object_id) {\n+  return impl_->Release(object_id);\n+}\n+\n+Status PlasmaClient::Contains(const ObjectID& object_id, bool* has_object) {\n+  return impl_->Contains(object_id, has_object);\n+}\n+\n+Status PlasmaClient::Abort(const ObjectID& object_id) { return impl_->Abort(object_id); }\n+\n+Status PlasmaClient::Seal(const ObjectID& object_id) { return impl_->Seal(object_id); }\n+\n+Status PlasmaClient::Delete(const ObjectID& object_id) {\n+  return impl_->Delete(object_id);\n+}\n+\n+Status PlasmaClient::Evict(int64_t num_bytes, int64_t& num_bytes_evicted) {\n+  return impl_->Evict(num_bytes, num_bytes_evicted);\n+}\n+\n+Status PlasmaClient::Hash(const ObjectID& object_id, uint8_t* digest) {\n+  return impl_->Hash(object_id, digest);\n+}\n+\n+Status PlasmaClient::Subscribe(int* fd) { return impl_->Subscribe(fd); }\n+\n+Status PlasmaClient::GetNotification(int fd, ObjectID* object_id, int64_t* data_size,\n+                                     int64_t* metadata_size) {\n+  return impl_->GetNotification(fd, object_id, data_size, metadata_size);\n+}\n+\n+Status PlasmaClient::Disconnect() { return impl_->Disconnect(); }\n+\n+Status PlasmaClient::Fetch(int num_object_ids, const ObjectID* object_ids) {\n+  return impl_->Fetch(num_object_ids, object_ids);\n+}\n+\n+Status PlasmaClient::Wait(int64_t num_object_requests, ObjectRequest* object_requests,\n+                          int num_ready_objects, int64_t timeout_ms,\n+                          int* num_objects_ready) {\n+  return impl_->Wait(num_object_requests, object_requests, num_ready_objects, timeout_ms,\n+                     num_objects_ready);\n+}\n+\n+Status PlasmaClient::Transfer(const char* addr, int port, const ObjectID& object_id) {\n+  return impl_->Transfer(addr, port, object_id);\n+}\n+\n+Status PlasmaClient::Info(const ObjectID& object_id, int* object_status) {\n+  return impl_->Info(object_id, object_status);\n+}\n+\n+int PlasmaClient::get_manager_fd() const { return impl_->get_manager_fd(); }\n+\n+Status PlasmaClient::FlushReleaseHistory() { return impl_->FlushReleaseHistory(); }\n+\n+bool PlasmaClient::IsInUse(const ObjectID& object_id) {\n+  return impl_->IsInUse(object_id);\n+}\n+\n }  // namespace plasma\ndiff --git a/cpp/src/plasma/client.h b/cpp/src/plasma/client.h\nindex 7e353b27c..422199740 100644\n--- a/cpp/src/plasma/client.h\n+++ b/cpp/src/plasma/client.h\n@@ -18,15 +18,9 @@\n #ifndef PLASMA_CLIENT_H\n #define PLASMA_CLIENT_H\n \n-#include <stdbool.h>\n-#include <time.h>\n-\n-#include <deque>\n #include <functional>\n #include <memory>\n #include <string>\n-#include <thread>\n-#include <unordered_map>\n #include <vector>\n \n #include \"arrow/buffer.h\"\n@@ -34,22 +28,14 @@\n #include \"arrow/util/macros.h\"\n #include \"arrow/util/visibility.h\"\n #include \"plasma/common.h\"\n-#ifdef PLASMA_GPU\n-#include \"arrow/gpu/cuda_api.h\"\n-#endif\n \n using arrow::Buffer;\n using arrow::Status;\n \n-typedef struct XXH64_state_s XXH64_state_t;\n-\n namespace plasma {\n \n #define PLASMA_DEFAULT_RELEASE_DELAY 64\n \n-// Use 100MB as an overestimate of the L3 cache size.\n-constexpr int64_t kL3CacheSizeBytes = 100000000;\n-\n /// Object buffer data structure.\n struct ObjectBuffer {\n   /// The data buffer.\n@@ -60,32 +46,9 @@ struct ObjectBuffer {\n   int device_num;\n };\n \n-/// Configuration options for the plasma client.\n-struct PlasmaClientConfig {\n-  /// Number of release calls we wait until the object is actually released.\n-  /// This allows us to avoid invalidating the cpu cache on workers if objects\n-  /// are reused accross tasks.\n-  size_t release_delay;\n-};\n-\n-struct ClientMmapTableEntry {\n-  /// The result of mmap for this file descriptor.\n-  uint8_t* pointer;\n-  /// The length of the memory-mapped file.\n-  size_t length;\n-  /// The number of objects in this memory-mapped file that are currently being\n-  /// used by the client. When this count reaches zeros, we unmap the file.\n-  int count;\n-};\n-\n-struct ObjectInUseEntry;\n-struct ObjectRequest;\n-struct PlasmaObject;\n-\n class ARROW_EXPORT PlasmaClient {\n  public:\n   PlasmaClient();\n-\n   ~PlasmaClient();\n \n   /// Connect to the local plasma store and plasma manager. Return\n@@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n };\n \n }  // namespace plasma\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T06:55:02.977+0000",
                    "updated": "2018-04-24T06:55:02.977+0000",
                    "started": "2018-04-24T06:55:02.977+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94485",
                    "issueId": "13154241"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/worklog/94516",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on a change in pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#discussion_r183641328\n \n \n\n ##########\n File path: cpp/src/plasma/client.h\n ##########\n @@ -346,76 +309,19 @@ class ARROW_EXPORT PlasmaClient {\n   int get_manager_fd() const;\n \n  private:\n+  friend class PlasmaBuffer;\n   FRIEND_TEST(TestPlasmaStore, GetTest);\n   FRIEND_TEST(TestPlasmaStore, LegacyGetTest);\n   FRIEND_TEST(TestPlasmaStore, AbortTest);\n \n-  /// This is a helper method for unmapping objects for which all references have\n-  /// gone out of scope, either by calling Release or Abort.\n-  ///\n-  /// @param object_id The object ID whose data we should unmap.\n-  Status UnmapObject(const ObjectID& object_id);\n-\n   /// This is a helper method that flushes all pending release calls to the\n   /// store.\n   Status FlushReleaseHistory();\n \n-  Status PerformRelease(const ObjectID& object_id);\n-\n-  /// Common helper for Get() variants\n-  Status GetBuffers(const ObjectID* object_ids, int64_t num_objects, int64_t timeout_ms,\n-                    const std::function<std::shared_ptr<Buffer>(\n-                        const ObjectID&, const std::shared_ptr<Buffer>&)>& wrap_buffer,\n-                    ObjectBuffer* object_buffers);\n-\n   bool IsInUse(const ObjectID& object_id);\n \n-  uint8_t* lookup_or_mmap(int fd, int store_fd_val, int64_t map_size);\n-\n-  uint8_t* lookup_mmapped_file(int store_fd_val);\n-\n-  void increment_object_count(const ObjectID& object_id, PlasmaObject* object,\n-                              bool is_sealed);\n-\n-  bool compute_object_hash_parallel(XXH64_state_t* hash_state, const unsigned char* data,\n-                                    int64_t nbytes);\n-\n-  uint64_t compute_object_hash(const ObjectBuffer& obj_buffer);\n-\n-  /// File descriptor of the Unix domain socket that connects to the store.\n-  int store_conn_;\n-  /// File descriptor of the Unix domain socket that connects to the manager.\n-  int manager_conn_;\n-  /// Table of dlmalloc buffer files that have been memory mapped so far. This\n-  /// is a hash table mapping a file descriptor to a struct containing the\n-  /// address of the corresponding memory-mapped file.\n-  std::unordered_map<int, ClientMmapTableEntry> mmap_table_;\n-  /// A hash table of the object IDs that are currently being used by this\n-  /// client.\n-  std::unordered_map<ObjectID, std::unique_ptr<ObjectInUseEntry>, UniqueIDHasher>\n-      objects_in_use_;\n-  /// Object IDs of the last few release calls. This is a deque and\n-  /// is used to delay releasing objects to see if they can be reused by\n-  /// subsequent tasks so we do not unneccessarily invalidate cpu caches.\n-  /// TODO(pcm): replace this with a proper lru cache using the size of the L3\n-  /// cache.\n-  std::deque<ObjectID> release_history_;\n-  /// The number of bytes in the combined objects that are held in the release\n-  /// history doubly-linked list. If this is too large then the client starts\n-  /// releasing objects.\n-  int64_t in_use_object_bytes_;\n-  /// Configuration options for the plasma client.\n-  PlasmaClientConfig config_;\n-  /// The amount of memory available to the Plasma store. The client needs this\n-  /// information to make sure that it does not delay in releasing so much\n-  /// memory that the store is unable to evict enough objects to free up space.\n-  int64_t store_capacity_;\n-  /// Threadpool for parallel memcopy and hash computation.\n-  std::vector<std::thread> threadpool_;\n-#ifdef PLASMA_GPU\n-  /// Cuda Device Manager.\n-  arrow::gpu::CudaDeviceManager* manager_;\n-#endif\n+  class ARROW_NO_EXPORT Impl;\n+  std::shared_ptr<Impl> impl_;\n \n Review comment:\n   Yes, this was a more general piece of information. The const correctness is rather something that we would need with the core Arrow structures such as Array or Buffer.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-04-24T08:15:52.165+0000",
                    "updated": "2018-04-24T08:15:52.165+0000",
                    "started": "2018-04-24T08:15:52.164+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "94516",
                    "issueId": "13154241"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": 6000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@6a5d9993[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@464ba93a[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a2b635b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@61b2175d[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@c23608[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@1b077442[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3a17fdc2[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@4b6e0d22[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5a8d0031[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7a08da46[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7f74d128[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4448c4f9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 6000,
        "customfield_12312520": null,
        "customfield_12312521": "Tue Apr 24 06:56:06 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-04-24T06:56:06.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2489/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2018-04-21T17:11:52.000+0000",
        "updated": "2018-04-24T08:15:52.000+0000",
        "timeoriginalestimate": null,
        "description": "This is new here:\r\n\r\n{code}$ py.test   --tb=native pyarrow/tests/test_plasma.py \r\n===================================================================== test session starts ======================================================================\r\nplatform linux -- Python 3.6.5, pytest-3.3.2, py-1.5.2, pluggy-0.6.0\r\nrootdir: /home/antoine/arrow/python, inifile: setup.cfg\r\nplugins: xdist-1.22.0, timeout-1.2.1, repeat-0.4.1, forked-0.2, faulthandler-1.3.1\r\ncollected 23 items                                                                                                                                             \r\n\r\npyarrow/tests/test_plasma.py *** Error in `/home/antoine/miniconda3/envs/pyarrow/bin/python': double free or corruption (!prev): 0x0000000001699520 ***\r\n[...]\r\n\r\nCurrent thread 0x00007fe7e8570700 (most recent call first):\r\n  File \"/home/antoine/arrow/python/pyarrow/tests/test_plasma.py\", line 211 in test_connection_failure_raises_exception\r\n[...]\r\n{code}\r\n\r\nHere is the C backtrace under gdb:\r\n\r\n{code}\r\n#0  0x00007ffff69d0428 in __GI_raise (sig=sig@entry=6) at ../sysdeps/unix/sysv/linux/raise.c:54\r\n#1  0x00007ffff69d202a in __GI_abort () at abort.c:89\r\n#2  0x00007ffff6a127ea in __libc_message (do_abort=do_abort@entry=2, fmt=fmt@entry=0x7ffff6b2bed8 \"*** Error in `%s': %s: 0x%s ***\\n\")\r\n    at ../sysdeps/posix/libc_fatal.c:175\r\n#3  0x00007ffff6a1b37a in malloc_printerr (ar_ptr=<optimized out>, ptr=<optimized out>, str=0x7ffff6b2c008 \"double free or corruption (!prev)\", action=3)\r\n    at malloc.c:5006\r\n#4  _int_free (av=<optimized out>, p=<optimized out>, have_lock=0) at malloc.c:3867\r\n#5  0x00007ffff6a1f53c in __GI___libc_free (mem=<optimized out>) at malloc.c:2968\r\n#6  0x00007fffbdfcc504 in std::_Sp_counted_ptr<plasma::PlasmaClient*, (__gnu_cxx::_Lock_policy)2>::_M_dispose (this=0x9defb0)\r\n    at /usr/include/c++/4.9/bits/shared_ptr_base.h:373\r\n#7  0x00007fffbdfc903c in std::_Sp_counted_base<(__gnu_cxx::_Lock_policy)2>::_M_release (this=0x9defb0) at /usr/include/c++/4.9/bits/shared_ptr_base.h:149\r\n#8  0x00007fffbdfc82b9 in std::__shared_count<(__gnu_cxx::_Lock_policy)2>::~__shared_count (this=0x7fffc1214510, __in_chrg=<optimized out>)\r\n    at /usr/include/c++/4.9/bits/shared_ptr_base.h:666\r\n#9  0x00007fffbdfc8276 in std::__shared_ptr<plasma::PlasmaClient, (__gnu_cxx::_Lock_policy)2>::~__shared_ptr (this=0x7fffc1214508, __in_chrg=<optimized out>)\r\n    at /usr/include/c++/4.9/bits/shared_ptr_base.h:914\r\n#10 0x00007fffbdfc8fc4 in std::shared_ptr<plasma::PlasmaClient>::~shared_ptr (this=0x7fffc1214508, __in_chrg=<optimized out>)\r\n    at /usr/include/c++/4.9/bits/shared_ptr.h:93\r\n#11 0x00007fffbdfc8fde in __Pyx_call_destructor<std::shared_ptr<plasma::PlasmaClient> > (x=...)\r\n    at /home/antoine/arrow/python/build/temp.linux-x86_64-3.6/plasma.cxx:281\r\n#12 0x00007fffbdfbc317 in __pyx_tp_dealloc_7pyarrow_6plasma_PlasmaClient (o=0x7fffc12144f0)\r\n    at /home/antoine/arrow/python/build/temp.linux-x86_64-3.6/plasma.cxx:10383\r\n#13 0x00007fffbdfb8986 in __pyx_pf_7pyarrow_6plasma_2connect (__pyx_self=0x0, __pyx_v_store_socket_name=0x7fffbc922c48, \r\n    __pyx_v_manager_socket_name=0x7ffff7fa0ab0, __pyx_v_release_delay=0, __pyx_v_num_retries=1)\r\n    at /home/antoine/arrow/python/build/temp.linux-x86_64-3.6/plasma.cxx:9147\r\n#14 0x00007fffbdfb7dec in __pyx_pw_7pyarrow_6plasma_3connect (__pyx_self=0x0, __pyx_args=0x7fffbc4d9688, __pyx_kwds=0x0)\r\n    at /home/antoine/arrow/python/build/temp.linux-x86_64-3.6/plasma.cxx:8978\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 6000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Plasma] test_plasma.py crashes",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446902",
                    "id": "16446902",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Bisecting tells me the following commit introduced the issue:\r\n\r\n{code}\r\ncommit 7eeca3ac823d5dda05f018661b453354cb782406\r\nAuthor: Philipp Moritz <pcmoritz@gmail.com>\r\nDate:   Thu Apr 19 12:25:27 2018 -0700\r\n\r\n    ARROW-2458: [Plasma] Use one thread pool per PlasmaClient\r\n    \r\n    This removes the global `thread pool_` variable from the PlasmaClient.\r\n    \r\n    cc @robertnishihara @pitrou\r\n    \r\n    Author: Philipp Moritz <pcmoritz@gmail.com>\r\n    \r\n    Closes #1893 from pcmoritz/fix-plasma-client and squashes the following commits:\r\n    \r\n    742b542 <Philipp Moritz> fix linting\r\n    b1130bd <Philipp Moritz> remove global variable from PlasmaClient\r\n{code}\r\n\r\n[~pcmoritz]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-04-21T17:31:09.073+0000",
                    "updated": "2018-04-21T17:31:09.073+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446916",
                    "id": "16446916",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "This seems somehow related to GPU support. If I disable the following line in the plasma client constructor:\r\n{code:cpp}\r\nCudaDeviceManager::GetInstance(&manager_);\r\n{code}\r\nthen the crash goes away.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-04-21T17:58:10.698+0000",
                    "updated": "2018-04-21T17:58:10.698+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446943",
                    "id": "16446943",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Ok, it's an ABI issue.\r\n\r\nWhen you compile Plasma with GPU support enabled, there's an additional pointer field at the end of {{PlasmaClient}}. However, pyarrow's {{setup.py}} doesn't enable {{PLASMA_GPU}} (AFAICT, it has no easy way of deciding whether to enable it). So the Cython extension allocates a {{PlasmaClient}} with 8 missing bytes at the end, and calls the {{PlasmaClient}} constructor which writes past the allocated memory. Depending on the exact structure size, this may garble some safety tags used by the libc's allocator, hence the error and the crash.\r\n\r\nOne solution is to migrate {{PlasmaClient}} to use a pimpl, which could also help fixing ARROW-2448.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-04-21T19:12:49.701+0000",
                    "updated": "2018-04-21T19:15:32.929+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446980",
                    "id": "16446980",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=robertnishihara",
                        "name": "robertnishihara",
                        "key": "robertnishihara",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Robert Nishihara",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Oh wow, nice job tracking that down. I'm all for the PIMPL solution to Arrow-2448, but why would PIMPL solve this issue?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=robertnishihara",
                        "name": "robertnishihara",
                        "key": "robertnishihara",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Robert Nishihara",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-21T20:39:09.121+0000",
                    "updated": "2018-04-21T20:39:09.121+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446982",
                    "id": "16446982",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "The size of the exposed class would always be fixed, only the class that contains the actual implementation would have a differing size. As this _internal_ class would only be used and visible inside of {{libplasma}}, all users of it would use the correct size.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-04-21T20:44:12.086+0000",
                    "updated": "2018-04-21T20:44:12.086+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16446988",
                    "id": "16446988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=robertnishihara",
                        "name": "robertnishihara",
                        "key": "robertnishihara",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Robert Nishihara",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Ok, that makes sense.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=robertnishihara",
                        "name": "robertnishihara",
                        "key": "robertnishihara",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Robert Nishihara",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-21T20:58:30.448+0000",
                    "updated": "2018-04-21T20:58:30.448+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16447821",
                    "id": "16447821",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou opened a new pull request #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933\n \n \n   When compiled with GPU support, the PlasmaClient ABI would differ, leading to a crash in the Python bindings to Plasma.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T09:20:40.377+0000",
                    "updated": "2018-04-23T09:20:40.377+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16448061",
                    "id": "16448061",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1933: ARROW-2489: [Plasma] Fix PlasmaClient ABI variation\nURL: https://github.com/apache/arrow/pull/1933#issuecomment-383559208\n \n \n   I think the AppVeyor failure is unrelated. It also succeeded on my AppVeyor account: https://ci.appveyor.com/project/pitrou/arrow/build/1.0.331\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-23T12:34:43.649+0000",
                    "updated": "2018-04-23T12:34:43.649+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13154241/comment/16449405",
                    "id": "16449405",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Issue resolved by pull request 1933\n[https://github.com/apache/arrow/pull/1933]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pcmoritz",
                        "name": "pcmoritz",
                        "key": "pcmoritz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Philipp Moritz",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-24T06:56:06.098+0000",
                    "updated": "2018-04-24T06:56:06.098+0000"
                }
            ],
            "maxResults": 9,
            "total": 9,
            "startAt": 0
        },
        "customfield_12311820": "0|i3suvr:",
        "customfield_12314139": null
    }
}