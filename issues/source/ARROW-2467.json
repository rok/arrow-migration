{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13153017",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017",
    "key": "ARROW-2467",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12344925",
                "id": "12344925",
                "description": "",
                "name": "0.14.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-07-04"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333773",
                "id": "12333773",
                "name": "Rust"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=andygrove",
            "name": "andygrove",
            "key": "andygrove",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=andygrove&avatarId=28239",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=andygrove&avatarId=28239",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=andygrove&avatarId=28239",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=andygrove&avatarId=28239"
            },
            "displayName": "Andy Grove",
            "active": true,
            "timeZone": "America/Denver"
        },
        "aggregateprogress": {
            "progress": 18000,
            "total": 18000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18000,
            "total": 18000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2467/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 31,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167189",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove opened a new pull request #2985: ARROW-2467: [Rust] Add generated flatbuffer source code\nURL: https://github.com/apache/arrow/pull/2985\n \n \n   Adding generated flatbuffers code for Schema, File, Message, and TensorIt would be nice to generate on the fly as part of the build process but this doesn't seem feasible today because:\r\n   \r\n   - We would have to download and compile Flatbuffers first\r\n   - The Rust implementation of Flatbuffers has a couple minor issues that required manually fixing the generated code\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-17T16:38:20.114+0000",
                    "updated": "2018-11-17T16:38:20.114+0000",
                    "started": "2018-11-17T16:38:20.113+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167189",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove closed pull request #2985: ARROW-2467: [Rust] Add generated flatbuffer source code\nURL: https://github.com/apache/arrow/pull/2985\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/rust/Cargo.toml b/rust/Cargo.toml\nindex c74e7a99c1..a4ef5856c3 100644\n--- a/rust/Cargo.toml\n+++ b/rust/Cargo.toml\n@@ -35,6 +35,7 @@ path = \"src/lib.rs\"\n \n [dependencies]\n bytes = \"0.4\"\n+flatbuffers = \"0.5.0\"\n libc = \"0.2\"\n serde_json = \"1.0.13\"\n rand = \"0.5\"\ndiff --git a/rust/src/format/README.md b/rust/src/format/README.md\nnew file mode 100644\nindex 0000000000..4161d44b52\n--- /dev/null\n+++ b/rust/src/format/README.md\n@@ -0,0 +1,14 @@\n+# Generating Arrow Flatbuffers code in Rust\n+\n+I compiled flatbuffers locally from commit 21591916afea4f50bb448fd071c3fccbc1d8034f and ran these commands to generate the source files:\n+\n+```bash\n+flatc --rust ../format/File.fbs\n+flatc --rust ../format/Schema.fbs\n+flatc --rust ../format/Message.fbs\n+flatc --rust ../format/Tensor.fbs\n+```\n+\n+There seems to be a bug in the current Flatbuffers code in the Rust implementation, so I had to manually search and replace to change `type__type` to `type_type`.\n+\n+I also removed the generated namespace `org::apache::arrow::format` and had to manually add imports at the top of each file.\n\\ No newline at end of file\ndiff --git a/rust/src/format/file.rs b/rust/src/format/file.rs\nnew file mode 100644\nindex 0000000000..1fb6f07a83\n--- /dev/null\n+++ b/rust/src/format/file.rs\n@@ -0,0 +1,221 @@\n+// automatically generated by the FlatBuffers compiler, do not modify\n+\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use std::mem;\n+use std::cmp::Ordering;\n+extern crate flatbuffers;\n+use self::flatbuffers::EndianScalar;\n+use ::format::schema::*;\n+\n+// struct Block, aligned to 8\n+#[repr(C, align(8))]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct Block {\n+  offset_: i64,\n+  metaDataLength_: i32,\n+  padding0__: u32,\n+  bodyLength_: i64,\n+} // pub struct Block\n+impl flatbuffers::SafeSliceAccess for Block {}\n+impl<'a> flatbuffers::Follow<'a> for Block {\n+  type Inner = &'a Block;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    <&'a Block>::follow(buf, loc)\n+  }\n+}\n+impl<'a> flatbuffers::Follow<'a> for &'a Block {\n+  type Inner = &'a Block;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::follow_cast_ref::<Block>(buf, loc)\n+  }\n+}\n+impl<'b> flatbuffers::Push for Block {\n+    type Output = Block;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(self as *const Block as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+impl<'b> flatbuffers::Push for &'b Block {\n+    type Output = Block;\n+\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(*self as *const Block as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+\n+\n+impl Block {\n+  pub fn new<'a>(_offset: i64, _metaDataLength: i32, _bodyLength: i64) -> Self {\n+    Block {\n+      offset_: _offset.to_little_endian(),\n+      metaDataLength_: _metaDataLength.to_little_endian(),\n+      bodyLength_: _bodyLength.to_little_endian(),\n+\n+      padding0__: 0,\n+    }\n+  }\n+  /// Index to the start of the RecordBlock (note this is past the Message header)\n+  pub fn offset<'a>(&'a self) -> i64 {\n+    self.offset_.from_little_endian()\n+  }\n+  /// Length of the metadata\n+  pub fn metaDataLength<'a>(&'a self) -> i32 {\n+    self.metaDataLength_.from_little_endian()\n+  }\n+  /// Length of the data (this is aligned so there can be a gap between this and\n+  /// the metatdata).\n+  pub fn bodyLength<'a>(&'a self) -> i64 {\n+    self.bodyLength_.from_little_endian()\n+  }\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// Arrow File metadata\n+///\n+pub enum FooterOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Footer<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Footer<'a> {\n+    type Inner = Footer<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Footer<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Footer {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args FooterArgs<'args>) -> flatbuffers::WIPOffset<Footer<'bldr>> {\n+      let mut builder = FooterBuilder::new(_fbb);\n+      if let Some(x) = args.recordBatches { builder.add_recordBatches(x); }\n+      if let Some(x) = args.dictionaries { builder.add_dictionaries(x); }\n+      if let Some(x) = args.schema { builder.add_schema(x); }\n+      builder.add_version(args.version);\n+      builder.finish()\n+    }\n+\n+    pub const VT_VERSION: flatbuffers::VOffsetT = 4;\n+    pub const VT_SCHEMA: flatbuffers::VOffsetT = 6;\n+    pub const VT_DICTIONARIES: flatbuffers::VOffsetT = 8;\n+    pub const VT_RECORDBATCHES: flatbuffers::VOffsetT = 10;\n+\n+  #[inline]\n+  pub fn version(&self) -> MetadataVersion {\n+    self._tab.get::<MetadataVersion>(Footer::VT_VERSION, Some(MetadataVersion::V1)).unwrap()\n+  }\n+  #[inline]\n+  pub fn schema(&self) -> Option<Schema<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<Schema<'a>>>(Footer::VT_SCHEMA, None)\n+  }\n+  #[inline]\n+  pub fn dictionaries(&self) -> Option<&'a [Block]> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Block>>>(Footer::VT_DICTIONARIES, None).map(|v| v.safe_slice() )\n+  }\n+  #[inline]\n+  pub fn recordBatches(&self) -> Option<&'a [Block]> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Block>>>(Footer::VT_RECORDBATCHES, None).map(|v| v.safe_slice() )\n+  }\n+}\n+\n+pub struct FooterArgs<'a> {\n+    pub version: MetadataVersion,\n+    pub schema: Option<flatbuffers::WIPOffset<Schema<'a >>>,\n+    pub dictionaries: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Block>>>,\n+    pub recordBatches: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Block>>>,\n+}\n+impl<'a> Default for FooterArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        FooterArgs {\n+            version: MetadataVersion::V1,\n+            schema: None,\n+            dictionaries: None,\n+            recordBatches: None,\n+        }\n+    }\n+}\n+pub struct FooterBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> FooterBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_version(&mut self, version: MetadataVersion) {\n+    self.fbb_.push_slot::<MetadataVersion>(Footer::VT_VERSION, version, MetadataVersion::V1);\n+  }\n+  #[inline]\n+  pub fn add_schema(&mut self, schema: flatbuffers::WIPOffset<Schema<'b >>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Schema>>(Footer::VT_SCHEMA, schema);\n+  }\n+  #[inline]\n+  pub fn add_dictionaries(&mut self, dictionaries: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Block>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Footer::VT_DICTIONARIES, dictionaries);\n+  }\n+  #[inline]\n+  pub fn add_recordBatches(&mut self, recordBatches: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Block>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Footer::VT_RECORDBATCHES, recordBatches);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FooterBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    FooterBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Footer<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+#[inline]\n+pub fn get_root_as_footer<'a>(buf: &'a [u8]) -> Footer<'a> {\n+  flatbuffers::get_root::<Footer<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn get_size_prefixed_root_as_footer<'a>(buf: &'a [u8]) -> Footer<'a> {\n+  flatbuffers::get_size_prefixed_root::<Footer<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn finish_footer_buffer<'a, 'b>(\n+    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+    root: flatbuffers::WIPOffset<Footer<'a>>) {\n+  fbb.finish(root, None);\n+}\n+\n+#[inline]\n+pub fn finish_size_prefixed_footer_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Footer<'a>>) {\n+  fbb.finish_size_prefixed(root, None);\n+}\n+\n+\ndiff --git a/rust/src/format/message.rs b/rust/src/format/message.rs\nnew file mode 100644\nindex 0000000000..284d0e1953\n--- /dev/null\n+++ b/rust/src/format/message.rs\n@@ -0,0 +1,558 @@\n+// automatically generated by the FlatBuffers compiler, do not modify\n+\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use std::mem;\n+use std::cmp::Ordering;\n+extern crate flatbuffers;\n+use self::flatbuffers::EndianScalar;\n+use ::format::schema::*;\n+use ::format::tensor::*;\n+\n+/// ----------------------------------------------------------------------\n+/// The root Message type\n+/// This union enables us to easily send different message types without\n+/// redundant storage, and in the future we can easily add new message types.\n+///\n+/// Arrow implementations do not need to implement all of the message types,\n+/// which may include experimental metadata types. For maximum compatibility,\n+/// it is best to send data using RecordBatch\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum MessageHeader {\n+  NONE = 0,\n+  Schema = 1,\n+  DictionaryBatch = 2,\n+  RecordBatch = 3,\n+  Tensor = 4,\n+\n+}\n+\n+const ENUM_MIN_MESSAGE_HEADER: u8 = 0;\n+const ENUM_MAX_MESSAGE_HEADER: u8 = 4;\n+\n+impl<'a> flatbuffers::Follow<'a> for MessageHeader {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for MessageHeader {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = u8::to_le(self as u8);\n+    let p = &n as *const u8 as *const MessageHeader;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = u8::from_le(self as u8);\n+    let p = &n as *const u8 as *const MessageHeader;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for MessageHeader {\n+    type Output = MessageHeader;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<MessageHeader>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_MESSAGE_HEADER:[MessageHeader; 5] = [\n+  MessageHeader::NONE,\n+  MessageHeader::Schema,\n+  MessageHeader::DictionaryBatch,\n+  MessageHeader::RecordBatch,\n+  MessageHeader::Tensor\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_MESSAGE_HEADER:[&'static str; 5] = [\n+    \"NONE\",\n+    \"Schema\",\n+    \"DictionaryBatch\",\n+    \"RecordBatch\",\n+    \"Tensor\"\n+];\n+\n+pub fn enum_name_message_header(e: MessageHeader) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_MESSAGE_HEADER[index]\n+}\n+\n+pub struct MessageHeaderUnionTableOffset {}\n+/// ----------------------------------------------------------------------\n+/// Data structures for describing a table row batch (a collection of\n+/// equal-length Arrow arrays)\n+/// Metadata about a field at some level of a nested type tree (but not\n+/// its children).\n+///\n+/// For example, a List<Int16> with values [[1, 2, 3], null, [4], [5, 6], null]\n+/// would have {length: 5, null_count: 2} for its List node, and {length: 6,\n+/// null_count: 0} for its Int16 node, as separate FieldNode structs\n+// struct FieldNode, aligned to 8\n+#[repr(C, align(8))]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct FieldNode {\n+  length_: i64,\n+  null_count_: i64,\n+} // pub struct FieldNode\n+impl flatbuffers::SafeSliceAccess for FieldNode {}\n+impl<'a> flatbuffers::Follow<'a> for FieldNode {\n+  type Inner = &'a FieldNode;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    <&'a FieldNode>::follow(buf, loc)\n+  }\n+}\n+impl<'a> flatbuffers::Follow<'a> for &'a FieldNode {\n+  type Inner = &'a FieldNode;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::follow_cast_ref::<FieldNode>(buf, loc)\n+  }\n+}\n+impl<'b> flatbuffers::Push for FieldNode {\n+    type Output = FieldNode;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(self as *const FieldNode as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+impl<'b> flatbuffers::Push for &'b FieldNode {\n+    type Output = FieldNode;\n+\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(*self as *const FieldNode as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+\n+\n+impl FieldNode {\n+  pub fn new<'a>(_length: i64, _null_count: i64) -> Self {\n+    FieldNode {\n+      length_: _length.to_little_endian(),\n+      null_count_: _null_count.to_little_endian(),\n+\n+    }\n+  }\n+  /// The number of value slots in the Arrow array at this level of a nested\n+  /// tree\n+  pub fn length<'a>(&'a self) -> i64 {\n+    self.length_.from_little_endian()\n+  }\n+  /// The number of observed nulls. Fields with null_count == 0 may choose not\n+  /// to write their physical validity bitmap out as a materialized buffer,\n+  /// instead setting the length of the bitmap buffer to 0.\n+  pub fn null_count<'a>(&'a self) -> i64 {\n+    self.null_count_.from_little_endian()\n+  }\n+}\n+\n+/// A data header describing the shared memory layout of a \"record\" or \"row\"\n+/// batch. Some systems call this a \"row batch\" internally and others a \"record\n+/// batch\".\n+pub enum RecordBatchOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct RecordBatch<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for RecordBatch<'a> {\n+    type Inner = RecordBatch<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> RecordBatch<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        RecordBatch {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args RecordBatchArgs<'args>) -> flatbuffers::WIPOffset<RecordBatch<'bldr>> {\n+      let mut builder = RecordBatchBuilder::new(_fbb);\n+      builder.add_length(args.length);\n+      if let Some(x) = args.buffers { builder.add_buffers(x); }\n+      if let Some(x) = args.nodes { builder.add_nodes(x); }\n+      builder.finish()\n+    }\n+\n+    pub const VT_LENGTH: flatbuffers::VOffsetT = 4;\n+    pub const VT_NODES: flatbuffers::VOffsetT = 6;\n+    pub const VT_BUFFERS: flatbuffers::VOffsetT = 8;\n+\n+  /// number of records / rows. The arrays in the batch should all have this\n+  /// length\n+  #[inline]\n+  pub fn length(&self) -> i64 {\n+    self._tab.get::<i64>(RecordBatch::VT_LENGTH, Some(0)).unwrap()\n+  }\n+  /// Nodes correspond to the pre-ordered flattened logical schema\n+  #[inline]\n+  pub fn nodes(&self) -> Option<&'a [FieldNode]> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<FieldNode>>>(RecordBatch::VT_NODES, None).map(|v| v.safe_slice() )\n+  }\n+  /// Buffers correspond to the pre-ordered flattened buffer tree\n+  ///\n+  /// The number of buffers appended to this list depends on the schema. For\n+  /// example, most primitive arrays will have 2 buffers, 1 for the validity\n+  /// bitmap and 1 for the values. For struct arrays, there will only be a\n+  /// single buffer for the validity (nulls) bitmap\n+  #[inline]\n+  pub fn buffers(&self) -> Option<&'a [Buffer]> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Buffer>>>(RecordBatch::VT_BUFFERS, None).map(|v| v.safe_slice() )\n+  }\n+}\n+\n+pub struct RecordBatchArgs<'a> {\n+    pub length: i64,\n+    pub nodes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , FieldNode>>>,\n+    pub buffers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Buffer>>>,\n+}\n+impl<'a> Default for RecordBatchArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        RecordBatchArgs {\n+            length: 0,\n+            nodes: None,\n+            buffers: None,\n+        }\n+    }\n+}\n+pub struct RecordBatchBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> RecordBatchBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_length(&mut self, length: i64) {\n+    self.fbb_.push_slot::<i64>(RecordBatch::VT_LENGTH, length, 0);\n+  }\n+  #[inline]\n+  pub fn add_nodes(&mut self, nodes: flatbuffers::WIPOffset<flatbuffers::Vector<'b , FieldNode>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordBatch::VT_NODES, nodes);\n+  }\n+  #[inline]\n+  pub fn add_buffers(&mut self, buffers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Buffer>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(RecordBatch::VT_BUFFERS, buffers);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RecordBatchBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    RecordBatchBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<RecordBatch<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// For sending dictionary encoding information. Any Field can be\n+/// dictionary-encoded, but in this case none of its children may be\n+/// dictionary-encoded.\n+/// There is one vector / column per dictionary, but that vector / column\n+/// may be spread across multiple dictionary batches by using the isDelta\n+/// flag\n+pub enum DictionaryBatchOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct DictionaryBatch<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for DictionaryBatch<'a> {\n+    type Inner = DictionaryBatch<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> DictionaryBatch<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        DictionaryBatch {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args DictionaryBatchArgs<'args>) -> flatbuffers::WIPOffset<DictionaryBatch<'bldr>> {\n+      let mut builder = DictionaryBatchBuilder::new(_fbb);\n+      builder.add_id(args.id);\n+      if let Some(x) = args.data { builder.add_data(x); }\n+      builder.add_isDelta(args.isDelta);\n+      builder.finish()\n+    }\n+\n+    pub const VT_ID: flatbuffers::VOffsetT = 4;\n+    pub const VT_DATA: flatbuffers::VOffsetT = 6;\n+    pub const VT_ISDELTA: flatbuffers::VOffsetT = 8;\n+\n+  #[inline]\n+  pub fn id(&self) -> i64 {\n+    self._tab.get::<i64>(DictionaryBatch::VT_ID, Some(0)).unwrap()\n+  }\n+  #[inline]\n+  pub fn data(&self) -> Option<RecordBatch<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<RecordBatch<'a>>>(DictionaryBatch::VT_DATA, None)\n+  }\n+  /// If isDelta is true the values in the dictionary are to be appended to a\n+  /// dictionary with the indicated id\n+  #[inline]\n+  pub fn isDelta(&self) -> bool {\n+    self._tab.get::<bool>(DictionaryBatch::VT_ISDELTA, Some(false)).unwrap()\n+  }\n+}\n+\n+pub struct DictionaryBatchArgs<'a> {\n+    pub id: i64,\n+    pub data: Option<flatbuffers::WIPOffset<RecordBatch<'a >>>,\n+    pub isDelta: bool,\n+}\n+impl<'a> Default for DictionaryBatchArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        DictionaryBatchArgs {\n+            id: 0,\n+            data: None,\n+            isDelta: false,\n+        }\n+    }\n+}\n+pub struct DictionaryBatchBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> DictionaryBatchBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_id(&mut self, id: i64) {\n+    self.fbb_.push_slot::<i64>(DictionaryBatch::VT_ID, id, 0);\n+  }\n+  #[inline]\n+  pub fn add_data(&mut self, data: flatbuffers::WIPOffset<RecordBatch<'b >>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<RecordBatch>>(DictionaryBatch::VT_DATA, data);\n+  }\n+  #[inline]\n+  pub fn add_isDelta(&mut self, isDelta: bool) {\n+    self.fbb_.push_slot::<bool>(DictionaryBatch::VT_ISDELTA, isDelta, false);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictionaryBatchBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    DictionaryBatchBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<DictionaryBatch<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum MessageOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Message<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Message<'a> {\n+    type Inner = Message<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Message<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Message {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args MessageArgs) -> flatbuffers::WIPOffset<Message<'bldr>> {\n+      let mut builder = MessageBuilder::new(_fbb);\n+      builder.add_bodyLength(args.bodyLength);\n+      if let Some(x) = args.header { builder.add_header(x); }\n+      builder.add_version(args.version);\n+      builder.add_header_type(args.header_type);\n+      builder.finish()\n+    }\n+\n+    pub const VT_VERSION: flatbuffers::VOffsetT = 4;\n+    pub const VT_HEADER_TYPE: flatbuffers::VOffsetT = 6;\n+    pub const VT_HEADER: flatbuffers::VOffsetT = 8;\n+    pub const VT_BODYLENGTH: flatbuffers::VOffsetT = 10;\n+\n+  #[inline]\n+  pub fn version(&self) -> MetadataVersion {\n+    self._tab.get::<MetadataVersion>(Message::VT_VERSION, Some(MetadataVersion::V1)).unwrap()\n+  }\n+  #[inline]\n+  pub fn header_type(&self) -> MessageHeader {\n+    self._tab.get::<MessageHeader>(Message::VT_HEADER_TYPE, Some(MessageHeader::NONE)).unwrap()\n+  }\n+  #[inline]\n+  pub fn header(&self) -> Option<flatbuffers::Table<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_HEADER, None)\n+  }\n+  #[inline]\n+  pub fn bodyLength(&self) -> i64 {\n+    self._tab.get::<i64>(Message::VT_BODYLENGTH, Some(0)).unwrap()\n+  }\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn header_as_schema(&'a self) -> Option<Schema> {\n+    if self.header_type() == MessageHeader::Schema {\n+      self.header().map(|u| Schema::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn header_as_dictionary_batch(&'a self) -> Option<DictionaryBatch> {\n+    if self.header_type() == MessageHeader::DictionaryBatch {\n+      self.header().map(|u| DictionaryBatch::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn header_as_record_batch(&'a self) -> Option<RecordBatch> {\n+    if self.header_type() == MessageHeader::RecordBatch {\n+      self.header().map(|u| RecordBatch::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn header_as_tensor(&'a self) -> Option<Tensor> {\n+    if self.header_type() == MessageHeader::Tensor {\n+      self.header().map(|u| Tensor::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+}\n+\n+pub struct MessageArgs {\n+    pub version: MetadataVersion,\n+    pub header_type: MessageHeader,\n+    pub header: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,\n+    pub bodyLength: i64,\n+}\n+impl<'a> Default for MessageArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        MessageArgs {\n+            version: MetadataVersion::V1,\n+            header_type: MessageHeader::NONE,\n+            header: None,\n+            bodyLength: 0,\n+        }\n+    }\n+}\n+pub struct MessageBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_version(&mut self, version: MetadataVersion) {\n+    self.fbb_.push_slot::<MetadataVersion>(Message::VT_VERSION, version, MetadataVersion::V1);\n+  }\n+  #[inline]\n+  pub fn add_header_type(&mut self, header_type: MessageHeader) {\n+    self.fbb_.push_slot::<MessageHeader>(Message::VT_HEADER_TYPE, header_type, MessageHeader::NONE);\n+  }\n+  #[inline]\n+  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_HEADER, header);\n+  }\n+  #[inline]\n+  pub fn add_bodyLength(&mut self, bodyLength: i64) {\n+    self.fbb_.push_slot::<i64>(Message::VT_BODYLENGTH, bodyLength, 0);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    MessageBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+#[inline]\n+pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {\n+  flatbuffers::get_root::<Message<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {\n+  flatbuffers::get_size_prefixed_root::<Message<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn finish_message_buffer<'a, 'b>(\n+    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+    root: flatbuffers::WIPOffset<Message<'a>>) {\n+  fbb.finish(root, None);\n+}\n+\n+#[inline]\n+pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {\n+  fbb.finish_size_prefixed(root, None);\n+}\ndiff --git a/rust/src/format/mod.rs b/rust/src/format/mod.rs\nnew file mode 100644\nindex 0000000000..fae314ecd7\n--- /dev/null\n+++ b/rust/src/format/mod.rs\n@@ -0,0 +1,4 @@\n+pub mod file;\n+pub mod message;\n+pub mod schema;\n+pub mod tensor;\n\\ No newline at end of file\ndiff --git a/rust/src/format/schema.rs b/rust/src/format/schema.rs\nnew file mode 100644\nindex 0000000000..2a004721e0\n--- /dev/null\n+++ b/rust/src/format/schema.rs\n@@ -0,0 +1,2632 @@\n+// automatically generated by the FlatBuffers compiler, do not modify\n+\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use std::mem;\n+use std::cmp::Ordering;\n+extern crate flatbuffers;\n+use self::flatbuffers::EndianScalar;\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum MetadataVersion {\n+  /// 0.1.0\n+  V1 = 0,\n+  /// 0.2.0\n+  V2 = 1,\n+  /// 0.3.0 -> 0.7.1\n+  V3 = 2,\n+  /// >= 0.8.0\n+  V4 = 3,\n+\n+}\n+\n+const ENUM_MIN_METADATA_VERSION: i16 = 0;\n+const ENUM_MAX_METADATA_VERSION: i16 = 3;\n+\n+impl<'a> flatbuffers::Follow<'a> for MetadataVersion {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for MetadataVersion {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const MetadataVersion;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const MetadataVersion;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for MetadataVersion {\n+    type Output = MetadataVersion;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<MetadataVersion>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_METADATA_VERSION:[MetadataVersion; 4] = [\n+  MetadataVersion::V1,\n+  MetadataVersion::V2,\n+  MetadataVersion::V3,\n+  MetadataVersion::V4\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_METADATA_VERSION:[&'static str; 4] = [\n+    \"V1\",\n+    \"V2\",\n+    \"V3\",\n+    \"V4\"\n+];\n+\n+pub fn enum_name_metadata_version(e: MetadataVersion) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_METADATA_VERSION[index]\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum UnionMode {\n+  Sparse = 0,\n+  Dense = 1,\n+\n+}\n+\n+const ENUM_MIN_UNION_MODE: i16 = 0;\n+const ENUM_MAX_UNION_MODE: i16 = 1;\n+\n+impl<'a> flatbuffers::Follow<'a> for UnionMode {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for UnionMode {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const UnionMode;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const UnionMode;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for UnionMode {\n+    type Output = UnionMode;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<UnionMode>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_UNION_MODE:[UnionMode; 2] = [\n+  UnionMode::Sparse,\n+  UnionMode::Dense\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_UNION_MODE:[&'static str; 2] = [\n+    \"Sparse\",\n+    \"Dense\"\n+];\n+\n+pub fn enum_name_union_mode(e: UnionMode) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_UNION_MODE[index]\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum Precision {\n+  HALF = 0,\n+  SINGLE = 1,\n+  DOUBLE = 2,\n+\n+}\n+\n+const ENUM_MIN_PRECISION: i16 = 0;\n+const ENUM_MAX_PRECISION: i16 = 2;\n+\n+impl<'a> flatbuffers::Follow<'a> for Precision {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for Precision {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const Precision;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const Precision;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for Precision {\n+    type Output = Precision;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<Precision>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_PRECISION:[Precision; 3] = [\n+  Precision::HALF,\n+  Precision::SINGLE,\n+  Precision::DOUBLE\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_PRECISION:[&'static str; 3] = [\n+    \"HALF\",\n+    \"SINGLE\",\n+    \"DOUBLE\"\n+];\n+\n+pub fn enum_name_precision(e: Precision) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_PRECISION[index]\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum DateUnit {\n+  DAY = 0,\n+  MILLISECOND = 1,\n+\n+}\n+\n+const ENUM_MIN_DATE_UNIT: i16 = 0;\n+const ENUM_MAX_DATE_UNIT: i16 = 1;\n+\n+impl<'a> flatbuffers::Follow<'a> for DateUnit {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for DateUnit {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const DateUnit;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const DateUnit;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for DateUnit {\n+    type Output = DateUnit;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<DateUnit>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_DATE_UNIT:[DateUnit; 2] = [\n+  DateUnit::DAY,\n+  DateUnit::MILLISECOND\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_DATE_UNIT:[&'static str; 2] = [\n+    \"DAY\",\n+    \"MILLISECOND\"\n+];\n+\n+pub fn enum_name_date_unit(e: DateUnit) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_DATE_UNIT[index]\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum TimeUnit {\n+  SECOND = 0,\n+  MILLISECOND = 1,\n+  MICROSECOND = 2,\n+  NANOSECOND = 3,\n+\n+}\n+\n+const ENUM_MIN_TIME_UNIT: i16 = 0;\n+const ENUM_MAX_TIME_UNIT: i16 = 3;\n+\n+impl<'a> flatbuffers::Follow<'a> for TimeUnit {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for TimeUnit {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const TimeUnit;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const TimeUnit;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for TimeUnit {\n+    type Output = TimeUnit;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<TimeUnit>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_TIME_UNIT:[TimeUnit; 4] = [\n+  TimeUnit::SECOND,\n+  TimeUnit::MILLISECOND,\n+  TimeUnit::MICROSECOND,\n+  TimeUnit::NANOSECOND\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_TIME_UNIT:[&'static str; 4] = [\n+    \"SECOND\",\n+    \"MILLISECOND\",\n+    \"MICROSECOND\",\n+    \"NANOSECOND\"\n+];\n+\n+pub fn enum_name_time_unit(e: TimeUnit) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_TIME_UNIT[index]\n+}\n+\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum IntervalUnit {\n+  YEAR_MONTH = 0,\n+  DAY_TIME = 1,\n+\n+}\n+\n+const ENUM_MIN_INTERVAL_UNIT: i16 = 0;\n+const ENUM_MAX_INTERVAL_UNIT: i16 = 1;\n+\n+impl<'a> flatbuffers::Follow<'a> for IntervalUnit {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for IntervalUnit {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const IntervalUnit;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const IntervalUnit;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for IntervalUnit {\n+    type Output = IntervalUnit;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<IntervalUnit>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_INTERVAL_UNIT:[IntervalUnit; 2] = [\n+  IntervalUnit::YEAR_MONTH,\n+  IntervalUnit::DAY_TIME\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_INTERVAL_UNIT:[&'static str; 2] = [\n+    \"YEAR_MONTH\",\n+    \"DAY_TIME\"\n+];\n+\n+pub fn enum_name_interval_unit(e: IntervalUnit) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_INTERVAL_UNIT[index]\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// Top-level Type value, enabling extensible type-specific metadata. We can\n+/// add new logical types to Type without breaking backwards compatibility\n+#[allow(non_camel_case_types)]\n+#[repr(u8)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum Type {\n+  NONE = 0,\n+  Null = 1,\n+  Int = 2,\n+  FloatingPoint = 3,\n+  Binary = 4,\n+  Utf8 = 5,\n+  Bool = 6,\n+  Decimal = 7,\n+  Date = 8,\n+  Time = 9,\n+  Timestamp = 10,\n+  Interval = 11,\n+  List = 12,\n+  Struct_ = 13,\n+  Union = 14,\n+  FixedSizeBinary = 15,\n+  FixedSizeList = 16,\n+  Map = 17,\n+\n+}\n+\n+const ENUM_MIN_TYPE: u8 = 0;\n+const ENUM_MAX_TYPE: u8 = 17;\n+\n+impl<'a> flatbuffers::Follow<'a> for Type {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for Type {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = u8::to_le(self as u8);\n+    let p = &n as *const u8 as *const Type;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = u8::from_le(self as u8);\n+    let p = &n as *const u8 as *const Type;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for Type {\n+    type Output = Type;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<Type>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_TYPE:[Type; 18] = [\n+  Type::NONE,\n+  Type::Null,\n+  Type::Int,\n+  Type::FloatingPoint,\n+  Type::Binary,\n+  Type::Utf8,\n+  Type::Bool,\n+  Type::Decimal,\n+  Type::Date,\n+  Type::Time,\n+  Type::Timestamp,\n+  Type::Interval,\n+  Type::List,\n+  Type::Struct_,\n+  Type::Union,\n+  Type::FixedSizeBinary,\n+  Type::FixedSizeList,\n+  Type::Map\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_TYPE:[&'static str; 18] = [\n+    \"NONE\",\n+    \"Null\",\n+    \"Int\",\n+    \"FloatingPoint\",\n+    \"Binary\",\n+    \"Utf8\",\n+    \"Bool\",\n+    \"Decimal\",\n+    \"Date\",\n+    \"Time\",\n+    \"Timestamp\",\n+    \"Interval\",\n+    \"List\",\n+    \"Struct_\",\n+    \"Union\",\n+    \"FixedSizeBinary\",\n+    \"FixedSizeList\",\n+    \"Map\"\n+];\n+\n+pub fn enum_name_type(e: Type) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_TYPE[index]\n+}\n+\n+pub struct TypeUnionTableOffset {}\n+/// ----------------------------------------------------------------------\n+/// Endianness of the platform producing the data\n+#[allow(non_camel_case_types)]\n+#[repr(i16)]\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+pub enum Endianness {\n+  Little = 0,\n+  Big = 1,\n+\n+}\n+\n+const ENUM_MIN_ENDIANNESS: i16 = 0;\n+const ENUM_MAX_ENDIANNESS: i16 = 1;\n+\n+impl<'a> flatbuffers::Follow<'a> for Endianness {\n+  type Inner = Self;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::read_scalar_at::<Self>(buf, loc)\n+  }\n+}\n+\n+impl flatbuffers::EndianScalar for Endianness {\n+  #[inline]\n+  fn to_little_endian(self) -> Self {\n+    let n = i16::to_le(self as i16);\n+    let p = &n as *const i16 as *const Endianness;\n+    unsafe { *p }\n+  }\n+  #[inline]\n+  fn from_little_endian(self) -> Self {\n+    let n = i16::from_le(self as i16);\n+    let p = &n as *const i16 as *const Endianness;\n+    unsafe { *p }\n+  }\n+}\n+\n+impl flatbuffers::Push for Endianness {\n+    type Output = Endianness;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        flatbuffers::emplace_scalar::<Endianness>(dst, *self);\n+    }\n+}\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_VALUES_ENDIANNESS:[Endianness; 2] = [\n+  Endianness::Little,\n+  Endianness::Big\n+];\n+\n+#[allow(non_camel_case_types)]\n+const ENUM_NAMES_ENDIANNESS:[&'static str; 2] = [\n+    \"Little\",\n+    \"Big\"\n+];\n+\n+pub fn enum_name_endianness(e: Endianness) -> &'static str {\n+  let index: usize = e as usize;\n+  ENUM_NAMES_ENDIANNESS[index]\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// A Buffer represents a single contiguous memory segment\n+// struct Buffer, aligned to 8\n+#[repr(C, align(8))]\n+#[derive(Clone, Copy, Debug, PartialEq)]\n+pub struct Buffer {\n+  offset_: i64,\n+  length_: i64,\n+} // pub struct Buffer\n+impl flatbuffers::SafeSliceAccess for Buffer {}\n+impl<'a> flatbuffers::Follow<'a> for Buffer {\n+  type Inner = &'a Buffer;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    <&'a Buffer>::follow(buf, loc)\n+  }\n+}\n+impl<'a> flatbuffers::Follow<'a> for &'a Buffer {\n+  type Inner = &'a Buffer;\n+  #[inline]\n+  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+    flatbuffers::follow_cast_ref::<Buffer>(buf, loc)\n+  }\n+}\n+impl<'b> flatbuffers::Push for Buffer {\n+    type Output = Buffer;\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(self as *const Buffer as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+impl<'b> flatbuffers::Push for &'b Buffer {\n+    type Output = Buffer;\n+\n+    #[inline]\n+    fn push(&self, dst: &mut [u8], _rest: &[u8]) {\n+        let src = unsafe {\n+            ::std::slice::from_raw_parts(*self as *const Buffer as *const u8, Self::size())\n+        };\n+        dst.copy_from_slice(src);\n+    }\n+}\n+\n+\n+impl Buffer {\n+  pub fn new<'a>(_offset: i64, _length: i64) -> Self {\n+    Buffer {\n+      offset_: _offset.to_little_endian(),\n+      length_: _length.to_little_endian(),\n+\n+    }\n+  }\n+  /// The relative offset into the shared memory page where the bytes for this\n+  /// buffer starts\n+  pub fn offset<'a>(&'a self) -> i64 {\n+    self.offset_.from_little_endian()\n+  }\n+  /// The absolute length (in bytes) of the memory buffer. The memory is found\n+  /// from offset (inclusive) to offset + length (non-inclusive).\n+  pub fn length<'a>(&'a self) -> i64 {\n+    self.length_.from_little_endian()\n+  }\n+}\n+\n+/// These are stored in the flatbuffer in the Type union below\n+pub enum NullOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Null<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Null<'a> {\n+    type Inner = Null<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Null<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Null {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args NullArgs) -> flatbuffers::WIPOffset<Null<'bldr>> {\n+      let mut builder = NullBuilder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct NullArgs {\n+}\n+impl<'a> Default for NullArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        NullArgs {\n+        }\n+    }\n+}\n+pub struct NullBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> NullBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NullBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    NullBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Null<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// A Struct_ in the flatbuffer metadata is the same as an Arrow Struct\n+/// (according to the physical memory layout). We used Struct_ here as\n+/// Struct is a reserved word in Flatbuffers\n+pub enum Struct_Offset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Struct_<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Struct_<'a> {\n+    type Inner = Struct_<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Struct_<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Struct_ {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args Struct_Args) -> flatbuffers::WIPOffset<Struct_<'bldr>> {\n+      let mut builder = Struct_Builder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct Struct_Args {\n+}\n+impl<'a> Default for Struct_Args {\n+    #[inline]\n+    fn default() -> Self {\n+        Struct_Args {\n+        }\n+    }\n+}\n+pub struct Struct_Builder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> Struct_Builder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Struct_Builder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    Struct_Builder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Struct_<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum ListOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct List<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for List<'a> {\n+    type Inner = List<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> List<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        List {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args ListArgs) -> flatbuffers::WIPOffset<List<'bldr>> {\n+      let mut builder = ListBuilder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct ListArgs {\n+}\n+impl<'a> Default for ListArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        ListArgs {\n+        }\n+    }\n+}\n+pub struct ListBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> ListBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> ListBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    ListBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<List<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum FixedSizeListOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct FixedSizeList<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for FixedSizeList<'a> {\n+    type Inner = FixedSizeList<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> FixedSizeList<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        FixedSizeList {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args FixedSizeListArgs) -> flatbuffers::WIPOffset<FixedSizeList<'bldr>> {\n+      let mut builder = FixedSizeListBuilder::new(_fbb);\n+      builder.add_listSize(args.listSize);\n+      builder.finish()\n+    }\n+\n+    pub const VT_LISTSIZE: flatbuffers::VOffsetT = 4;\n+\n+  /// Number of list items per value\n+  #[inline]\n+  pub fn listSize(&self) -> i32 {\n+    self._tab.get::<i32>(FixedSizeList::VT_LISTSIZE, Some(0)).unwrap()\n+  }\n+}\n+\n+pub struct FixedSizeListArgs {\n+    pub listSize: i32,\n+}\n+impl<'a> Default for FixedSizeListArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        FixedSizeListArgs {\n+            listSize: 0,\n+        }\n+    }\n+}\n+pub struct FixedSizeListBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> FixedSizeListBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_listSize(&mut self, listSize: i32) {\n+    self.fbb_.push_slot::<i32>(FixedSizeList::VT_LISTSIZE, listSize, 0);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FixedSizeListBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    FixedSizeListBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<FixedSizeList<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// A Map is a logical nested type that is represented as\n+///\n+/// List<entry: Struct<key: K, value: V>>\n+///\n+/// In this layout, the keys and values are each respectively contiguous. We do\n+/// not constrain the key and value types, so the application is responsible\n+/// for ensuring that the keys are hashable and unique. Whether the keys are sorted\n+/// may be set in the metadata for this field\n+///\n+/// In a Field with Map type, the Field has a child Struct field, which then\n+/// has two children: key type and the second the value type. The names of the\n+/// child fields may be respectively \"entry\", \"key\", and \"value\", but this is\n+/// not enforced\n+///\n+/// Map\n+///   - child[0] entry: Struct\n+///     - child[0] key: K\n+///     - child[1] value: V\n+///\n+/// Neither the \"entry\" field nor the \"key\" field may be nullable.\n+///\n+/// The metadata is structured so that Arrow systems without special handling\n+/// for Map can make Map an alias for List. The \"layout\" attribute for the Map\n+/// field must have the same contents as a List.\n+pub enum MapOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Map<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Map<'a> {\n+    type Inner = Map<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Map<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Map {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args MapArgs) -> flatbuffers::WIPOffset<Map<'bldr>> {\n+      let mut builder = MapBuilder::new(_fbb);\n+      builder.add_keysSorted(args.keysSorted);\n+      builder.finish()\n+    }\n+\n+    pub const VT_KEYSSORTED: flatbuffers::VOffsetT = 4;\n+\n+  /// Set to true if the keys within each value are sorted\n+  #[inline]\n+  pub fn keysSorted(&self) -> bool {\n+    self._tab.get::<bool>(Map::VT_KEYSSORTED, Some(false)).unwrap()\n+  }\n+}\n+\n+pub struct MapArgs {\n+    pub keysSorted: bool,\n+}\n+impl<'a> Default for MapArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        MapArgs {\n+            keysSorted: false,\n+        }\n+    }\n+}\n+pub struct MapBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> MapBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_keysSorted(&mut self, keysSorted: bool) {\n+    self.fbb_.push_slot::<bool>(Map::VT_KEYSSORTED, keysSorted, false);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MapBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    MapBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Map<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// A union is a complex type with children in Field\n+/// By default ids in the type vector refer to the offsets in the children\n+/// optionally typeIds provides an indirection between the child offset and the type id\n+/// for each child typeIds[offset] is the id used in the type vector\n+pub enum UnionOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Union<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Union<'a> {\n+    type Inner = Union<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Union<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Union {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args UnionArgs<'args>) -> flatbuffers::WIPOffset<Union<'bldr>> {\n+      let mut builder = UnionBuilder::new(_fbb);\n+      if let Some(x) = args.typeIds { builder.add_typeIds(x); }\n+      builder.add_mode(args.mode);\n+      builder.finish()\n+    }\n+\n+    pub const VT_MODE: flatbuffers::VOffsetT = 4;\n+    pub const VT_TYPEIDS: flatbuffers::VOffsetT = 6;\n+\n+  #[inline]\n+  pub fn mode(&self) -> UnionMode {\n+    self._tab.get::<UnionMode>(Union::VT_MODE, Some(UnionMode::Sparse)).unwrap()\n+  }\n+  #[inline]\n+  pub fn typeIds(&self) -> Option<flatbuffers::Vector<'a, i32>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(Union::VT_TYPEIDS, None)\n+  }\n+}\n+\n+pub struct UnionArgs<'a> {\n+    pub mode: UnionMode,\n+    pub typeIds: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  i32>>>,\n+}\n+impl<'a> Default for UnionArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        UnionArgs {\n+            mode: UnionMode::Sparse,\n+            typeIds: None,\n+        }\n+    }\n+}\n+pub struct UnionBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> UnionBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_mode(&mut self, mode: UnionMode) {\n+    self.fbb_.push_slot::<UnionMode>(Union::VT_MODE, mode, UnionMode::Sparse);\n+  }\n+  #[inline]\n+  pub fn add_typeIds(&mut self, typeIds: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i32>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Union::VT_TYPEIDS, typeIds);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UnionBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    UnionBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Union<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum IntOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Int<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Int<'a> {\n+    type Inner = Int<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Int<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Int {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args IntArgs) -> flatbuffers::WIPOffset<Int<'bldr>> {\n+      let mut builder = IntBuilder::new(_fbb);\n+      builder.add_bitWidth(args.bitWidth);\n+      builder.add_is_signed(args.is_signed);\n+      builder.finish()\n+    }\n+\n+    pub const VT_BITWIDTH: flatbuffers::VOffsetT = 4;\n+    pub const VT_IS_SIGNED: flatbuffers::VOffsetT = 6;\n+\n+  #[inline]\n+  pub fn bitWidth(&self) -> i32 {\n+    self._tab.get::<i32>(Int::VT_BITWIDTH, Some(0)).unwrap()\n+  }\n+  #[inline]\n+  pub fn is_signed(&self) -> bool {\n+    self._tab.get::<bool>(Int::VT_IS_SIGNED, Some(false)).unwrap()\n+  }\n+}\n+\n+pub struct IntArgs {\n+    pub bitWidth: i32,\n+    pub is_signed: bool,\n+}\n+impl<'a> Default for IntArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        IntArgs {\n+            bitWidth: 0,\n+            is_signed: false,\n+        }\n+    }\n+}\n+pub struct IntBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> IntBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_bitWidth(&mut self, bitWidth: i32) {\n+    self.fbb_.push_slot::<i32>(Int::VT_BITWIDTH, bitWidth, 0);\n+  }\n+  #[inline]\n+  pub fn add_is_signed(&mut self, is_signed: bool) {\n+    self.fbb_.push_slot::<bool>(Int::VT_IS_SIGNED, is_signed, false);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    IntBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Int<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum FloatingPointOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct FloatingPoint<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for FloatingPoint<'a> {\n+    type Inner = FloatingPoint<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> FloatingPoint<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        FloatingPoint {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args FloatingPointArgs) -> flatbuffers::WIPOffset<FloatingPoint<'bldr>> {\n+      let mut builder = FloatingPointBuilder::new(_fbb);\n+      builder.add_precision(args.precision);\n+      builder.finish()\n+    }\n+\n+    pub const VT_PRECISION: flatbuffers::VOffsetT = 4;\n+\n+  #[inline]\n+  pub fn precision(&self) -> Precision {\n+    self._tab.get::<Precision>(FloatingPoint::VT_PRECISION, Some(Precision::HALF)).unwrap()\n+  }\n+}\n+\n+pub struct FloatingPointArgs {\n+    pub precision: Precision,\n+}\n+impl<'a> Default for FloatingPointArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        FloatingPointArgs {\n+            precision: Precision::HALF,\n+        }\n+    }\n+}\n+pub struct FloatingPointBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> FloatingPointBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_precision(&mut self, precision: Precision) {\n+    self.fbb_.push_slot::<Precision>(FloatingPoint::VT_PRECISION, precision, Precision::HALF);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FloatingPointBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    FloatingPointBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<FloatingPoint<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// Unicode with UTF-8 encoding\n+pub enum Utf8Offset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Utf8<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Utf8<'a> {\n+    type Inner = Utf8<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Utf8<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Utf8 {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args Utf8Args) -> flatbuffers::WIPOffset<Utf8<'bldr>> {\n+      let mut builder = Utf8Builder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct Utf8Args {\n+}\n+impl<'a> Default for Utf8Args {\n+    #[inline]\n+    fn default() -> Self {\n+        Utf8Args {\n+        }\n+    }\n+}\n+pub struct Utf8Builder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> Utf8Builder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> Utf8Builder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    Utf8Builder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Utf8<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum BinaryOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Binary<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Binary<'a> {\n+    type Inner = Binary<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Binary<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Binary {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args BinaryArgs) -> flatbuffers::WIPOffset<Binary<'bldr>> {\n+      let mut builder = BinaryBuilder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct BinaryArgs {\n+}\n+impl<'a> Default for BinaryArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        BinaryArgs {\n+        }\n+    }\n+}\n+pub struct BinaryBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> BinaryBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BinaryBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    BinaryBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Binary<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum FixedSizeBinaryOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct FixedSizeBinary<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for FixedSizeBinary<'a> {\n+    type Inner = FixedSizeBinary<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> FixedSizeBinary<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        FixedSizeBinary {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args FixedSizeBinaryArgs) -> flatbuffers::WIPOffset<FixedSizeBinary<'bldr>> {\n+      let mut builder = FixedSizeBinaryBuilder::new(_fbb);\n+      builder.add_byteWidth(args.byteWidth);\n+      builder.finish()\n+    }\n+\n+    pub const VT_BYTEWIDTH: flatbuffers::VOffsetT = 4;\n+\n+  /// Number of bytes per value\n+  #[inline]\n+  pub fn byteWidth(&self) -> i32 {\n+    self._tab.get::<i32>(FixedSizeBinary::VT_BYTEWIDTH, Some(0)).unwrap()\n+  }\n+}\n+\n+pub struct FixedSizeBinaryArgs {\n+    pub byteWidth: i32,\n+}\n+impl<'a> Default for FixedSizeBinaryArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        FixedSizeBinaryArgs {\n+            byteWidth: 0,\n+        }\n+    }\n+}\n+pub struct FixedSizeBinaryBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> FixedSizeBinaryBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_byteWidth(&mut self, byteWidth: i32) {\n+    self.fbb_.push_slot::<i32>(FixedSizeBinary::VT_BYTEWIDTH, byteWidth, 0);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FixedSizeBinaryBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    FixedSizeBinaryBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<FixedSizeBinary<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum BoolOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Bool<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Bool<'a> {\n+    type Inner = Bool<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Bool<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Bool {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        _args: &'args BoolArgs) -> flatbuffers::WIPOffset<Bool<'bldr>> {\n+      let mut builder = BoolBuilder::new(_fbb);\n+      builder.finish()\n+    }\n+\n+}\n+\n+pub struct BoolArgs {\n+}\n+impl<'a> Default for BoolArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        BoolArgs {\n+        }\n+    }\n+}\n+pub struct BoolBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> BoolBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BoolBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    BoolBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Bool<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum DecimalOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Decimal<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Decimal<'a> {\n+    type Inner = Decimal<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Decimal<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Decimal {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args DecimalArgs) -> flatbuffers::WIPOffset<Decimal<'bldr>> {\n+      let mut builder = DecimalBuilder::new(_fbb);\n+      builder.add_scale(args.scale);\n+      builder.add_precision(args.precision);\n+      builder.finish()\n+    }\n+\n+    pub const VT_PRECISION: flatbuffers::VOffsetT = 4;\n+    pub const VT_SCALE: flatbuffers::VOffsetT = 6;\n+\n+  /// Total number of decimal digits\n+  #[inline]\n+  pub fn precision(&self) -> i32 {\n+    self._tab.get::<i32>(Decimal::VT_PRECISION, Some(0)).unwrap()\n+  }\n+  /// Number of digits after the decimal point \".\"\n+  #[inline]\n+  pub fn scale(&self) -> i32 {\n+    self._tab.get::<i32>(Decimal::VT_SCALE, Some(0)).unwrap()\n+  }\n+}\n+\n+pub struct DecimalArgs {\n+    pub precision: i32,\n+    pub scale: i32,\n+}\n+impl<'a> Default for DecimalArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        DecimalArgs {\n+            precision: 0,\n+            scale: 0,\n+        }\n+    }\n+}\n+pub struct DecimalBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> DecimalBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_precision(&mut self, precision: i32) {\n+    self.fbb_.push_slot::<i32>(Decimal::VT_PRECISION, precision, 0);\n+  }\n+  #[inline]\n+  pub fn add_scale(&mut self, scale: i32) {\n+    self.fbb_.push_slot::<i32>(Decimal::VT_SCALE, scale, 0);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DecimalBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    DecimalBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Decimal<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// Date is either a 32-bit or 64-bit type representing elapsed time since UNIX\n+/// epoch (1970-01-01), stored in either of two units:\n+///\n+/// * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n+///   leap seconds), where the values are evenly divisible by 86400000\n+/// * Days (32 bits) since the UNIX epoch\n+pub enum DateOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Date<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Date<'a> {\n+    type Inner = Date<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Date<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Date {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args DateArgs) -> flatbuffers::WIPOffset<Date<'bldr>> {\n+      let mut builder = DateBuilder::new(_fbb);\n+      builder.add_unit(args.unit);\n+      builder.finish()\n+    }\n+\n+    pub const VT_UNIT: flatbuffers::VOffsetT = 4;\n+\n+  #[inline]\n+  pub fn unit(&self) -> DateUnit {\n+    self._tab.get::<DateUnit>(Date::VT_UNIT, Some(DateUnit::MILLISECOND)).unwrap()\n+  }\n+}\n+\n+pub struct DateArgs {\n+    pub unit: DateUnit,\n+}\n+impl<'a> Default for DateArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        DateArgs {\n+            unit: DateUnit::MILLISECOND,\n+        }\n+    }\n+}\n+pub struct DateBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> DateBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_unit(&mut self, unit: DateUnit) {\n+    self.fbb_.push_slot::<DateUnit>(Date::VT_UNIT, unit, DateUnit::MILLISECOND);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DateBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    DateBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Date<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// Time type. The physical storage type depends on the unit\n+/// - SECOND and MILLISECOND: 32 bits\n+/// - MICROSECOND and NANOSECOND: 64 bits\n+pub enum TimeOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Time<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Time<'a> {\n+    type Inner = Time<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Time<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Time {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args TimeArgs) -> flatbuffers::WIPOffset<Time<'bldr>> {\n+      let mut builder = TimeBuilder::new(_fbb);\n+      builder.add_bitWidth(args.bitWidth);\n+      builder.add_unit(args.unit);\n+      builder.finish()\n+    }\n+\n+    pub const VT_UNIT: flatbuffers::VOffsetT = 4;\n+    pub const VT_BITWIDTH: flatbuffers::VOffsetT = 6;\n+\n+  #[inline]\n+  pub fn unit(&self) -> TimeUnit {\n+    self._tab.get::<TimeUnit>(Time::VT_UNIT, Some(TimeUnit::MILLISECOND)).unwrap()\n+  }\n+  #[inline]\n+  pub fn bitWidth(&self) -> i32 {\n+    self._tab.get::<i32>(Time::VT_BITWIDTH, Some(32)).unwrap()\n+  }\n+}\n+\n+pub struct TimeArgs {\n+    pub unit: TimeUnit,\n+    pub bitWidth: i32,\n+}\n+impl<'a> Default for TimeArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        TimeArgs {\n+            unit: TimeUnit::MILLISECOND,\n+            bitWidth: 32,\n+        }\n+    }\n+}\n+pub struct TimeBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> TimeBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_unit(&mut self, unit: TimeUnit) {\n+    self.fbb_.push_slot::<TimeUnit>(Time::VT_UNIT, unit, TimeUnit::MILLISECOND);\n+  }\n+  #[inline]\n+  pub fn add_bitWidth(&mut self, bitWidth: i32) {\n+    self.fbb_.push_slot::<i32>(Time::VT_BITWIDTH, bitWidth, 32);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimeBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    TimeBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Time<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding\n+/// leap seconds, as a 64-bit integer. Note that UNIX time does not include\n+/// leap seconds.\n+///\n+/// The Timestamp metadata supports both \"time zone naive\" and \"time zone\n+/// aware\" timestamps. Read about the timezone attribute for more detail\n+pub enum TimestampOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Timestamp<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Timestamp<'a> {\n+    type Inner = Timestamp<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Timestamp<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Timestamp {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args TimestampArgs<'args>) -> flatbuffers::WIPOffset<Timestamp<'bldr>> {\n+      let mut builder = TimestampBuilder::new(_fbb);\n+      if let Some(x) = args.timezone { builder.add_timezone(x); }\n+      builder.add_unit(args.unit);\n+      builder.finish()\n+    }\n+\n+    pub const VT_UNIT: flatbuffers::VOffsetT = 4;\n+    pub const VT_TIMEZONE: flatbuffers::VOffsetT = 6;\n+\n+  #[inline]\n+  pub fn unit(&self) -> TimeUnit {\n+    self._tab.get::<TimeUnit>(Timestamp::VT_UNIT, Some(TimeUnit::SECOND)).unwrap()\n+  }\n+  /// The time zone is a string indicating the name of a time zone, one of:\n+  ///\n+  /// * As used in the Olson time zone database (the \"tz database\" or\n+  ///   \"tzdata\"), such as \"America/New_York\"\n+  /// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30\n+  ///\n+  /// Whether a timezone string is present indicates different semantics about\n+  /// the data:\n+  ///\n+  /// * If the time zone is null or equal to an empty string, the data is \"time\n+  ///   zone naive\" and shall be displayed *as is* to the user, not localized\n+  ///   to the locale of the user. This data can be though of as UTC but\n+  ///   without having \"UTC\" as the time zone, it is not considered to be\n+  ///   localized to any time zone\n+  ///\n+  /// * If the time zone is set to a valid value, values can be displayed as\n+  ///   \"localized\" to that time zone, even though the underlying 64-bit\n+  ///   integers are identical to the same data stored in UTC. Converting\n+  ///   between time zones is a metadata-only operation and does not change the\n+  ///   underlying values\n+  #[inline]\n+  pub fn timezone(&self) -> Option<&'a str> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Timestamp::VT_TIMEZONE, None)\n+  }\n+}\n+\n+pub struct TimestampArgs<'a> {\n+    pub unit: TimeUnit,\n+    pub timezone: Option<flatbuffers::WIPOffset<&'a  str>>,\n+}\n+impl<'a> Default for TimestampArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        TimestampArgs {\n+            unit: TimeUnit::SECOND,\n+            timezone: None,\n+        }\n+    }\n+}\n+pub struct TimestampBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> TimestampBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_unit(&mut self, unit: TimeUnit) {\n+    self.fbb_.push_slot::<TimeUnit>(Timestamp::VT_UNIT, unit, TimeUnit::SECOND);\n+  }\n+  #[inline]\n+  pub fn add_timezone(&mut self, timezone: flatbuffers::WIPOffset<&'b  str>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Timestamp::VT_TIMEZONE, timezone);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TimestampBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    TimestampBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Timestamp<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum IntervalOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Interval<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Interval<'a> {\n+    type Inner = Interval<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Interval<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Interval {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args IntervalArgs) -> flatbuffers::WIPOffset<Interval<'bldr>> {\n+      let mut builder = IntervalBuilder::new(_fbb);\n+      builder.add_unit(args.unit);\n+      builder.finish()\n+    }\n+\n+    pub const VT_UNIT: flatbuffers::VOffsetT = 4;\n+\n+  #[inline]\n+  pub fn unit(&self) -> IntervalUnit {\n+    self._tab.get::<IntervalUnit>(Interval::VT_UNIT, Some(IntervalUnit::YEAR_MONTH)).unwrap()\n+  }\n+}\n+\n+pub struct IntervalArgs {\n+    pub unit: IntervalUnit,\n+}\n+impl<'a> Default for IntervalArgs {\n+    #[inline]\n+    fn default() -> Self {\n+        IntervalArgs {\n+            unit: IntervalUnit::YEAR_MONTH,\n+        }\n+    }\n+}\n+pub struct IntervalBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> IntervalBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_unit(&mut self, unit: IntervalUnit) {\n+    self.fbb_.push_slot::<IntervalUnit>(Interval::VT_UNIT, unit, IntervalUnit::YEAR_MONTH);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> IntervalBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    IntervalBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Interval<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// user defined key value pairs to add custom metadata to arrow\n+/// key namespacing is the responsibility of the user\n+pub enum KeyValueOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct KeyValue<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for KeyValue<'a> {\n+    type Inner = KeyValue<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> KeyValue<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        KeyValue {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args KeyValueArgs<'args>) -> flatbuffers::WIPOffset<KeyValue<'bldr>> {\n+      let mut builder = KeyValueBuilder::new(_fbb);\n+      if let Some(x) = args.value { builder.add_value(x); }\n+      if let Some(x) = args.key { builder.add_key(x); }\n+      builder.finish()\n+    }\n+\n+    pub const VT_KEY: flatbuffers::VOffsetT = 4;\n+    pub const VT_VALUE: flatbuffers::VOffsetT = 6;\n+\n+  #[inline]\n+  pub fn key(&self) -> Option<&'a str> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_KEY, None)\n+  }\n+  #[inline]\n+  pub fn value(&self) -> Option<&'a str> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(KeyValue::VT_VALUE, None)\n+  }\n+}\n+\n+pub struct KeyValueArgs<'a> {\n+    pub key: Option<flatbuffers::WIPOffset<&'a  str>>,\n+    pub value: Option<flatbuffers::WIPOffset<&'a  str>>,\n+}\n+impl<'a> Default for KeyValueArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        KeyValueArgs {\n+            key: None,\n+            value: None,\n+        }\n+    }\n+}\n+pub struct KeyValueBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> KeyValueBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_key(&mut self, key: flatbuffers::WIPOffset<&'b  str>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_KEY, key);\n+  }\n+  #[inline]\n+  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b  str>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(KeyValue::VT_VALUE, value);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> KeyValueBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    KeyValueBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<KeyValue<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// Dictionary encoding metadata\n+pub enum DictionaryEncodingOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct DictionaryEncoding<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for DictionaryEncoding<'a> {\n+    type Inner = DictionaryEncoding<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> DictionaryEncoding<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        DictionaryEncoding {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args DictionaryEncodingArgs<'args>) -> flatbuffers::WIPOffset<DictionaryEncoding<'bldr>> {\n+      let mut builder = DictionaryEncodingBuilder::new(_fbb);\n+      builder.add_id(args.id);\n+      if let Some(x) = args.indexType { builder.add_indexType(x); }\n+      builder.add_isOrdered(args.isOrdered);\n+      builder.finish()\n+    }\n+\n+    pub const VT_ID: flatbuffers::VOffsetT = 4;\n+    pub const VT_INDEXTYPE: flatbuffers::VOffsetT = 6;\n+    pub const VT_ISORDERED: flatbuffers::VOffsetT = 8;\n+\n+  /// The known dictionary id in the application where this data is used. In\n+  /// the file or streaming formats, the dictionary ids are found in the\n+  /// DictionaryBatch messages\n+  #[inline]\n+  pub fn id(&self) -> i64 {\n+    self._tab.get::<i64>(DictionaryEncoding::VT_ID, Some(0)).unwrap()\n+  }\n+  /// The dictionary indices are constrained to be positive integers. If this\n+  /// field is null, the indices must be signed int32\n+  #[inline]\n+  pub fn indexType(&self) -> Option<Int<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<Int<'a>>>(DictionaryEncoding::VT_INDEXTYPE, None)\n+  }\n+  /// By default, dictionaries are not ordered, or the order does not have\n+  /// semantic meaning. In some statistical, applications, dictionary-encoding\n+  /// is used to represent ordered categorical data, and we provide a way to\n+  /// preserve that metadata here\n+  #[inline]\n+  pub fn isOrdered(&self) -> bool {\n+    self._tab.get::<bool>(DictionaryEncoding::VT_ISORDERED, Some(false)).unwrap()\n+  }\n+}\n+\n+pub struct DictionaryEncodingArgs<'a> {\n+    pub id: i64,\n+    pub indexType: Option<flatbuffers::WIPOffset<Int<'a >>>,\n+    pub isOrdered: bool,\n+}\n+impl<'a> Default for DictionaryEncodingArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        DictionaryEncodingArgs {\n+            id: 0,\n+            indexType: None,\n+            isOrdered: false,\n+        }\n+    }\n+}\n+pub struct DictionaryEncodingBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> DictionaryEncodingBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_id(&mut self, id: i64) {\n+    self.fbb_.push_slot::<i64>(DictionaryEncoding::VT_ID, id, 0);\n+  }\n+  #[inline]\n+  pub fn add_indexType(&mut self, indexType: flatbuffers::WIPOffset<Int<'b >>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Int>>(DictionaryEncoding::VT_INDEXTYPE, indexType);\n+  }\n+  #[inline]\n+  pub fn add_isOrdered(&mut self, isOrdered: bool) {\n+    self.fbb_.push_slot::<bool>(DictionaryEncoding::VT_ISORDERED, isOrdered, false);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> DictionaryEncodingBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    DictionaryEncodingBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<DictionaryEncoding<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// A field represents a named column in a record / row batch or child of a\n+/// nested type.\n+///\n+/// - children is only for nested Arrow arrays\n+/// - For primitive types, children will have length 0\n+/// - nullable should default to true in general\n+pub enum FieldOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Field<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Field<'a> {\n+    type Inner = Field<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Field<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Field {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args FieldArgs<'args>) -> flatbuffers::WIPOffset<Field<'bldr>> {\n+      let mut builder = FieldBuilder::new(_fbb);\n+      if let Some(x) = args.custom_metadata { builder.add_custom_metadata(x); }\n+      if let Some(x) = args.children { builder.add_children(x); }\n+      if let Some(x) = args.dictionary { builder.add_dictionary(x); }\n+      if let Some(x) = args.type_ { builder.add_type_(x); }\n+      if let Some(x) = args.name { builder.add_name(x); }\n+      builder.add_type_type(args.type_type);\n+      builder.add_nullable(args.nullable);\n+      builder.finish()\n+    }\n+\n+    pub const VT_NAME: flatbuffers::VOffsetT = 4;\n+    pub const VT_NULLABLE: flatbuffers::VOffsetT = 6;\n+    pub const VT_TYPE_TYPE: flatbuffers::VOffsetT = 8;\n+    pub const VT_TYPE_: flatbuffers::VOffsetT = 10;\n+    pub const VT_DICTIONARY: flatbuffers::VOffsetT = 12;\n+    pub const VT_CHILDREN: flatbuffers::VOffsetT = 14;\n+    pub const VT_CUSTOM_METADATA: flatbuffers::VOffsetT = 16;\n+\n+  #[inline]\n+  pub fn name(&self) -> Option<&'a str> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Field::VT_NAME, None)\n+  }\n+  #[inline]\n+  pub fn nullable(&self) -> bool {\n+    self._tab.get::<bool>(Field::VT_NULLABLE, Some(false)).unwrap()\n+  }\n+  #[inline]\n+  pub fn type_type(&self) -> Type {\n+    self._tab.get::<Type>(Field::VT_TYPE_TYPE, Some(Type::NONE)).unwrap()\n+  }\n+  #[inline]\n+  pub fn type_(&self) -> Option<flatbuffers::Table<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Field::VT_TYPE_, None)\n+  }\n+  #[inline]\n+  pub fn dictionary(&self) -> Option<DictionaryEncoding<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<DictionaryEncoding<'a>>>(Field::VT_DICTIONARY, None)\n+  }\n+  #[inline]\n+  pub fn children(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Field<'a>>>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Field<'a>>>>>(Field::VT_CHILDREN, None)\n+  }\n+  #[inline]\n+  pub fn custom_metadata(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Field::VT_CUSTOM_METADATA, None)\n+  }\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_null(&'a self) -> Option<Null> {\n+    if self.type_type() == Type::Null {\n+      self.type_().map(|u| Null::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_int(&'a self) -> Option<Int> {\n+    if self.type_type() == Type::Int {\n+      self.type_().map(|u| Int::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_floating_point(&'a self) -> Option<FloatingPoint> {\n+    if self.type_type() == Type::FloatingPoint {\n+      self.type_().map(|u| FloatingPoint::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_binary(&'a self) -> Option<Binary> {\n+    if self.type_type() == Type::Binary {\n+      self.type_().map(|u| Binary::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_utf_8(&'a self) -> Option<Utf8> {\n+    if self.type_type() == Type::Utf8 {\n+      self.type_().map(|u| Utf8::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_bool(&'a self) -> Option<Bool> {\n+    if self.type_type() == Type::Bool {\n+      self.type_().map(|u| Bool::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_decimal(&'a self) -> Option<Decimal> {\n+    if self.type_type() == Type::Decimal {\n+      self.type_().map(|u| Decimal::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_date(&'a self) -> Option<Date> {\n+    if self.type_type() == Type::Date {\n+      self.type_().map(|u| Date::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_time(&'a self) -> Option<Time> {\n+    if self.type_type() == Type::Time {\n+      self.type_().map(|u| Time::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_timestamp(&'a self) -> Option<Timestamp> {\n+    if self.type_type() == Type::Timestamp {\n+      self.type_().map(|u| Timestamp::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_interval(&'a self) -> Option<Interval> {\n+    if self.type_type() == Type::Interval {\n+      self.type_().map(|u| Interval::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_list(&'a self) -> Option<List> {\n+    if self.type_type() == Type::List {\n+      self.type_().map(|u| List::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_struct_(&'a self) -> Option<Struct_> {\n+    if self.type_type() == Type::Struct_ {\n+      self.type_().map(|u| Struct_::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_union(&'a self) -> Option<Union> {\n+    if self.type_type() == Type::Union {\n+      self.type_().map(|u| Union::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_fixed_size_binary(&'a self) -> Option<FixedSizeBinary> {\n+    if self.type_type() == Type::FixedSizeBinary {\n+      self.type_().map(|u| FixedSizeBinary::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_fixed_size_list(&'a self) -> Option<FixedSizeList> {\n+    if self.type_type() == Type::FixedSizeList {\n+      self.type_().map(|u| FixedSizeList::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_map(&'a self) -> Option<Map> {\n+    if self.type_type() == Type::Map {\n+      self.type_().map(|u| Map::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+}\n+\n+pub struct FieldArgs<'a> {\n+    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,\n+    pub nullable: bool,\n+    pub type_type: Type,\n+    pub type_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,\n+    pub dictionary: Option<flatbuffers::WIPOffset<DictionaryEncoding<'a >>>,\n+    pub children: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Field<'a >>>>>,\n+    pub custom_metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,\n+}\n+impl<'a> Default for FieldArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        FieldArgs {\n+            name: None,\n+            nullable: false,\n+            type_type: Type::NONE,\n+            type_: None,\n+            dictionary: None,\n+            children: None,\n+            custom_metadata: None,\n+        }\n+    }\n+}\n+pub struct FieldBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> FieldBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_NAME, name);\n+  }\n+  #[inline]\n+  pub fn add_nullable(&mut self, nullable: bool) {\n+    self.fbb_.push_slot::<bool>(Field::VT_NULLABLE, nullable, false);\n+  }\n+  #[inline]\n+  pub fn add_type_type(&mut self, type_type: Type) {\n+    self.fbb_.push_slot::<Type>(Field::VT_TYPE_TYPE, type_type, Type::NONE);\n+  }\n+  #[inline]\n+  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_TYPE_, type_);\n+  }\n+  #[inline]\n+  pub fn add_dictionary(&mut self, dictionary: flatbuffers::WIPOffset<DictionaryEncoding<'b >>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<DictionaryEncoding>>(Field::VT_DICTIONARY, dictionary);\n+  }\n+  #[inline]\n+  pub fn add_children(&mut self, children: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Field<'b >>>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_CHILDREN, children);\n+  }\n+  #[inline]\n+  pub fn add_custom_metadata(&mut self, custom_metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Field::VT_CUSTOM_METADATA, custom_metadata);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> FieldBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    FieldBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Field<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+/// ----------------------------------------------------------------------\n+/// A Schema describes the columns in a row batch\n+pub enum SchemaOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Schema<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Schema<'a> {\n+    type Inner = Schema<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Schema<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Schema {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args SchemaArgs<'args>) -> flatbuffers::WIPOffset<Schema<'bldr>> {\n+      let mut builder = SchemaBuilder::new(_fbb);\n+      if let Some(x) = args.custom_metadata { builder.add_custom_metadata(x); }\n+      if let Some(x) = args.fields { builder.add_fields(x); }\n+      builder.add_endianness(args.endianness);\n+      builder.finish()\n+    }\n+\n+    pub const VT_ENDIANNESS: flatbuffers::VOffsetT = 4;\n+    pub const VT_FIELDS: flatbuffers::VOffsetT = 6;\n+    pub const VT_CUSTOM_METADATA: flatbuffers::VOffsetT = 8;\n+\n+  /// endianness of the buffer\n+  /// it is Little Endian by default\n+  /// if endianness doesn't match the underlying system then the vectors need to be converted\n+  #[inline]\n+  pub fn endianness(&self) -> Endianness {\n+    self._tab.get::<Endianness>(Schema::VT_ENDIANNESS, Some(Endianness::Little)).unwrap()\n+  }\n+  #[inline]\n+  pub fn fields(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Field<'a>>>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Field<'a>>>>>(Schema::VT_FIELDS, None)\n+  }\n+  #[inline]\n+  pub fn custom_metadata(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<KeyValue<'a>>>>>(Schema::VT_CUSTOM_METADATA, None)\n+  }\n+}\n+\n+pub struct SchemaArgs<'a> {\n+    pub endianness: Endianness,\n+    pub fields: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Field<'a >>>>>,\n+    pub custom_metadata: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<KeyValue<'a >>>>>,\n+}\n+impl<'a> Default for SchemaArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        SchemaArgs {\n+            endianness: Endianness::Little,\n+            fields: None,\n+            custom_metadata: None,\n+        }\n+    }\n+}\n+pub struct SchemaBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> SchemaBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_endianness(&mut self, endianness: Endianness) {\n+    self.fbb_.push_slot::<Endianness>(Schema::VT_ENDIANNESS, endianness, Endianness::Little);\n+  }\n+  #[inline]\n+  pub fn add_fields(&mut self, fields: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Field<'b >>>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_FIELDS, fields);\n+  }\n+  #[inline]\n+  pub fn add_custom_metadata(&mut self, custom_metadata: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<KeyValue<'b >>>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Schema::VT_CUSTOM_METADATA, custom_metadata);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SchemaBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    SchemaBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Schema<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+#[inline]\n+pub fn get_root_as_schema<'a>(buf: &'a [u8]) -> Schema<'a> {\n+  flatbuffers::get_root::<Schema<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn get_size_prefixed_root_as_schema<'a>(buf: &'a [u8]) -> Schema<'a> {\n+  flatbuffers::get_size_prefixed_root::<Schema<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn finish_schema_buffer<'a, 'b>(\n+    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+    root: flatbuffers::WIPOffset<Schema<'a>>) {\n+  fbb.finish(root, None);\n+}\n+\n+#[inline]\n+pub fn finish_size_prefixed_schema_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Schema<'a>>) {\n+  fbb.finish_size_prefixed(root, None);\n+}\n+\n+\ndiff --git a/rust/src/format/tensor.rs b/rust/src/format/tensor.rs\nnew file mode 100644\nindex 0000000000..e27445ab02\n--- /dev/null\n+++ b/rust/src/format/tensor.rs\n@@ -0,0 +1,423 @@\n+// automatically generated by the FlatBuffers compiler, do not modify\n+\n+#![allow(dead_code)]\n+#![allow(unused_imports)]\n+\n+use std::mem;\n+use std::cmp::Ordering;\n+\n+extern crate flatbuffers;\n+use self::flatbuffers::EndianScalar;\n+use ::format::schema::*;\n+\n+/// Shape data for a single axis in a tensor\n+pub enum TensorDimOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct TensorDim<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for TensorDim<'a> {\n+    type Inner = TensorDim<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> TensorDim<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        TensorDim {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args TensorDimArgs<'args>) -> flatbuffers::WIPOffset<TensorDim<'bldr>> {\n+      let mut builder = TensorDimBuilder::new(_fbb);\n+      builder.add_size_(args.size_);\n+      if let Some(x) = args.name { builder.add_name(x); }\n+      builder.finish()\n+    }\n+\n+    pub const VT_SIZE_: flatbuffers::VOffsetT = 4;\n+    pub const VT_NAME: flatbuffers::VOffsetT = 6;\n+\n+  /// Length of dimension\n+  #[inline]\n+  pub fn size_(&self) -> i64 {\n+    self._tab.get::<i64>(TensorDim::VT_SIZE_, Some(0)).unwrap()\n+  }\n+  /// Name of the dimension, optional\n+  #[inline]\n+  pub fn name(&self) -> Option<&'a str> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(TensorDim::VT_NAME, None)\n+  }\n+}\n+\n+pub struct TensorDimArgs<'a> {\n+    pub size_: i64,\n+    pub name: Option<flatbuffers::WIPOffset<&'a  str>>,\n+}\n+impl<'a> Default for TensorDimArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        TensorDimArgs {\n+            size_: 0,\n+            name: None,\n+        }\n+    }\n+}\n+pub struct TensorDimBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> TensorDimBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_size_(&mut self, size_: i64) {\n+    self.fbb_.push_slot::<i64>(TensorDim::VT_SIZE_, size_, 0);\n+  }\n+  #[inline]\n+  pub fn add_name(&mut self, name: flatbuffers::WIPOffset<&'b  str>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(TensorDim::VT_NAME, name);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorDimBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    TensorDimBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<TensorDim<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+pub enum TensorOffset {}\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+\n+pub struct Tensor<'a> {\n+  pub _tab: flatbuffers::Table<'a>,\n+}\n+\n+impl<'a> flatbuffers::Follow<'a> for Tensor<'a> {\n+    type Inner = Tensor<'a>;\n+    #[inline]\n+    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {\n+        Self {\n+            _tab: flatbuffers::Table { buf: buf, loc: loc },\n+        }\n+    }\n+}\n+\n+impl<'a> Tensor<'a> {\n+    #[inline]\n+    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {\n+        Tensor {\n+            _tab: table,\n+        }\n+    }\n+    #[allow(unused_mut)]\n+    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(\n+        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,\n+        args: &'args TensorArgs<'args>) -> flatbuffers::WIPOffset<Tensor<'bldr>> {\n+      let mut builder = TensorBuilder::new(_fbb);\n+      if let Some(x) = args.data { builder.add_data(x); }\n+      if let Some(x) = args.strides { builder.add_strides(x); }\n+      if let Some(x) = args.shape { builder.add_shape(x); }\n+      if let Some(x) = args.type_ { builder.add_type_(x); }\n+      builder.add_type_type(args.type_type);\n+      builder.finish()\n+    }\n+\n+    pub const VT_TYPE_TYPE: flatbuffers::VOffsetT = 4;\n+    pub const VT_TYPE_: flatbuffers::VOffsetT = 6;\n+    pub const VT_SHAPE: flatbuffers::VOffsetT = 8;\n+    pub const VT_STRIDES: flatbuffers::VOffsetT = 10;\n+    pub const VT_DATA: flatbuffers::VOffsetT = 12;\n+\n+  #[inline]\n+  pub fn type_type(&self) -> Type {\n+    self._tab.get::<Type>(Tensor::VT_TYPE_TYPE, Some(Type::NONE)).unwrap()\n+  }\n+  /// The type of data contained in a value cell. Currently only fixed-width\n+  /// value types are supported, no strings or nested types\n+  #[inline]\n+  pub fn type_(&self) -> Option<flatbuffers::Table<'a>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Tensor::VT_TYPE_, None)\n+  }\n+  /// The dimensions of the tensor, optionally named\n+  #[inline]\n+  pub fn shape(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TensorDim<'a>>>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<TensorDim<'a>>>>>(Tensor::VT_SHAPE, None)\n+  }\n+  /// Non-negative byte offsets to advance one value cell along each dimension\n+  #[inline]\n+  pub fn strides(&self) -> Option<flatbuffers::Vector<'a, i64>> {\n+    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(Tensor::VT_STRIDES, None)\n+  }\n+  /// The location and size of the tensor's data\n+  #[inline]\n+  pub fn data(&self) -> Option<&'a Buffer> {\n+    self._tab.get::<Buffer>(Tensor::VT_DATA, None)\n+  }\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_null(&'a self) -> Option<Null> {\n+    if self.type_type() == Type::Null {\n+      self.type_().map(|u| Null::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_int(&'a self) -> Option<Int> {\n+    if self.type_type() == Type::Int {\n+      self.type_().map(|u| Int::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_floating_point(&'a self) -> Option<FloatingPoint> {\n+    if self.type_type() == Type::FloatingPoint {\n+      self.type_().map(|u| FloatingPoint::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_binary(&'a self) -> Option<Binary> {\n+    if self.type_type() == Type::Binary {\n+      self.type_().map(|u| Binary::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_utf_8(&'a self) -> Option<Utf8> {\n+    if self.type_type() == Type::Utf8 {\n+      self.type_().map(|u| Utf8::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_bool(&'a self) -> Option<Bool> {\n+    if self.type_type() == Type::Bool {\n+      self.type_().map(|u| Bool::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_decimal(&'a self) -> Option<Decimal> {\n+    if self.type_type() == Type::Decimal {\n+      self.type_().map(|u| Decimal::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_date(&'a self) -> Option<Date> {\n+    if self.type_type() == Type::Date {\n+      self.type_().map(|u| Date::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_time(&'a self) -> Option<Time> {\n+    if self.type_type() == Type::Time {\n+      self.type_().map(|u| Time::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_timestamp(&'a self) -> Option<Timestamp> {\n+    if self.type_type() == Type::Timestamp {\n+      self.type_().map(|u| Timestamp::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_interval(&'a self) -> Option<Interval> {\n+    if self.type_type() == Type::Interval {\n+      self.type_().map(|u| Interval::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_list(&'a self) -> Option<List> {\n+    if self.type_type() == Type::List {\n+      self.type_().map(|u| List::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_struct_(&'a self) -> Option<Struct_> {\n+    if self.type_type() == Type::Struct_ {\n+      self.type_().map(|u| Struct_::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_union(&'a self) -> Option<Union> {\n+    if self.type_type() == Type::Union {\n+      self.type_().map(|u| Union::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_fixed_size_binary(&'a self) -> Option<FixedSizeBinary> {\n+    if self.type_type() == Type::FixedSizeBinary {\n+      self.type_().map(|u| FixedSizeBinary::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_fixed_size_list(&'a self) -> Option<FixedSizeList> {\n+    if self.type_type() == Type::FixedSizeList {\n+      self.type_().map(|u| FixedSizeList::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+  #[inline]\n+  #[allow(non_snake_case)]\n+  pub fn type__as_map(&'a self) -> Option<Map> {\n+    if self.type_type() == Type::Map {\n+      self.type_().map(|u| Map::init_from_table(u))\n+    } else {\n+      None\n+    }\n+  }\n+\n+}\n+\n+pub struct TensorArgs<'a> {\n+    pub type_type: Type,\n+    pub type_: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,\n+    pub shape: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<TensorDim<'a >>>>>,\n+    pub strides: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  i64>>>,\n+    pub data: Option<&'a  Buffer>,\n+}\n+impl<'a> Default for TensorArgs<'a> {\n+    #[inline]\n+    fn default() -> Self {\n+        TensorArgs {\n+            type_type: Type::NONE,\n+            type_: None,\n+            shape: None,\n+            strides: None,\n+            data: None,\n+        }\n+    }\n+}\n+pub struct TensorBuilder<'a: 'b, 'b> {\n+  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,\n+}\n+impl<'a: 'b, 'b> TensorBuilder<'a, 'b> {\n+  #[inline]\n+  pub fn add_type_type(&mut self, type_type: Type) {\n+    self.fbb_.push_slot::<Type>(Tensor::VT_TYPE_TYPE, type_type, Type::NONE);\n+  }\n+  #[inline]\n+  pub fn add_type_(&mut self, type_: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_TYPE_, type_);\n+  }\n+  #[inline]\n+  pub fn add_shape(&mut self, shape: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<TensorDim<'b >>>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_SHAPE, shape);\n+  }\n+  #[inline]\n+  pub fn add_strides(&mut self, strides: flatbuffers::WIPOffset<flatbuffers::Vector<'b , i64>>) {\n+    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Tensor::VT_STRIDES, strides);\n+  }\n+  #[inline]\n+  pub fn add_data(&mut self, data: &'b  Buffer) {\n+    self.fbb_.push_slot_always::<&Buffer>(Tensor::VT_DATA, data);\n+  }\n+  #[inline]\n+  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> TensorBuilder<'a, 'b> {\n+    let start = _fbb.start_table();\n+    TensorBuilder {\n+      fbb_: _fbb,\n+      start_: start,\n+    }\n+  }\n+  #[inline]\n+  pub fn finish(self) -> flatbuffers::WIPOffset<Tensor<'a>> {\n+    let o = self.fbb_.end_table(self.start_);\n+    flatbuffers::WIPOffset::new(o.value())\n+  }\n+}\n+\n+#[inline]\n+pub fn get_root_as_tensor<'a>(buf: &'a [u8]) -> Tensor<'a> {\n+  flatbuffers::get_root::<Tensor<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn get_size_prefixed_root_as_tensor<'a>(buf: &'a [u8]) -> Tensor<'a> {\n+  flatbuffers::get_size_prefixed_root::<Tensor<'a>>(buf)\n+}\n+\n+#[inline]\n+pub fn finish_tensor_buffer<'a, 'b>(\n+    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,\n+    root: flatbuffers::WIPOffset<Tensor<'a>>) {\n+  fbb.finish(root, None);\n+}\n+\n+#[inline]\n+pub fn finish_size_prefixed_tensor_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Tensor<'a>>) {\n+  fbb.finish_size_prefixed(root, None);\n+}\ndiff --git a/rust/src/lib.rs b/rust/src/lib.rs\nindex 52f6763b00..9930b5ae03 100644\n--- a/rust/src/lib.rs\n+++ b/rust/src/lib.rs\n@@ -30,6 +30,7 @@ pub mod buffer;\n pub mod builder;\n pub mod datatypes;\n pub mod error;\n+pub mod format;\n pub mod memory;\n pub mod record_batch;\n pub mod tensor;\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-17T16:38:44.480+0000",
                    "updated": "2018-11-17T16:38:44.480+0000",
                    "started": "2018-11-17T16:38:44.479+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167190",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167197",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439635855\n \n \n   > We would have to download and compile Flatbuffers first\r\n   This will be part of the next flatbuffers release, i.e. we would then be able to skip the compilation step and use a released binary, e.g. via conda?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-17T18:02:57.339+0000",
                    "updated": "2018-11-17T18:02:57.339+0000",
                    "started": "2018-11-17T18:02:57.338+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167197",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167198",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "xhochy edited a comment on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439635855\n \n \n   > We would have to download and compile Flatbuffers first\r\n   \r\n   This will be part of the next flatbuffers release, i.e. we would then be able to skip the compilation step and use a released binary, e.g. via conda?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-17T18:03:08.669+0000",
                    "updated": "2018-11-17T18:03:08.669+0000",
                    "started": "2018-11-17T18:03:08.668+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167198",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167247",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2985: ARROW-2467: [Rust] Add generated flatbuffer source code\nURL: https://github.com/apache/arrow/pull/2985#issuecomment-439705920\n \n \n   Did you delete and recreate your fork? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T16:33:37.405+0000",
                    "updated": "2018-11-18T16:33:37.405+0000",
                    "started": "2018-11-18T16:33:37.404+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167247",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167250",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439706535\n \n \n   > The Rust implementation of Flatbuffers has a couple minor issues that required manually fixing the generated code\r\n   \r\n   Are there any bugs to report upstream?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T16:41:22.602+0000",
                    "updated": "2018-11-18T16:41:22.602+0000",
                    "started": "2018-11-18T16:41:22.601+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167250",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167253",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439709314\n \n \n   @wesm I just filed these issues:\r\n   \r\n   https://github.com/google/flatbuffers/issues/5052\r\n   https://github.com/google/flatbuffers/issues/5053\r\n   https://github.com/google/flatbuffers/issues/5054\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T17:17:52.928+0000",
                    "updated": "2018-11-18T17:17:52.928+0000",
                    "started": "2018-11-18T17:17:52.927+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167253",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167254",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #2985: ARROW-2467: [Rust] Add generated flatbuffer source code\nURL: https://github.com/apache/arrow/pull/2985#issuecomment-439710312\n \n \n   Yes, I did. Looks like you found the new PR. In case anyone else is looking for it, it is https://github.com/apache/arrow/pull/2986\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T17:30:38.984+0000",
                    "updated": "2018-11-18T17:30:38.984+0000",
                    "started": "2018-11-18T17:30:38.981+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167254",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167255",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439711425\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=h1) Report\n   > Merging [#2986](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/60305d5a75e319e2cfec94be8bacf97abde77d90?src=pr&el=desc) will **decrease** coverage by `42.46%`.\n   > The diff coverage is `0%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2986/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree)\n   \n   ```diff\n   @@             Coverage Diff             @@\n   ##           master    #2986       +/-   ##\n   ===========================================\n   - Coverage   86.61%   44.15%   -42.47%     \n   ===========================================\n     Files         491       14      -477     \n     Lines       69438     3209    -66229     \n   ===========================================\n   - Hits        60146     1417    -58729     \n   + Misses       9196     1792     -7404     \n   + Partials       96        0       -96\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/src/lib.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvbGliLnJz) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [rust/src/format/message.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L21lc3NhZ2UucnM=) | `0% <0%> (\u00f8)` | |\n   | [rust/src/format/schema.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L3NjaGVtYS5ycw==) | `0% <0%> (\u00f8)` | |\n   | [rust/src/format/tensor.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L3RlbnNvci5ycw==) | `0% <0%> (\u00f8)` | |\n   | [python/pyarrow/ipc.pxi](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cHl0aG9uL3B5YXJyb3cvaXBjLnB4aQ==) | | |\n   | [cpp/src/parquet/column\\_page.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wYXJxdWV0L2NvbHVtbl9wYWdlLmg=) | | |\n   | [cpp/src/parquet/bloom\\_filter-test.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wYXJxdWV0L2Jsb29tX2ZpbHRlci10ZXN0LmNj) | | |\n   | [cpp/src/plasma/client.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY2xpZW50LmNj) | | |\n   | [cpp/src/arrow/io/test-common.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pby90ZXN0LWNvbW1vbi5o) | | |\n   | [cpp/src/gandiva/function\\_registry.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2Z1bmN0aW9uX3JlZ2lzdHJ5Lmg=) | | |\n   | ... and [477 more](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=footer). Last update [60305d5...899967b](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T17:46:36.596+0000",
                    "updated": "2018-11-18T17:46:36.596+0000",
                    "started": "2018-11-18T17:46:36.595+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167255",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167257",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io edited a comment on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439711425\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=h1) Report\n   > Merging [#2986](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/60305d5a75e319e2cfec94be8bacf97abde77d90?src=pr&el=desc) will **decrease** coverage by `44.01%`.\n   > The diff coverage is `0%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2986/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff             @@\n   ##           master   #2986       +/-   ##\n   ==========================================\n   - Coverage   86.61%   42.6%   -44.02%     \n   ==========================================\n     Files         491      15      -476     \n     Lines       69438    3326    -66112     \n   ==========================================\n   - Hits        60146    1417    -58729     \n   + Misses       9196    1909     -7287     \n   + Partials       96       0       -96\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/src/lib.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvbGliLnJz) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [rust/src/format/file.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L2ZpbGUucnM=) | `0% <0%> (\u00f8)` | |\n   | [rust/src/format/message.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L21lc3NhZ2UucnM=) | `0% <0%> (\u00f8)` | |\n   | [rust/src/format/schema.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L3NjaGVtYS5ycw==) | `0% <0%> (\u00f8)` | |\n   | [rust/src/format/tensor.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvZm9ybWF0L3RlbnNvci5ycw==) | `0% <0%> (\u00f8)` | |\n   | [python/pyarrow/ipc.pxi](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cHl0aG9uL3B5YXJyb3cvaXBjLnB4aQ==) | | |\n   | [cpp/src/parquet/column\\_page.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wYXJxdWV0L2NvbHVtbl9wYWdlLmg=) | | |\n   | [cpp/src/parquet/bloom\\_filter-test.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wYXJxdWV0L2Jsb29tX2ZpbHRlci10ZXN0LmNj) | | |\n   | [cpp/src/plasma/client.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9wbGFzbWEvY2xpZW50LmNj) | | |\n   | [cpp/src/arrow/io/test-common.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9pby90ZXN0LWNvbW1vbi5o) | | |\n   | ... and [479 more](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=footer). Last update [60305d5...c771115](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T18:12:47.404+0000",
                    "updated": "2018-11-18T18:12:47.404+0000",
                    "started": "2018-11-18T18:12:47.404+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167257",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167264",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io edited a comment on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439711425\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=h1) Report\n   > Merging [#2986](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/60305d5a75e319e2cfec94be8bacf97abde77d90?src=pr&el=desc) will **decrease** coverage by `0.01%`.\n   > The diff coverage is `n/a`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/2986/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree)\n   \n   ```diff\n   @@            Coverage Diff            @@\n   ##           master   #2986      +/-   ##\n   =========================================\n   - Coverage   86.61%   86.6%   -0.02%     \n   =========================================\n     Files         491     490       -1     \n     Lines       69438   69231     -207     \n   =========================================\n   - Hits        60146   59957     -189     \n   + Misses       9196    9178      -18     \n     Partials       96      96\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [rust/src/lib.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvbGliLnJz) | `100% <\u00f8> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/array-test.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS10ZXN0LmNj) | `100% <0%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/arrow/util/compression.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy91dGlsL2NvbXByZXNzaW9uLmNj) | `90.9% <0%> (\u00f8)` | :arrow_up: |\n   | [cpp/src/gandiva/annotator.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2Fubm90YXRvci5jYw==) | `97.95% <0%> (\u00f8)` | :arrow_up: |\n   | [rust/src/tensor.rs](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-cnVzdC9zcmMvdGVuc29yLnJz) | | |\n   | [cpp/src/arrow/builder.h](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9idWlsZGVyLmg=) | `97.76% <0%> (+0.03%)` | :arrow_up: |\n   | [cpp/src/gandiva/llvm\\_generator.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9nYW5kaXZhL2xsdm1fZ2VuZXJhdG9yLmNj) | `76.41% <0%> (+0.16%)` | :arrow_up: |\n   | [cpp/src/arrow/csv/column-builder.cc](https://codecov.io/gh/apache/arrow/pull/2986/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9jc3YvY29sdW1uLWJ1aWxkZXIuY2M=) | `97.31% <0%> (+2.01%)` | :arrow_up: |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=footer). Last update [60305d5...1133e97](https://codecov.io/gh/apache/arrow/pull/2986?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T19:42:41.911+0000",
                    "updated": "2018-11-18T19:42:41.911+0000",
                    "started": "2018-11-18T19:42:41.894+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167264",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167265",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439723985\n \n \n   @sunchao @paddyhoran @kszucs This is ready for review\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-18T20:39:56.921+0000",
                    "updated": "2018-11-18T20:39:56.921+0000",
                    "started": "2018-11-18T20:39:56.921+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167265",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167461",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-439978528\n \n \n   Not sure if it's a good idea to add generated files in the repo. Personally, I've had bad experiences with this in the past, such as having to handle different versions of the code generating software. The approach we used in parquet-rs is to create a separate crate just to store the generated files, which may or may not be feasible here..\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T17:38:05.179+0000",
                    "updated": "2018-11-19T17:38:05.179+0000",
                    "started": "2018-11-19T17:38:05.178+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167461",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167465",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on a change in pull request #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#discussion_r234716045\n \n \n\n ##########\n File path: rust/src/lib.rs\n ##########\n @@ -30,6 +30,7 @@ pub mod buffer;\n pub mod builder;\n pub mod datatypes;\n pub mod error;\n+pub mod format;\n \n Review comment:\n   Can we rename this module to `ipc`? following the C++ impl.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T17:41:38.597+0000",
                    "updated": "2018-11-19T17:41:38.597+0000",
                    "started": "2018-11-19T17:41:38.596+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167465",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167496",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-440012984\n \n \n   I would be fine with us having multiple crates for this project, initially having `arrow` and `arrow-format`. We would just need to have one directory per crate under the top level `rust` directory.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-19T19:28:05.721+0000",
                    "updated": "2018-11-19T19:28:05.721+0000",
                    "started": "2018-11-19T19:28:05.721+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167496",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167596",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "paddyhoran commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-440108869\n \n \n   > It would be nice to generate on the fly as part of the build process but this doesn't seem feasible today\r\n   \r\n   IMHO generating on the fly is the ideal situation so it depends how long it would take to get to this end state.  \r\n   \r\n   > This will be part of the next flatbuffers release, i.e. we would then be able to skip the compilation step and use a released binary, e.g. via conda?\r\n   \r\n   This solves the first issue in a reasonable time frame.\r\n   \r\n   The other 3 issues don't seem to be big hurdles and the `flatbuffers` devs have been responsive so it's reasonable that they will be addressed in a reasonable time-frame also.\r\n   \r\n   Given all this I'm in favor of merging this PR and updating to generating on the fly once all the blockers are resolved.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T01:58:58.318+0000",
                    "updated": "2018-11-20T01:58:58.318+0000",
                    "started": "2018-11-20T01:58:58.317+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167596",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "andygrove commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-440343203\n \n \n   @sunchao I started a discussion on the mail list re adding a separate crate but not responses yet. Can we consider this as a separate PR?\r\n   \r\n   @paddyhoran Could you approve please given that you are in favor of merging? Appveyor failed due to something unrelated.\r\n   \r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T16:46:11.411+0000",
                    "updated": "2018-11-20T16:46:11.411+0000",
                    "started": "2018-11-20T16:46:11.410+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167834",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167859",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on issue #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#issuecomment-440356841\n \n \n   > @sunchao I started a discussion on the mail list re adding a separate crate but not responses yet. Can we consider this as a separate PR?\r\n   \r\n   I'm OK as long as this is just a temporary solution.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T17:21:24.537+0000",
                    "updated": "2018-11-20T17:21:24.537+0000",
                    "started": "2018-11-20T17:21:24.536+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167859",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167863",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on a change in pull request #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#discussion_r235096322\n \n \n\n ##########\n File path: .travis.yml\n ##########\n @@ -286,7 +286,7 @@ matrix:\n     - pushd ${TRAVIS_BUILD_DIR}/rust\n     # Run coverage for codecov.io\n     - mkdir -p target/kcov\n-    - RUST_BACKTRACE=1 RUSTUP_TOOLCHAIN=stable cargo coverage --verbose\n+    - RUST_BACKTRACE=1 RUSTUP_TOOLCHAIN=stable cargo coverage --verbose --exclude-pattern=src/format\n \n Review comment:\n   nit: this also needs to be updated.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T17:26:51.678+0000",
                    "updated": "2018-11-20T17:26:51.678+0000",
                    "started": "2018-11-20T17:26:51.677+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167863",
                    "issueId": "13153017"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/worklog/167864",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "sunchao commented on a change in pull request #2986: ARROW-2467: [Rust] Add generated flatbuffers code\nURL: https://github.com/apache/arrow/pull/2986#discussion_r235097793\n \n \n\n ##########\n File path: rust/src/ipc/README.md\n ##########\n @@ -0,0 +1,33 @@\n+<!---\n \n Review comment:\n   Just one thought: if we do keep these generated files, can we keep them in a folder such as `src/ipc/gen`, to isolate them from other source files? \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-20T17:26:51.745+0000",
                    "updated": "2018-11-20T17:26:51.745+0000",
                    "started": "2018-11-20T17:26:51.745+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "167864",
                    "issueId": "13153017"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 18000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5388d53c[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@18436480[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@490433f4[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@4ae03930[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@22a8cd88[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7f267e52[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@17d579d1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5c37eba2[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@3817b921[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@748f849f[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4828602e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2b21e872[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18000,
        "customfield_12312520": null,
        "customfield_12312521": "Mon Apr 08 11:05:00 UTC 2019",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2019-04-08T11:05:00.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2467/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2018-04-17T13:56:17.000+0000",
        "updated": "2019-04-08T12:34:42.000+0000",
        "timeoriginalestimate": null,
        "description": "Generate flatbuffers code for Schema, File, Message, and Tensor and add to project. It would be nice to generate on the fly as part of the build process but this doesn't seem feasible today because:\r\n * We would have to download and compile Flatbuffers first\r\n * The Rust implementation of Flatbuffers has a couple minor issues that required manually fixing the generated code",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Rust] Generate code using Flatbuffers",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13153017/comment/16812342",
                    "id": "16812342",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "body": "Issue resolved by pull request 4021\n[https://github.com/apache/arrow/pull/4021]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kszucs",
                        "name": "kszucs",
                        "key": "kszucs",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "Krisztian Szucs",
                        "active": true,
                        "timeZone": "Europe/Budapest"
                    },
                    "created": "2019-04-08T11:05:00.822+0000",
                    "updated": "2019-04-08T11:05:00.822+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|i3sne7:",
        "customfield_12314139": null
    }
}