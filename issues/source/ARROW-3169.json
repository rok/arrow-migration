{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13182901",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901",
    "key": "ARROW-3169",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12549024",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12549024",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13185597",
                    "key": "ARROW-3254",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13185597",
                    "fields": {
                        "summary": "[C++] Add option to ADD_ARROW_TEST to compose a test executable from multiple .cc files containing unit tests",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
            "name": "wesm",
            "key": "wesmckinn",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
            },
            "displayName": "Wes McKinney",
            "active": true,
            "timeZone": "America/New_York"
        },
        "aggregateprogress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 9600,
            "total": 9600,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3169/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 16,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170286",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou opened a new pull request #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047\n \n \n   This makes the code easier to read and also eases up recompilation times on multicore setups.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T16:18:39.187+0000",
                    "updated": "2018-11-28T16:18:39.187+0000",
                    "started": "2018-11-28T16:18:39.186+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170286",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170296",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442512779\n \n \n   What do you think about creating an \"array\" or \"columnar\" subdirectory where this code (and also possibly array.cc) can be organized?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T16:33:14.115+0000",
                    "updated": "2018-11-28T16:33:14.115+0000",
                    "started": "2018-11-28T16:33:14.114+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170296",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170299",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442513229\n \n \n   I don't know. The Array class is pretty central so it feels a bit weird to put it in a subdirectory. Perhaps we need to think about it some more or ask other people.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T16:34:31.301+0000",
                    "updated": "2018-11-28T16:34:31.301+0000",
                    "started": "2018-11-28T16:34:31.300+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170299",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170301",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442513836\n \n \n   Right. The public API \"arrow/array.h\" wouldn't need to change. We can solicit some more opinions; not really necessary to do anything here\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T16:36:02.122+0000",
                    "updated": "2018-11-28T16:36:02.122+0000",
                    "started": "2018-11-28T16:36:02.121+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170301",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170302",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442517585\n \n \n   cc @xhochy for opinions.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T16:45:50.873+0000",
                    "updated": "2018-11-28T16:45:50.873+0000",
                    "started": "2018-11-28T16:45:50.873+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170302",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170312",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442524151\n \n \n   My opinion: I'd like having a `core` where the very important stuff is, notably type.h, buffer.h, array.h, table.h (possibly move ChunkedArray out of table.h in it's own header), record_batch ...\r\n   \r\n   This would help new comers, you point them to the directory. The other possibility is to clean up the root directory by hidding the not \"critical\" stuff, e.g. allocator, builder, compare, memory pool, pretty print, status, table builder, visitor...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:02:54.368+0000",
                    "updated": "2018-11-28T17:02:54.368+0000",
                    "started": "2018-11-28T17:02:54.367+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170312",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170313",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques edited a comment on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442524151\n \n \n   My opinion: I'd like having a `core` where the very important stuff is, notably type.h, buffer.h, array.h, table.h (possibly move ChunkedArray out of table.h in it's own header), record_batch ...\r\n   \r\n   This would help new comers, you point them to the directory. The other possibility is to clean up the root directory by hidding the non \"critical\" stuff, e.g. allocator, builder, compare, memory pool, pretty print, status, table builder, visitor...\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:03:52.009+0000",
                    "updated": "2018-11-28T17:03:52.009+0000",
                    "started": "2018-11-28T17:03:52.009+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170313",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170318",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442525146\n \n \n   I don't know. Personally I'd rather keep the important stuff in the base directory, where it's immediately reachable :-)\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:05:42.370+0000",
                    "updated": "2018-11-28T17:05:42.370+0000",
                    "started": "2018-11-28T17:05:42.370+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170318",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170329",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442531117\n \n \n   We used to have things split up, a long time ago\r\n   \r\n   https://github.com/apache/arrow/tree/apache-arrow-0.1.0/cpp/src/arrow/types\r\n   \r\n   I do like having the \"most important stuff\" in the base directory, at least the public headers. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:22:11.273+0000",
                    "updated": "2018-11-28T17:22:11.273+0000",
                    "started": "2018-11-28T17:22:11.272+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170329",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170333",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "fsaintjacques commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442532998\n \n \n   Now that I think about it, we have to leave the root directory as-is for backward compatibility, at least in term of (re)moving files.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:27:12.925+0000",
                    "updated": "2018-11-28T17:27:12.925+0000",
                    "started": "2018-11-28T17:27:12.924+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170333",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170338",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442537162\n \n \n   Not sure why the Windows toolchain build is complaining about double-conversion\r\n   \r\n   ```\r\n   Make Error at cmake_modules/ThirdpartyToolchain.cmake:503 (find_package):\r\n     Could not find a package configuration file provided by \"double-conversion\"\r\n     with any of the following names:\r\n       double-conversionConfig.cmake\r\n       double-conversion-config.cmake\r\n     Add the installation prefix of \"double-conversion\" to CMAKE_PREFIX_PATH or\r\n     set \"double-conversion_DIR\" to a directory containing one of the above\r\n     files.  If \"double-conversion\" provides a separate development package or\r\n     SDK, be sure it has been installed.\r\n   ```\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:38:47.788+0000",
                    "updated": "2018-11-28T17:38:47.788+0000",
                    "started": "2018-11-28T17:38:47.787+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170338",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170341",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442539362\n \n \n   It failed downloading it from conda-forge:\r\n   https://ci.appveyor.com/project/ApacheSoftwareFoundation/arrow/builds/20621397/job/ktkt3i9iqfjrckl9#L393\r\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:45:23.993+0000",
                    "updated": "2018-11-28T17:45:23.993+0000",
                    "started": "2018-11-28T17:45:23.993+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170341",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170342",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442539730\n \n \n   > +1, except from a directory listing point of view should we use \"array-binary-test.cc\" instead of \"binary-array-test.cc\"?\r\n   \r\n   That was my intuition as well, but I thought it might sound weird for english speakers?\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-28T17:46:31.419+0000",
                    "updated": "2018-11-28T17:46:31.419+0000",
                    "started": "2018-11-28T17:46:31.418+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170342",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170530",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442685192\n \n \n   Using `array-X-test.cc` sounds good to me. The \"array-\" bit is more of a \"namespace\" than anything, and helps keep the files organized to the eye\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-29T02:40:16.335+0000",
                    "updated": "2018-11-29T02:40:16.335+0000",
                    "started": "2018-11-29T02:40:16.334+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170530",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170667",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "codecov-io commented on issue #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047#issuecomment-442857446\n \n \n   # [Codecov](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=h1) Report\n   > Merging [#3047](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=desc) into [master](https://codecov.io/gh/apache/arrow/commit/780068478a4a3486d878b4849067f56d1ac46f4c?src=pr&el=desc) will **increase** coverage by `20.73%`.\n   > The diff coverage is `100%`.\n   \n   [![Impacted file tree graph](https://codecov.io/gh/apache/arrow/pull/3047/graphs/tree.svg?width=650&token=LpTCFbqVT1&height=150&src=pr)](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=tree)\n   \n   ```diff\n   @@             Coverage Diff             @@\n   ##           master    #3047       +/-   ##\n   ===========================================\n   + Coverage   67.32%   88.06%   +20.73%     \n   ===========================================\n     Files          58      429      +371     \n     Lines        3718    64892    +61174     \n   ===========================================\n   + Hits         2503    57144    +54641     \n   - Misses       1114     7748     +6634     \n   + Partials      101        0      -101\n   ```\n   \n   \n   | [Impacted Files](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=tree) | Coverage \u0394 | |\n   |---|---|---|\n   | [cpp/src/arrow/array-test.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS10ZXN0LmNj) | `100% <\u00f8> (\u00f8)` | |\n   | [cpp/src/arrow/array-dict-test.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS1kaWN0LXRlc3QuY2M=) | `100% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/array-struct-test.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS1zdHJ1Y3QtdGVzdC5jYw==) | `100% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/test-util.h](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90ZXN0LXV0aWwuaA==) | `98.05% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/array-binary-test.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS1iaW5hcnktdGVzdC5jYw==) | `100% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/test-common.h](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90ZXN0LWNvbW1vbi5o) | `100% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/array-list-test.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy9hcnJheS1saXN0LXRlc3QuY2M=) | `100% <100%> (\u00f8)` | |\n   | [cpp/src/arrow/test-util.cc](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Y3BwL3NyYy9hcnJvdy90ZXN0LXV0aWwuY2M=) | `59.49% <100%> (\u00f8)` | |\n   | [go/arrow/array/table.go](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Z28vYXJyb3cvYXJyYXkvdGFibGUuZ28=) | | |\n   | [go/arrow/math/uint64\\_amd64.go](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree#diff-Z28vYXJyb3cvbWF0aC91aW50NjRfYW1kNjQuZ28=) | | |\n   | ... and [485 more](https://codecov.io/gh/apache/arrow/pull/3047/diff?src=pr&el=tree-more) | |\n   \n   ------\n   \n   [Continue to review full report at Codecov](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=continue).\n   > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta)\n   > `\u0394 = absolute <relative> (impact)`, `\u00f8 = not affected`, `? = missing data`\n   > Powered by [Codecov](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=footer). Last update [7800684...f3cb919](https://codecov.io/gh/apache/arrow/pull/3047?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).\n   \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-29T14:41:18.486+0000",
                    "updated": "2018-11-29T14:41:18.486+0000",
                    "started": "2018-11-29T14:41:18.485+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170667",
                    "issueId": "13182901"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/worklog/170675",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #3047: ARROW-3169: [C++] Break up array-test into multiple compilation units\nURL: https://github.com/apache/arrow/pull/3047\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/cmake_modules/BuildUtils.cmake b/cpp/cmake_modules/BuildUtils.cmake\nindex 57cac82777..fb646dd6c1 100644\n--- a/cpp/cmake_modules/BuildUtils.cmake\n+++ b/cpp/cmake_modules/BuildUtils.cmake\n@@ -360,6 +360,9 @@ endfunction()\n # net/net_util-test). Either way, the last component must be a globally\n # unique name.\n #\n+# If given, SOURCES is the list of C++ source files to compile into the test\n+# executable.  Otherwise, \"REL_TEST_NAME.cc\" is used.\n+#\n # The unit test is added with a label of \"unittest\" to support filtering with\n # ctest.\n #\n@@ -376,8 +379,8 @@ endfunction()\n function(ADD_ARROW_TEST REL_TEST_NAME)\n   set(options NO_VALGRIND)\n   set(one_value_args)\n-  set(multi_value_args STATIC_LINK_LIBS EXTRA_LINK_LIBS EXTRA_INCLUDES EXTRA_DEPENDENCIES\n-    LABELS PREFIX)\n+  set(multi_value_args SOURCES STATIC_LINK_LIBS EXTRA_LINK_LIBS EXTRA_INCLUDES\n+      EXTRA_DEPENDENCIES LABELS PREFIX)\n   cmake_parse_arguments(ARG \"${options}\" \"${one_value_args}\" \"${multi_value_args}\" ${ARGN})\n   if(ARG_UNPARSED_ARGUMENTS)\n     message(SEND_ERROR \"Error: unrecognized arguments: ${ARG_UNPARSED_ARGUMENTS}\")\n@@ -410,40 +413,40 @@ function(ADD_ARROW_TEST REL_TEST_NAME)\n     set(ARG_LABELS unittest)\n   endif()\n \n-  if(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/${REL_TEST_NAME}.cc)\n-    # This test has a corresponding .cc file, set it up as an executable.\n-    set(TEST_PATH \"${EXECUTABLE_OUTPUT_PATH}/${TEST_NAME}\")\n-    add_executable(${TEST_NAME} \"${REL_TEST_NAME}.cc\")\n+  if (ARG_SOURCES)\n+    set(SOURCES ${ARG_SOURCES})\n+  else()\n+    set(SOURCES \"${REL_TEST_NAME}.cc\")\n+  endif()\n \n-    if (ARG_STATIC_LINK_LIBS)\n-      # Customize link libraries\n-      target_link_libraries(${TEST_NAME} ${ARG_STATIC_LINK_LIBS})\n-    else()\n-      target_link_libraries(${TEST_NAME} ${ARROW_TEST_LINK_LIBS})\n-    endif()\n+  set(TEST_PATH \"${EXECUTABLE_OUTPUT_PATH}/${TEST_NAME}\")\n+  add_executable(${TEST_NAME} ${SOURCES})\n \n-    if (ARG_EXTRA_LINK_LIBS)\n-      target_link_libraries(${TEST_NAME} ${ARG_EXTRA_LINK_LIBS})\n-    endif()\n+  if (ARG_STATIC_LINK_LIBS)\n+    # Customize link libraries\n+    target_link_libraries(${TEST_NAME} ${ARG_STATIC_LINK_LIBS})\n+  else()\n+    target_link_libraries(${TEST_NAME} ${ARROW_TEST_LINK_LIBS})\n+  endif()\n \n-    if (ARG_EXTRA_INCLUDES)\n-      target_include_directories(${TEST_NAME} SYSTEM PUBLIC\n-        ${ARG_EXTRA_INCLUDES}\n-        )\n-    endif()\n+  if (ARG_EXTRA_LINK_LIBS)\n+    target_link_libraries(${TEST_NAME} ${ARG_EXTRA_LINK_LIBS})\n+  endif()\n \n-    if (ARG_EXTRA_DEPENDENCIES)\n-      add_dependencies(${TEST_NAME} ${ARG_EXTRA_DEPENDENCIES})\n-    endif()\n+  if (ARG_EXTRA_INCLUDES)\n+    target_include_directories(${TEST_NAME} SYSTEM PUBLIC\n+      ${ARG_EXTRA_INCLUDES}\n+      )\n+  endif()\n \n-    foreach (TEST_LABEL ${ARG_LABELS})\n-      add_dependencies(${TEST_LABEL} ${TEST_NAME})\n-    endforeach()\n-  else()\n-    # No executable, just invoke the test (probably a script) directly.\n-    set(TEST_PATH ${CMAKE_CURRENT_SOURCE_DIR}/${REL_TEST_NAME})\n+  if (ARG_EXTRA_DEPENDENCIES)\n+    add_dependencies(${TEST_NAME} ${ARG_EXTRA_DEPENDENCIES})\n   endif()\n \n+  foreach (TEST_LABEL ${ARG_LABELS})\n+    add_dependencies(${TEST_LABEL} ${TEST_NAME})\n+  endforeach()\n+\n   if (ARROW_TEST_MEMCHECK AND NOT ARG_NO_VALGRIND)\n     SET_PROPERTY(TARGET ${TEST_NAME}\n       APPEND_STRING PROPERTY\ndiff --git a/cpp/src/arrow/CMakeLists.txt b/cpp/src/arrow/CMakeLists.txt\nindex 4b5db0a67d..8ff17a279c 100644\n--- a/cpp/src/arrow/CMakeLists.txt\n+++ b/cpp/src/arrow/CMakeLists.txt\n@@ -238,7 +238,9 @@ install(\n #######################################\n \n ADD_ARROW_TEST(allocator-test)\n-ADD_ARROW_TEST(array-test)\n+ADD_ARROW_TEST(array-test\n+  SOURCES array-test.cc array-binary-test.cc array-dict-test.cc\n+          array-list-test.cc array-struct-test.cc)\n ADD_ARROW_TEST(buffer-test)\n ADD_ARROW_TEST(memory_pool-test)\n ADD_ARROW_TEST(pretty_print-test)\ndiff --git a/cpp/src/arrow/array-binary-test.cc b/cpp/src/arrow/array-binary-test.cc\nnew file mode 100644\nindex 0000000000..4376695c68\n--- /dev/null\n+++ b/cpp/src/arrow/array-binary-test.cc\n@@ -0,0 +1,679 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <cstring>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+using std::string;\n+using std::vector;\n+\n+using internal::checked_cast;\n+\n+// ----------------------------------------------------------------------\n+// String / Binary tests\n+\n+class TestStringArray : public ::testing::Test {\n+ public:\n+  void SetUp() {\n+    chars_ = {'a', 'b', 'b', 'c', 'c', 'c'};\n+    offsets_ = {0, 1, 1, 1, 3, 6};\n+    valid_bytes_ = {1, 1, 0, 1, 1};\n+    expected_ = {\"a\", \"\", \"\", \"bb\", \"ccc\"};\n+\n+    MakeArray();\n+  }\n+\n+  void MakeArray() {\n+    length_ = static_cast<int64_t>(offsets_.size()) - 1;\n+    value_buf_ = Buffer::Wrap(chars_);\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+    ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n+    null_count_ = CountNulls(valid_bytes_);\n+\n+    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+                                             null_bitmap_, null_count_);\n+  }\n+\n+ protected:\n+  vector<int32_t> offsets_;\n+  vector<char> chars_;\n+  vector<uint8_t> valid_bytes_;\n+\n+  vector<string> expected_;\n+\n+  std::shared_ptr<Buffer> value_buf_;\n+  std::shared_ptr<Buffer> offsets_buf_;\n+  std::shared_ptr<Buffer> null_bitmap_;\n+\n+  int64_t null_count_;\n+  int64_t length_;\n+\n+  std::shared_ptr<StringArray> strings_;\n+};\n+\n+TEST_F(TestStringArray, TestArrayBasics) {\n+  ASSERT_EQ(length_, strings_->length());\n+  ASSERT_EQ(1, strings_->null_count());\n+  ASSERT_OK(ValidateArray(*strings_));\n+}\n+\n+TEST_F(TestStringArray, TestType) {\n+  std::shared_ptr<DataType> type = strings_->type();\n+\n+  ASSERT_EQ(Type::STRING, type->id());\n+  ASSERT_EQ(Type::STRING, strings_->type_id());\n+}\n+\n+TEST_F(TestStringArray, TestListFunctions) {\n+  int pos = 0;\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    ASSERT_EQ(pos, strings_->value_offset(i));\n+    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n+    pos += static_cast<int>(expected_[i].size());\n+  }\n+}\n+\n+TEST_F(TestStringArray, TestDestructor) {\n+  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n+}\n+\n+TEST_F(TestStringArray, TestGetString) {\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    if (valid_bytes_[i] == 0) {\n+      ASSERT_TRUE(strings_->IsNull(i));\n+    } else {\n+      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+    }\n+  }\n+}\n+\n+TEST_F(TestStringArray, TestEmptyStringComparison) {\n+  offsets_ = {0, 0, 0, 0, 0, 0};\n+  offsets_buf_ = Buffer::Wrap(offsets_);\n+  length_ = static_cast<int64_t>(offsets_.size() - 1);\n+\n+  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n+                                                 null_bitmap_, null_count_);\n+  ASSERT_TRUE(strings_a->Equals(strings_b));\n+}\n+\n+TEST_F(TestStringArray, CompareNullByteSlots) {\n+  StringBuilder builder;\n+  StringBuilder builder2;\n+  StringBuilder builder3;\n+\n+  ASSERT_OK(builder.Append(\"foo\"));\n+  ASSERT_OK(builder2.Append(\"foo\"));\n+  ASSERT_OK(builder3.Append(\"foo\"));\n+\n+  ASSERT_OK(builder.Append(\"bar\"));\n+  ASSERT_OK(builder2.AppendNull());\n+\n+  // same length, but different\n+  ASSERT_OK(builder3.Append(\"xyz\"));\n+\n+  ASSERT_OK(builder.Append(\"baz\"));\n+  ASSERT_OK(builder2.Append(\"baz\"));\n+  ASSERT_OK(builder3.Append(\"baz\"));\n+\n+  std::shared_ptr<Array> array, array2, array3;\n+  FinishAndCheckPadding(&builder, &array);\n+  ASSERT_OK(builder2.Finish(&array2));\n+  ASSERT_OK(builder3.Finish(&array3));\n+\n+  const auto& a1 = checked_cast<const StringArray&>(*array);\n+  const auto& a2 = checked_cast<const StringArray&>(*array2);\n+  const auto& a3 = checked_cast<const StringArray&>(*array3);\n+\n+  // The validity bitmaps are the same, the data is different, but the unequal\n+  // portion is masked out\n+  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n+  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n+\n+  ASSERT_TRUE(equal_array.Equals(equal_array2));\n+  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n+\n+  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n+  ASSERT_TRUE(\n+      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n+}\n+\n+TEST_F(TestStringArray, TestSliceGetString) {\n+  StringBuilder builder;\n+\n+  ASSERT_OK(builder.Append(\"a\"));\n+  ASSERT_OK(builder.Append(\"b\"));\n+  ASSERT_OK(builder.Append(\"c\"));\n+\n+  std::shared_ptr<Array> array;\n+  ASSERT_OK(builder.Finish(&array));\n+  auto s = array->Slice(1, 10);\n+  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n+  ASSERT_EQ(arr->GetString(0), \"b\");\n+}\n+\n+// ----------------------------------------------------------------------\n+// String builder tests\n+\n+class TestStringBuilder : public TestBuilder {\n+ public:\n+  void SetUp() {\n+    TestBuilder::SetUp();\n+    builder_.reset(new StringBuilder(pool_));\n+  }\n+\n+  void Done() {\n+    std::shared_ptr<Array> out;\n+    FinishAndCheckPadding(builder_.get(), &out);\n+\n+    result_ = std::dynamic_pointer_cast<StringArray>(out);\n+    ASSERT_OK(ValidateArray(*result_));\n+  }\n+\n+ protected:\n+  std::unique_ptr<StringBuilder> builder_;\n+  std::shared_ptr<StringArray> result_;\n+};\n+\n+TEST_F(TestStringBuilder, TestScalarAppend) {\n+  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n+  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n+\n+  int N = static_cast<int>(strings.size());\n+  int reps = 1000;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    for (int i = 0; i < N; ++i) {\n+      if (is_null[i]) {\n+        ASSERT_OK(builder_->AppendNull());\n+      } else {\n+        ASSERT_OK(builder_->Append(strings[i]));\n+      }\n+    }\n+  }\n+  Done();\n+\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps, result_->null_count());\n+  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+\n+  int32_t length;\n+  int32_t pos = 0;\n+  for (int i = 0; i < N * reps; ++i) {\n+    if (is_null[i % N]) {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    } else {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      result_->GetValue(i, &length);\n+      ASSERT_EQ(pos, result_->value_offset(i));\n+      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n+      ASSERT_EQ(strings[i % N], result_->GetString(i));\n+\n+      pos += length;\n+    }\n+  }\n+}\n+\n+TEST_F(TestStringBuilder, TestAppendVector) {\n+  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n+  vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n+\n+  int N = static_cast<int>(strings.size());\n+  int reps = 1000;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n+  }\n+  Done();\n+\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps, result_->null_count());\n+  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+\n+  int32_t length;\n+  int32_t pos = 0;\n+  for (int i = 0; i < N * reps; ++i) {\n+    if (valid_bytes[i % N]) {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      result_->GetValue(i, &length);\n+      ASSERT_EQ(pos, result_->value_offset(i));\n+      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n+      ASSERT_EQ(strings[i % N], result_->GetString(i));\n+\n+      pos += length;\n+    } else {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    }\n+  }\n+}\n+\n+TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n+  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n+  vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n+\n+  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n+  int reps = 1000;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n+  }\n+  Done();\n+\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps * 3, result_->null_count());\n+  ASSERT_EQ(reps * 3, result_->value_data()->size());\n+\n+  int32_t length;\n+  int32_t pos = 0;\n+  for (int i = 0; i < N * reps; ++i) {\n+    auto string = strings[i % N];\n+    if (string && valid_bytes[i % N]) {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      result_->GetValue(i, &length);\n+      ASSERT_EQ(pos, result_->value_offset(i));\n+      ASSERT_EQ(static_cast<int32_t>(strlen(string)), length);\n+      ASSERT_EQ(strings[i % N], result_->GetString(i));\n+\n+      pos += length;\n+    } else {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    }\n+  }\n+}\n+\n+TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n+  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+\n+  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n+  int reps = 1000;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    ASSERT_OK(builder_->AppendValues(strings, N));\n+  }\n+  Done();\n+\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps, result_->null_count());\n+  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+\n+  int32_t length;\n+  int32_t pos = 0;\n+  for (int i = 0; i < N * reps; ++i) {\n+    if (strings[i % N]) {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      result_->GetValue(i, &length);\n+      ASSERT_EQ(pos, result_->value_offset(i));\n+      ASSERT_EQ(static_cast<int32_t>(strlen(strings[i % N])), length);\n+      ASSERT_EQ(strings[i % N], result_->GetString(i));\n+\n+      pos += length;\n+    } else {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    }\n+  }\n+}\n+\n+TEST_F(TestStringBuilder, TestZeroLength) {\n+  // All buffers are null\n+  Done();\n+}\n+\n+// Binary container type\n+// TODO(emkornfield) there should be some way to refactor these to avoid code duplicating\n+// with String\n+class TestBinaryArray : public ::testing::Test {\n+ public:\n+  void SetUp() {\n+    chars_ = {'a', 'b', 'b', 'c', 'c', 'c'};\n+    offsets_ = {0, 1, 1, 1, 3, 6};\n+    valid_bytes_ = {1, 1, 0, 1, 1};\n+    expected_ = {\"a\", \"\", \"\", \"bb\", \"ccc\"};\n+\n+    MakeArray();\n+  }\n+\n+  void MakeArray() {\n+    length_ = static_cast<int64_t>(offsets_.size() - 1);\n+    value_buf_ = Buffer::Wrap(chars_);\n+    offsets_buf_ = Buffer::Wrap(offsets_);\n+\n+    ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n+    null_count_ = CountNulls(valid_bytes_);\n+\n+    strings_ = std::make_shared<BinaryArray>(length_, offsets_buf_, value_buf_,\n+                                             null_bitmap_, null_count_);\n+  }\n+\n+ protected:\n+  vector<int32_t> offsets_;\n+  vector<char> chars_;\n+  vector<uint8_t> valid_bytes_;\n+\n+  vector<string> expected_;\n+\n+  std::shared_ptr<Buffer> value_buf_;\n+  std::shared_ptr<Buffer> offsets_buf_;\n+  std::shared_ptr<Buffer> null_bitmap_;\n+\n+  int64_t null_count_;\n+  int64_t length_;\n+\n+  std::shared_ptr<BinaryArray> strings_;\n+};\n+\n+TEST_F(TestBinaryArray, TestArrayBasics) {\n+  ASSERT_EQ(length_, strings_->length());\n+  ASSERT_EQ(1, strings_->null_count());\n+  ASSERT_OK(ValidateArray(*strings_));\n+}\n+\n+TEST_F(TestBinaryArray, TestType) {\n+  std::shared_ptr<DataType> type = strings_->type();\n+\n+  ASSERT_EQ(Type::BINARY, type->id());\n+  ASSERT_EQ(Type::BINARY, strings_->type_id());\n+}\n+\n+TEST_F(TestBinaryArray, TestListFunctions) {\n+  size_t pos = 0;\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    ASSERT_EQ(pos, strings_->value_offset(i));\n+    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n+    pos += expected_[i].size();\n+  }\n+}\n+\n+TEST_F(TestBinaryArray, TestDestructor) {\n+  auto arr = std::make_shared<BinaryArray>(length_, offsets_buf_, value_buf_,\n+                                           null_bitmap_, null_count_);\n+}\n+\n+TEST_F(TestBinaryArray, TestGetValue) {\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    if (valid_bytes_[i] == 0) {\n+      ASSERT_TRUE(strings_->IsNull(i));\n+    } else {\n+      ASSERT_FALSE(strings_->IsNull(i));\n+      ASSERT_EQ(strings_->GetString(i), expected_[i]);\n+    }\n+  }\n+}\n+\n+TEST_F(TestBinaryArray, TestNullValuesInitialized) {\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    if (valid_bytes_[i] == 0) {\n+      ASSERT_TRUE(strings_->IsNull(i));\n+    } else {\n+      ASSERT_FALSE(strings_->IsNull(i));\n+      ASSERT_EQ(strings_->GetString(i), expected_[i]);\n+    }\n+  }\n+  TestInitialized(*strings_);\n+}\n+\n+TEST_F(TestBinaryArray, TestPaddingZeroed) { AssertZeroPadded(*strings_); }\n+\n+TEST_F(TestBinaryArray, TestGetString) {\n+  for (size_t i = 0; i < expected_.size(); ++i) {\n+    if (valid_bytes_[i] == 0) {\n+      ASSERT_TRUE(strings_->IsNull(i));\n+    } else {\n+      std::string val = strings_->GetString(i);\n+      ASSERT_EQ(0, std::memcmp(expected_[i].data(), val.c_str(), val.size()));\n+    }\n+  }\n+}\n+\n+TEST_F(TestBinaryArray, TestEqualsEmptyStrings) {\n+  BinaryBuilder builder;\n+\n+  string empty_string(\"\");\n+  for (int i = 0; i < 5; ++i) {\n+    ASSERT_OK(builder.Append(empty_string));\n+  }\n+\n+  std::shared_ptr<Array> left_arr;\n+  FinishAndCheckPadding(&builder, &left_arr);\n+\n+  const BinaryArray& left = checked_cast<const BinaryArray&>(*left_arr);\n+  std::shared_ptr<Array> right =\n+      std::make_shared<BinaryArray>(left.length(), left.value_offsets(), nullptr,\n+                                    left.null_bitmap(), left.null_count());\n+\n+  ASSERT_TRUE(left.Equals(right));\n+  ASSERT_TRUE(left.RangeEquals(0, left.length(), 0, right));\n+}\n+\n+class TestBinaryBuilder : public TestBuilder {\n+ public:\n+  void SetUp() {\n+    TestBuilder::SetUp();\n+    builder_.reset(new BinaryBuilder(pool_));\n+  }\n+\n+  void Done() {\n+    std::shared_ptr<Array> out;\n+    FinishAndCheckPadding(builder_.get(), &out);\n+\n+    result_ = std::dynamic_pointer_cast<BinaryArray>(out);\n+    ASSERT_OK(ValidateArray(*result_));\n+  }\n+\n+ protected:\n+  std::unique_ptr<BinaryBuilder> builder_;\n+  std::shared_ptr<BinaryArray> result_;\n+};\n+\n+TEST_F(TestBinaryBuilder, TestScalarAppend) {\n+  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n+  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n+\n+  int N = static_cast<int>(strings.size());\n+  int reps = 10;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    for (int i = 0; i < N; ++i) {\n+      if (is_null[i]) {\n+        ASSERT_OK(builder_->AppendNull());\n+      } else {\n+        ASSERT_OK(builder_->Append(strings[i]));\n+      }\n+    }\n+  }\n+  Done();\n+  ASSERT_OK(ValidateArray(*result_));\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps, result_->null_count());\n+  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+\n+  int32_t length;\n+  for (int i = 0; i < N * reps; ++i) {\n+    if (is_null[i % N]) {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    } else {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      const uint8_t* vals = result_->GetValue(i, &length);\n+      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n+      ASSERT_EQ(0, std::memcmp(vals, strings[i % N].data(), length));\n+    }\n+  }\n+}\n+\n+TEST_F(TestBinaryBuilder, TestScalarAppendUnsafe) {\n+  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n+  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n+\n+  int N = static_cast<int>(strings.size());\n+  int reps = 13;\n+  int total_length = 0;\n+  for (auto&& s : strings) total_length += static_cast<int>(s.size());\n+\n+  ASSERT_OK(builder_->Reserve(N * reps));\n+  ASSERT_OK(builder_->ReserveData(total_length * reps));\n+\n+  for (int j = 0; j < reps; ++j) {\n+    for (int i = 0; i < N; ++i) {\n+      if (is_null[i]) {\n+        builder_->UnsafeAppendNull();\n+      } else {\n+        builder_->UnsafeAppend(strings[i]);\n+      }\n+    }\n+  }\n+  ASSERT_EQ(builder_->value_data_length(), total_length * reps);\n+  Done();\n+  ASSERT_OK(ValidateArray(*result_));\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(reps, result_->null_count());\n+  ASSERT_EQ(reps * total_length, result_->value_data()->size());\n+\n+  int32_t length;\n+  for (int i = 0; i < N * reps; ++i) {\n+    if (is_null[i % N]) {\n+      ASSERT_TRUE(result_->IsNull(i));\n+    } else {\n+      ASSERT_FALSE(result_->IsNull(i));\n+      const uint8_t* vals = result_->GetValue(i, &length);\n+      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n+      ASSERT_EQ(0, std::memcmp(vals, strings[i % N].data(), length));\n+    }\n+  }\n+}\n+\n+TEST_F(TestBinaryBuilder, TestCapacityReserve) {\n+  vector<string> strings = {\"aaaaa\", \"bbbbbbbbbb\", \"ccccccccccccccc\", \"dddddddddd\"};\n+  int N = static_cast<int>(strings.size());\n+  int reps = 15;\n+  int64_t length = 0;\n+  int64_t capacity = 1000;\n+  int64_t expected_capacity = BitUtil::RoundUpToMultipleOf64(capacity);\n+\n+  ASSERT_OK(builder_->ReserveData(capacity));\n+\n+  ASSERT_EQ(length, builder_->value_data_length());\n+  ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n+\n+  for (int j = 0; j < reps; ++j) {\n+    for (int i = 0; i < N; ++i) {\n+      ASSERT_OK(builder_->Append(strings[i]));\n+      length += static_cast<int>(strings[i].size());\n+\n+      ASSERT_EQ(length, builder_->value_data_length());\n+      ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n+    }\n+  }\n+\n+  int extra_capacity = 500;\n+  expected_capacity = BitUtil::RoundUpToMultipleOf64(length + extra_capacity);\n+\n+  ASSERT_OK(builder_->ReserveData(extra_capacity));\n+\n+  ASSERT_EQ(length, builder_->value_data_length());\n+  ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n+\n+  Done();\n+\n+  ASSERT_EQ(reps * N, result_->length());\n+  ASSERT_EQ(0, result_->null_count());\n+  ASSERT_EQ(reps * 40, result_->value_data()->size());\n+\n+  // Capacity is shrunk after `Finish`\n+  ASSERT_EQ(640, result_->value_data()->capacity());\n+}\n+\n+TEST_F(TestBinaryBuilder, TestZeroLength) {\n+  // All buffers are null\n+  Done();\n+}\n+\n+// ----------------------------------------------------------------------\n+// Slice tests\n+\n+template <typename TYPE>\n+void CheckSliceEquality() {\n+  using Traits = TypeTraits<TYPE>;\n+  using BuilderType = typename Traits::BuilderType;\n+\n+  BuilderType builder;\n+\n+  vector<string> strings = {\"foo\", \"\", \"bar\", \"baz\", \"qux\", \"\"};\n+  vector<uint8_t> is_null = {0, 1, 0, 1, 0, 0};\n+\n+  int N = static_cast<int>(strings.size());\n+  int reps = 10;\n+\n+  for (int j = 0; j < reps; ++j) {\n+    for (int i = 0; i < N; ++i) {\n+      if (is_null[i]) {\n+        ASSERT_OK(builder.AppendNull());\n+      } else {\n+        ASSERT_OK(builder.Append(strings[i]));\n+      }\n+    }\n+  }\n+\n+  std::shared_ptr<Array> array;\n+  FinishAndCheckPadding(&builder, &array);\n+\n+  std::shared_ptr<Array> slice, slice2;\n+\n+  slice = array->Slice(5);\n+  slice2 = array->Slice(5);\n+  ASSERT_EQ(N * reps - 5, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(5, slice->length(), 0, slice));\n+\n+  // Chained slices\n+  slice2 = array->Slice(2)->Slice(3);\n+  ASSERT_TRUE(slice->Equals(slice2));\n+\n+  slice = array->Slice(5, 20);\n+  slice2 = array->Slice(5, 20);\n+  ASSERT_EQ(20, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(5, 25, 0, slice));\n+}\n+\n+TEST_F(TestBinaryArray, TestSliceEquality) { CheckSliceEquality<BinaryType>(); }\n+\n+TEST_F(TestStringArray, TestSliceEquality) { CheckSliceEquality<BinaryType>(); }\n+\n+TEST_F(TestBinaryArray, LengthZeroCtor) { BinaryArray array(0, nullptr, nullptr); }\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/array-dict-test.cc b/cpp/src/arrow/array-dict-test.cc\nnew file mode 100644\nindex 0000000000..4c8dcc067b\n--- /dev/null\n+++ b/cpp/src/arrow/array-dict-test.cc\n@@ -0,0 +1,890 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <cstring>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+using std::string;\n+using std::vector;\n+\n+// ----------------------------------------------------------------------\n+// Dictionary tests\n+\n+template <typename Type>\n+class TestDictionaryBuilder : public TestBuilder {};\n+\n+typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n+                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType>\n+    PrimitiveDictionaries;\n+\n+TYPED_TEST_CASE(TestDictionaryBuilder, PrimitiveDictionaries);\n+\n+TYPED_TEST(TestDictionaryBuilder, Basic) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  NumericBuilder<TypeParam> dict_builder;\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array;\n+  ASSERT_OK(dict_builder.Finish(&dict_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, ArrayConversion) {\n+  NumericBuilder<TypeParam> builder;\n+  // DictionaryBuilder<TypeParam> builder;\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+\n+  std::shared_ptr<Array> intermediate_result;\n+  ASSERT_OK(builder.Finish(&intermediate_result));\n+  DictionaryBuilder<TypeParam> dictionary_builder(default_memory_pool());\n+  ASSERT_OK(dictionary_builder.AppendArray(*intermediate_result));\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(dictionary_builder.Finish(&result));\n+\n+  // Build expected data\n+  NumericBuilder<TypeParam> dict_builder;\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array;\n+  ASSERT_OK(dict_builder.Finish(&dict_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, DoubleTableSize) {\n+  using Scalar = typename TypeParam::c_type;\n+  // Skip this test for (u)int8\n+  if (sizeof(Scalar) > 1) {\n+    // Build the dictionary Array\n+    DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+    // Build expected data\n+    NumericBuilder<TypeParam> dict_builder;\n+    Int16Builder int_builder;\n+\n+    // Fill with 1024 different values\n+    for (int64_t i = 0; i < 1024; i++) {\n+      ASSERT_OK(builder.Append(static_cast<Scalar>(i)));\n+      ASSERT_OK(dict_builder.Append(static_cast<Scalar>(i)));\n+      ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+    }\n+    // Fill with an already existing value\n+    for (int64_t i = 0; i < 1024; i++) {\n+      ASSERT_OK(builder.Append(static_cast<Scalar>(1)));\n+      ASSERT_OK(int_builder.Append(1));\n+    }\n+\n+    // Finalize result\n+    std::shared_ptr<Array> result;\n+    FinishAndCheckPadding(&builder, &result);\n+\n+    // Finalize expected data\n+    std::shared_ptr<Array> dict_array;\n+    ASSERT_OK(dict_builder.Finish(&dict_array));\n+    auto dtype = std::make_shared<DictionaryType>(int16(), dict_array);\n+    std::shared_ptr<Array> int_array;\n+    ASSERT_OK(int_builder.Finish(&int_array));\n+\n+    DictionaryArray expected(dtype, int_array);\n+    ASSERT_TRUE(expected.Equals(result));\n+  }\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, DeltaDictionary) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> result;\n+  FinishAndCheckPadding(&builder, &result);\n+\n+  // Build expected data for the initial dictionary\n+  NumericBuilder<TypeParam> dict_builder1;\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array1;\n+  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // extend the dictionary builder with new data\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+\n+  std::shared_ptr<Array> result_delta;\n+  ASSERT_OK(builder.Finish(&result_delta));\n+\n+  // Build expected data for the delta dictionary\n+  NumericBuilder<TypeParam> dict_builder2;\n+  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n+  std::shared_ptr<Array> dict_array2;\n+  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta.Equals(result_delta));\n+}\n+\n+TYPED_TEST(TestDictionaryBuilder, DoubleDeltaDictionary) {\n+  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n+\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> result;\n+  FinishAndCheckPadding(&builder, &result);\n+\n+  // Build expected data for the initial dictionary\n+  NumericBuilder<TypeParam> dict_builder1;\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n+  std::shared_ptr<Array> dict_array1;\n+  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // extend the dictionary builder with new data\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+\n+  std::shared_ptr<Array> result_delta1;\n+  ASSERT_OK(builder.Finish(&result_delta1));\n+\n+  // Build expected data for the delta dictionary\n+  NumericBuilder<TypeParam> dict_builder2;\n+  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n+  std::shared_ptr<Array> dict_array2;\n+  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta1(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta1.Equals(result_delta1));\n+\n+  // extend the dictionary builder with new data again\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(4)));\n+  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(5)));\n+\n+  std::shared_ptr<Array> result_delta2;\n+  ASSERT_OK(builder.Finish(&result_delta2));\n+\n+  // Build expected data for the delta dictionary again\n+  NumericBuilder<TypeParam> dict_builder3;\n+  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(4)));\n+  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(5)));\n+  std::shared_ptr<Array> dict_array3;\n+  ASSERT_OK(dict_builder3.Finish(&dict_array3));\n+  auto dtype3 = std::make_shared<DictionaryType>(int8(), dict_array3);\n+\n+  Int8Builder int_builder3;\n+  ASSERT_OK(int_builder3.Append(0));\n+  ASSERT_OK(int_builder3.Append(1));\n+  ASSERT_OK(int_builder3.Append(2));\n+  ASSERT_OK(int_builder3.Append(3));\n+  ASSERT_OK(int_builder3.Append(4));\n+  std::shared_ptr<Array> int_array3;\n+  ASSERT_OK(int_builder3.Finish(&int_array3));\n+\n+  DictionaryArray expected_delta2(dtype3, int_array3);\n+  ASSERT_TRUE(expected_delta2.Equals(result_delta2));\n+}\n+\n+TEST(TestStringDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(\"test\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test\"));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  StringBuilder str_builder;\n+  ASSERT_OK(str_builder.Append(\"test\"));\n+  ASSERT_OK(str_builder.Append(\"test2\"));\n+  std::shared_ptr<Array> str_array;\n+  ASSERT_OK(str_builder.Finish(&str_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), str_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestStringDictionaryBuilder, DoubleTableSize) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  // Build expected data\n+  StringBuilder str_builder;\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    std::stringstream ss;\n+    ss << \"test\" << i;\n+    ASSERT_OK(builder.Append(ss.str()));\n+    ASSERT_OK(str_builder.Append(ss.str()));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(\"test1\"));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  FinishAndCheckPadding(&builder, &result);\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> str_array;\n+  ASSERT_OK(str_builder.Finish(&str_array));\n+  auto dtype = std::make_shared<DictionaryType>(int16(), str_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestStringDictionaryBuilder, DeltaDictionary) {\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+  ASSERT_OK(builder.Append(\"test\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test\"));\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  StringBuilder str_builder1;\n+  ASSERT_OK(str_builder1.Append(\"test\"));\n+  ASSERT_OK(str_builder1.Append(\"test2\"));\n+  std::shared_ptr<Array> str_array1;\n+  ASSERT_OK(str_builder1.Finish(&str_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), str_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // build a delta dictionary\n+  ASSERT_OK(builder.Append(\"test2\"));\n+  ASSERT_OK(builder.Append(\"test3\"));\n+  ASSERT_OK(builder.Append(\"test2\"));\n+\n+  std::shared_ptr<Array> result_delta;\n+  FinishAndCheckPadding(&builder, &result_delta);\n+\n+  // Build expected data\n+  StringBuilder str_builder2;\n+  ASSERT_OK(str_builder2.Append(\"test3\"));\n+  std::shared_ptr<Array> str_array2;\n+  ASSERT_OK(str_builder2.Finish(&str_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), str_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  ASSERT_OK(int_builder2.Append(1));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected_delta(dtype2, int_array2);\n+  ASSERT_TRUE(expected_delta.Equals(result_delta));\n+}\n+\n+TEST(TestStringDictionaryBuilder, BigDeltaDictionary) {\n+  constexpr int16_t kTestLength = 2048;\n+  // Build the dictionary Array\n+  StringDictionaryBuilder builder(default_memory_pool());\n+\n+  StringBuilder str_builder1;\n+  Int16Builder int_builder1;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    std::stringstream sstream;\n+    sstream << \"test\" << idx;\n+    ASSERT_OK(builder.Append(sstream.str()));\n+    ASSERT_OK(str_builder1.Append(sstream.str()));\n+    ASSERT_OK(int_builder1.Append(idx));\n+  }\n+\n+  std::shared_ptr<Array> result;\n+  FinishAndCheckPadding(&builder, &result);\n+\n+  std::shared_ptr<Array> str_array1;\n+  ASSERT_OK(str_builder1.Finish(&str_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int16(), str_array1);\n+\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected(dtype1, int_array1);\n+  ASSERT_TRUE(expected.Equals(result));\n+\n+  // build delta 1\n+  StringBuilder str_builder2;\n+  Int16Builder int_builder2;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test1\"));\n+    ASSERT_OK(int_builder2.Append(1));\n+  }\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test_new_value1\"));\n+    ASSERT_OK(int_builder2.Append(kTestLength));\n+  }\n+  ASSERT_OK(str_builder2.Append(\"test_new_value1\"));\n+\n+  std::shared_ptr<Array> result2;\n+  ASSERT_OK(builder.Finish(&result2));\n+\n+  std::shared_ptr<Array> str_array2;\n+  ASSERT_OK(str_builder2.Finish(&str_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int16(), str_array2);\n+\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected2(dtype2, int_array2);\n+  ASSERT_TRUE(expected2.Equals(result2));\n+\n+  // build delta 2\n+  StringBuilder str_builder3;\n+  Int16Builder int_builder3;\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test2\"));\n+    ASSERT_OK(int_builder3.Append(2));\n+  }\n+\n+  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n+    ASSERT_OK(builder.Append(\"test_new_value2\"));\n+    ASSERT_OK(int_builder3.Append(kTestLength + 1));\n+  }\n+  ASSERT_OK(str_builder3.Append(\"test_new_value2\"));\n+\n+  std::shared_ptr<Array> result3;\n+  ASSERT_OK(builder.Finish(&result3));\n+\n+  std::shared_ptr<Array> str_array3;\n+  ASSERT_OK(str_builder3.Finish(&str_array3));\n+  auto dtype3 = std::make_shared<DictionaryType>(int16(), str_array3);\n+\n+  std::shared_ptr<Array> int_array3;\n+  ASSERT_OK(int_builder3.Finish(&int_array3));\n+\n+  DictionaryArray expected3(dtype3, int_array3);\n+  ASSERT_TRUE(expected3.Equals(result3));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  std::vector<uint8_t> test{12, 12, 11, 12};\n+  std::vector<uint8_t> test2{12, 12, 11, 11};\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test.data()));\n+\n+  std::shared_ptr<Array> result;\n+  FinishAndCheckPadding(&builder, &result);\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder.Append(test.data()));\n+  ASSERT_OK(fsb_builder.Append(test2.data()));\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+  auto dtype = std::make_shared<DictionaryType>(int8(), fsb_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.Append(0));\n+  ASSERT_OK(int_builder.Append(1));\n+  ASSERT_OK(int_builder.Append(0));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, DeltaDictionary) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  std::vector<uint8_t> test{12, 12, 11, 12};\n+  std::vector<uint8_t> test2{12, 12, 11, 11};\n+  std::vector<uint8_t> test3{12, 12, 11, 10};\n+\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test.data()));\n+\n+  std::shared_ptr<Array> result1;\n+  FinishAndCheckPadding(&builder, &result1);\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder1(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder1.Append(test.data()));\n+  ASSERT_OK(fsb_builder1.Append(test2.data()));\n+  std::shared_ptr<Array> fsb_array1;\n+  ASSERT_OK(fsb_builder1.Finish(&fsb_array1));\n+  auto dtype1 = std::make_shared<DictionaryType>(int8(), fsb_array1);\n+\n+  Int8Builder int_builder1;\n+  ASSERT_OK(int_builder1.Append(0));\n+  ASSERT_OK(int_builder1.Append(1));\n+  ASSERT_OK(int_builder1.Append(0));\n+  std::shared_ptr<Array> int_array1;\n+  ASSERT_OK(int_builder1.Finish(&int_array1));\n+\n+  DictionaryArray expected1(dtype1, int_array1);\n+  ASSERT_TRUE(expected1.Equals(result1));\n+\n+  // build delta dictionary\n+  ASSERT_OK(builder.Append(test.data()));\n+  ASSERT_OK(builder.Append(test2.data()));\n+  ASSERT_OK(builder.Append(test3.data()));\n+\n+  std::shared_ptr<Array> result2;\n+  FinishAndCheckPadding(&builder, &result2);\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder2(arrow::fixed_size_binary(4));\n+  ASSERT_OK(fsb_builder2.Append(test3.data()));\n+  std::shared_ptr<Array> fsb_array2;\n+  ASSERT_OK(fsb_builder2.Finish(&fsb_array2));\n+  auto dtype2 = std::make_shared<DictionaryType>(int8(), fsb_array2);\n+\n+  Int8Builder int_builder2;\n+  ASSERT_OK(int_builder2.Append(0));\n+  ASSERT_OK(int_builder2.Append(1));\n+  ASSERT_OK(int_builder2.Append(2));\n+  std::shared_ptr<Array> int_array2;\n+  ASSERT_OK(int_builder2.Finish(&int_array2));\n+\n+  DictionaryArray expected2(dtype2, int_array2);\n+  ASSERT_TRUE(expected2.Equals(result2));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, DoubleTableSize) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    std::vector<uint8_t> value{12, 12, static_cast<uint8_t>(i / 128),\n+                               static_cast<uint8_t>(i % 128)};\n+    ASSERT_OK(builder.Append(value.data()));\n+    ASSERT_OK(fsb_builder.Append(value.data()));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  std::vector<uint8_t> known_value{12, 12, 0, 1};\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(known_value.data()));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestFixedSizeBinaryDictionaryBuilder, InvalidTypeAppend) {\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n+                                                 default_memory_pool());\n+  // Build an array with different byte width\n+  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(5));\n+  std::vector<uint8_t> value{100, 1, 1, 1, 1};\n+  ASSERT_OK(fsb_builder.Append(value.data()));\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+\n+  ASSERT_RAISES(Invalid, builder.AppendArray(*fsb_array));\n+}\n+\n+TEST(TestDecimalDictionaryBuilder, Basic) {\n+  // Build the dictionary Array\n+  const auto& decimal_type = arrow::decimal(2, 0);\n+  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n+\n+  // Test data\n+  std::vector<Decimal128> test{12, 12, 11, 12};\n+  for (const auto& value : test) {\n+    ASSERT_OK(builder.Append(value.ToBytes().data()));\n+  }\n+\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder decimal_builder(decimal_type);\n+  ASSERT_OK(decimal_builder.Append(Decimal128(12).ToBytes()));\n+  ASSERT_OK(decimal_builder.Append(Decimal128(11).ToBytes()));\n+\n+  std::shared_ptr<Array> decimal_array;\n+  ASSERT_OK(decimal_builder.Finish(&decimal_array));\n+  auto dtype = arrow::dictionary(int8(), decimal_array);\n+\n+  Int8Builder int_builder;\n+  ASSERT_OK(int_builder.AppendValues({0, 0, 1, 0}));\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+TEST(TestDecimalDictionaryBuilder, DoubleTableSize) {\n+  const auto& decimal_type = arrow::decimal(21, 0);\n+\n+  // Build the dictionary Array\n+  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n+\n+  // Build expected data\n+  FixedSizeBinaryBuilder fsb_builder(decimal_type);\n+  Int16Builder int_builder;\n+\n+  // Fill with 1024 different values\n+  for (int64_t i = 0; i < 1024; i++) {\n+    const uint8_t bytes[] = {0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             0,\n+                             12,\n+                             12,\n+                             static_cast<uint8_t>(i / 128),\n+                             static_cast<uint8_t>(i % 128)};\n+    ASSERT_OK(builder.Append(bytes));\n+    ASSERT_OK(fsb_builder.Append(bytes));\n+    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n+  }\n+  // Fill with an already existing value\n+  const uint8_t known_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 1};\n+  for (int64_t i = 0; i < 1024; i++) {\n+    ASSERT_OK(builder.Append(known_value));\n+    ASSERT_OK(int_builder.Append(1));\n+  }\n+\n+  // Finalize result\n+  std::shared_ptr<Array> result;\n+  ASSERT_OK(builder.Finish(&result));\n+\n+  // Finalize expected data\n+  std::shared_ptr<Array> fsb_array;\n+  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n+\n+  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n+  std::shared_ptr<Array> int_array;\n+  ASSERT_OK(int_builder.Finish(&int_array));\n+\n+  DictionaryArray expected(dtype, int_array);\n+  ASSERT_TRUE(expected.Equals(result));\n+}\n+\n+// ----------------------------------------------------------------------\n+// DictionaryArray tests\n+\n+TEST(TestDictionary, Basics) {\n+  vector<int32_t> values = {100, 1000, 10000, 100000};\n+  std::shared_ptr<Array> dict;\n+  ArrayFromVector<Int32Type, int32_t>(values, &dict);\n+\n+  std::shared_ptr<DictionaryType> type1 =\n+      std::dynamic_pointer_cast<DictionaryType>(dictionary(int16(), dict));\n+\n+  auto type2 =\n+      std::dynamic_pointer_cast<DictionaryType>(::arrow::dictionary(int16(), dict, true));\n+\n+  ASSERT_TRUE(int16()->Equals(type1->index_type()));\n+  ASSERT_TRUE(type1->dictionary()->Equals(dict));\n+\n+  ASSERT_TRUE(int16()->Equals(type2->index_type()));\n+  ASSERT_TRUE(type2->dictionary()->Equals(dict));\n+\n+  ASSERT_EQ(\"dictionary<values=int32, indices=int16, ordered=0>\", type1->ToString());\n+  ASSERT_EQ(\"dictionary<values=int32, indices=int16, ordered=1>\", type2->ToString());\n+}\n+\n+TEST(TestDictionary, Equals) {\n+  vector<bool> is_valid = {true, true, false, true, true, true};\n+\n+  std::shared_ptr<Array> dict;\n+  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n+  ArrayFromVector<StringType, string>(dict_values, &dict);\n+  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n+\n+  std::shared_ptr<Array> dict2;\n+  vector<string> dict2_values = {\"foo\", \"bar\", \"baz\", \"qux\"};\n+  ArrayFromVector<StringType, string>(dict2_values, &dict2);\n+  std::shared_ptr<DataType> dict2_type = dictionary(int16(), dict2);\n+\n+  std::shared_ptr<Array> indices;\n+  vector<int16_t> indices_values = {1, 2, -1, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid, indices_values, &indices);\n+\n+  std::shared_ptr<Array> indices2;\n+  vector<int16_t> indices2_values = {1, 2, 0, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid, indices2_values, &indices2);\n+\n+  std::shared_ptr<Array> indices3;\n+  vector<int16_t> indices3_values = {1, 1, 0, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid, indices3_values, &indices3);\n+\n+  auto array = std::make_shared<DictionaryArray>(dict_type, indices);\n+  auto array2 = std::make_shared<DictionaryArray>(dict_type, indices2);\n+  auto array3 = std::make_shared<DictionaryArray>(dict2_type, indices);\n+  auto array4 = std::make_shared<DictionaryArray>(dict_type, indices3);\n+\n+  ASSERT_TRUE(array->Equals(array));\n+\n+  // Equal, because the unequal index is masked by null\n+  ASSERT_TRUE(array->Equals(array2));\n+\n+  // Unequal dictionaries\n+  ASSERT_FALSE(array->Equals(array3));\n+\n+  // Unequal indices\n+  ASSERT_FALSE(array->Equals(array4));\n+\n+  // RangeEquals\n+  ASSERT_TRUE(array->RangeEquals(3, 6, 3, array4));\n+  ASSERT_FALSE(array->RangeEquals(1, 3, 1, array4));\n+\n+  // ARROW-33 Test slices\n+  const int64_t size = array->length();\n+\n+  std::shared_ptr<Array> slice, slice2;\n+  slice = array->Array::Slice(2);\n+  slice2 = array->Array::Slice(2);\n+  ASSERT_EQ(size - 2, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(2, array->length(), 0, slice));\n+\n+  // Chained slices\n+  slice2 = array->Array::Slice(1)->Array::Slice(1);\n+  ASSERT_TRUE(slice->Equals(slice2));\n+\n+  slice = array->Slice(1, 3);\n+  slice2 = array->Slice(1, 3);\n+  ASSERT_EQ(3, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(1, 4, 0, slice));\n+}\n+\n+TEST(TestDictionary, Validate) {\n+  vector<bool> is_valid = {true, true, false, true, true, true};\n+\n+  std::shared_ptr<Array> dict;\n+  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n+  ArrayFromVector<StringType, string>(dict_values, &dict);\n+  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n+\n+  std::shared_ptr<Array> indices;\n+  vector<int16_t> indices_values = {1, 2, 0, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid, indices_values, &indices);\n+\n+  std::shared_ptr<Array> arr = std::make_shared<DictionaryArray>(dict_type, indices);\n+\n+  // Only checking index type for now\n+  ASSERT_OK(ValidateArray(*arr));\n+\n+  // TODO(wesm) In ARROW-1199, there is now a DCHECK to compare the indices\n+  // type with the dict_type. How can we test for this?\n+\n+  // std::shared_ptr<Array> indices2;\n+  // vector<float> indices2_values = {1., 2., 0., 0., 2., 0.};\n+  // ArrayFromVector<FloatType, float>(is_valid, indices2_values, &indices2);\n+\n+  // std::shared_ptr<Array> indices3;\n+  // vector<int64_t> indices3_values = {1, 2, 0, 0, 2, 0};\n+  // ArrayFromVector<Int64Type, int64_t>(is_valid, indices3_values, &indices3);\n+  // std::shared_ptr<Array> arr2 = std::make_shared<DictionaryArray>(dict_type, indices2);\n+  // std::shared_ptr<Array> arr3 = std::make_shared<DictionaryArray>(dict_type, indices3);\n+  // ASSERT_OK(ValidateArray(*arr3));\n+}\n+\n+TEST(TestDictionary, FromArray) {\n+  std::shared_ptr<Array> dict;\n+  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n+  ArrayFromVector<StringType, string>(dict_values, &dict);\n+  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n+\n+  std::shared_ptr<Array> indices1;\n+  vector<int16_t> indices_values1 = {1, 2, 0, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(indices_values1, &indices1);\n+\n+  std::shared_ptr<Array> indices2;\n+  vector<int16_t> indices_values2 = {1, 2, 0, 3, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(indices_values2, &indices2);\n+\n+  std::shared_ptr<Array> indices3;\n+  vector<bool> is_valid3 = {true, true, false, true, true, true};\n+  vector<int16_t> indices_values3 = {1, 2, -1, 0, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid3, indices_values3, &indices3);\n+\n+  std::shared_ptr<Array> indices4;\n+  vector<bool> is_valid4 = {true, true, false, true, true, true};\n+  vector<int16_t> indices_values4 = {1, 2, 1, 3, 2, 0};\n+  ArrayFromVector<Int16Type, int16_t>(is_valid4, indices_values4, &indices4);\n+\n+  std::shared_ptr<Array> arr1, arr2, arr3, arr4;\n+  ASSERT_OK(DictionaryArray::FromArrays(dict_type, indices1, &arr1));\n+  ASSERT_RAISES(Invalid, DictionaryArray::FromArrays(dict_type, indices2, &arr2));\n+  ASSERT_OK(DictionaryArray::FromArrays(dict_type, indices3, &arr3));\n+  ASSERT_RAISES(Invalid, DictionaryArray::FromArrays(dict_type, indices4, &arr4));\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/array-list-test.cc b/cpp/src/arrow/array-list-test.cc\nnew file mode 100644\nindex 0000000000..207acd4cf6\n--- /dev/null\n+++ b/cpp/src/arrow/array-list-test.cc\n@@ -0,0 +1,299 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <cstring>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+using std::string;\n+using std::vector;\n+\n+using internal::checked_cast;\n+\n+// ----------------------------------------------------------------------\n+// List tests\n+\n+class TestListArray : public TestBuilder {\n+ public:\n+  void SetUp() {\n+    TestBuilder::SetUp();\n+\n+    value_type_ = int32();\n+    type_ = list(value_type_);\n+\n+    std::unique_ptr<ArrayBuilder> tmp;\n+    ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n+    builder_.reset(checked_cast<ListBuilder*>(tmp.release()));\n+  }\n+\n+  void Done() {\n+    std::shared_ptr<Array> out;\n+    FinishAndCheckPadding(builder_.get(), &out);\n+    result_ = std::dynamic_pointer_cast<ListArray>(out);\n+  }\n+\n+ protected:\n+  std::shared_ptr<DataType> value_type_;\n+\n+  std::shared_ptr<ListBuilder> builder_;\n+  std::shared_ptr<ListArray> result_;\n+};\n+\n+TEST_F(TestListArray, Equality) {\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n+\n+  std::shared_ptr<Array> array, equal_array, unequal_array;\n+  vector<int32_t> equal_offsets = {0, 1, 2, 5, 6, 7, 8, 10};\n+  vector<int32_t> equal_values = {1, 2, 3, 4, 5, 2, 2, 2, 5, 6};\n+  vector<int32_t> unequal_offsets = {0, 1, 4, 7};\n+  vector<int32_t> unequal_values = {1, 2, 2, 2, 3, 4, 5};\n+\n+  // setup two equal arrays\n+  ASSERT_OK(builder_->AppendValues(equal_offsets.data(), equal_offsets.size()));\n+  ASSERT_OK(vb->AppendValues(equal_values.data(), equal_values.size()));\n+\n+  ASSERT_OK(builder_->Finish(&array));\n+  ASSERT_OK(builder_->AppendValues(equal_offsets.data(), equal_offsets.size()));\n+  ASSERT_OK(vb->AppendValues(equal_values.data(), equal_values.size()));\n+\n+  ASSERT_OK(builder_->Finish(&equal_array));\n+  // now an unequal one\n+  ASSERT_OK(builder_->AppendValues(unequal_offsets.data(), unequal_offsets.size()));\n+  ASSERT_OK(vb->AppendValues(unequal_values.data(), unequal_values.size()));\n+\n+  ASSERT_OK(builder_->Finish(&unequal_array));\n+\n+  // Test array equality\n+  EXPECT_TRUE(array->Equals(array));\n+  EXPECT_TRUE(array->Equals(equal_array));\n+  EXPECT_TRUE(equal_array->Equals(array));\n+  EXPECT_FALSE(equal_array->Equals(unequal_array));\n+  EXPECT_FALSE(unequal_array->Equals(equal_array));\n+\n+  // Test range equality\n+  EXPECT_TRUE(array->RangeEquals(0, 1, 0, unequal_array));\n+  EXPECT_FALSE(array->RangeEquals(0, 2, 0, unequal_array));\n+  EXPECT_FALSE(array->RangeEquals(1, 2, 1, unequal_array));\n+  EXPECT_TRUE(array->RangeEquals(2, 3, 2, unequal_array));\n+\n+  // Check with slices, ARROW-33\n+  std::shared_ptr<Array> slice, slice2;\n+\n+  slice = array->Slice(2);\n+  slice2 = array->Slice(2);\n+  ASSERT_EQ(array->length() - 2, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(2, slice->length(), 0, slice));\n+\n+  // Chained slices\n+  slice2 = array->Slice(1)->Slice(1);\n+  ASSERT_TRUE(slice->Equals(slice2));\n+\n+  slice = array->Slice(1, 4);\n+  slice2 = array->Slice(1, 4);\n+  ASSERT_EQ(4, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(1, 5, 0, slice));\n+}\n+\n+TEST_F(TestListArray, TestResize) {}\n+\n+TEST_F(TestListArray, TestFromArrays) {\n+  std::shared_ptr<Array> offsets1, offsets2, offsets3, offsets4, values;\n+\n+  std::vector<bool> offsets_is_valid3 = {true, false, true, true};\n+  std::vector<bool> offsets_is_valid4 = {true, true, false, true};\n+\n+  std::vector<bool> values_is_valid = {true, false, true, true, true, true};\n+\n+  std::vector<int32_t> offset1_values = {0, 2, 2, 6};\n+  std::vector<int32_t> offset2_values = {0, 2, 6, 6};\n+\n+  std::vector<int8_t> values_values = {0, 1, 2, 3, 4, 5};\n+  const int length = 3;\n+\n+  ArrayFromVector<Int32Type, int32_t>(offset1_values, &offsets1);\n+  ArrayFromVector<Int32Type, int32_t>(offset2_values, &offsets2);\n+\n+  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid3, offset1_values, &offsets3);\n+  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid4, offset2_values, &offsets4);\n+\n+  ArrayFromVector<Int8Type, int8_t>(values_is_valid, values_values, &values);\n+\n+  auto list_type = list(int8());\n+\n+  std::shared_ptr<Array> list1, list3, list4;\n+  ASSERT_OK(ListArray::FromArrays(*offsets1, *values, pool_, &list1));\n+  ASSERT_OK(ListArray::FromArrays(*offsets3, *values, pool_, &list3));\n+  ASSERT_OK(ListArray::FromArrays(*offsets4, *values, pool_, &list4));\n+\n+  ListArray expected1(list_type, length, offsets1->data()->buffers[1], values,\n+                      offsets1->data()->buffers[0], 0);\n+  AssertArraysEqual(expected1, *list1);\n+\n+  // Use null bitmap from offsets3, but clean offsets from non-null version\n+  ListArray expected3(list_type, length, offsets1->data()->buffers[1], values,\n+                      offsets3->data()->buffers[0], 1);\n+  AssertArraysEqual(expected3, *list3);\n+\n+  // Check that the last offset bit is zero\n+  ASSERT_FALSE(BitUtil::GetBit(list3->null_bitmap()->data(), length + 1));\n+\n+  ListArray expected4(list_type, length, offsets2->data()->buffers[1], values,\n+                      offsets4->data()->buffers[0], 1);\n+  AssertArraysEqual(expected4, *list4);\n+\n+  // Test failure modes\n+\n+  std::shared_ptr<Array> tmp;\n+\n+  // Zero-length offsets\n+  ASSERT_RAISES(Invalid,\n+                ListArray::FromArrays(*offsets1->Slice(0, 0), *values, pool_, &tmp));\n+\n+  // Offsets not int32\n+  ASSERT_RAISES(Invalid, ListArray::FromArrays(*values, *offsets1, pool_, &tmp));\n+}\n+\n+TEST_F(TestListArray, TestAppendNull) {\n+  ASSERT_OK(builder_->AppendNull());\n+  ASSERT_OK(builder_->AppendNull());\n+\n+  Done();\n+\n+  ASSERT_OK(ValidateArray(*result_));\n+  ASSERT_TRUE(result_->IsNull(0));\n+  ASSERT_TRUE(result_->IsNull(1));\n+\n+  ASSERT_EQ(0, result_->raw_value_offsets()[0]);\n+  ASSERT_EQ(0, result_->value_offset(1));\n+  ASSERT_EQ(0, result_->value_offset(2));\n+\n+  auto values = result_->values();\n+  ASSERT_EQ(0, values->length());\n+  // Values buffer should be non-null\n+  ASSERT_NE(nullptr, values->data()->buffers[1]);\n+}\n+\n+void ValidateBasicListArray(const ListArray* result, const vector<int32_t>& values,\n+                            const vector<uint8_t>& is_valid) {\n+  ASSERT_OK(ValidateArray(*result));\n+  ASSERT_EQ(1, result->null_count());\n+  ASSERT_EQ(0, result->values()->null_count());\n+\n+  ASSERT_EQ(3, result->length());\n+  vector<int32_t> ex_offsets = {0, 3, 3, 7};\n+  for (size_t i = 0; i < ex_offsets.size(); ++i) {\n+    ASSERT_EQ(ex_offsets[i], result->value_offset(i));\n+  }\n+\n+  for (int i = 0; i < result->length(); ++i) {\n+    ASSERT_EQ(is_valid[i] == 0, result->IsNull(i));\n+  }\n+\n+  ASSERT_EQ(7, result->values()->length());\n+  auto varr = std::dynamic_pointer_cast<Int32Array>(result->values());\n+\n+  for (size_t i = 0; i < values.size(); ++i) {\n+    ASSERT_EQ(values[i], varr->Value(i));\n+  }\n+}\n+\n+TEST_F(TestListArray, TestBasics) {\n+  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n+  vector<int> lengths = {3, 0, 4};\n+  vector<uint8_t> is_valid = {1, 0, 1};\n+\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n+\n+  ASSERT_OK(builder_->Reserve(lengths.size()));\n+  ASSERT_OK(vb->Reserve(values.size()));\n+\n+  int pos = 0;\n+  for (size_t i = 0; i < lengths.size(); ++i) {\n+    ASSERT_OK(builder_->Append(is_valid[i] > 0));\n+    for (int j = 0; j < lengths[i]; ++j) {\n+      ASSERT_OK(vb->Append(values[pos++]));\n+    }\n+  }\n+\n+  Done();\n+  ValidateBasicListArray(result_.get(), values, is_valid);\n+}\n+\n+TEST_F(TestListArray, BulkAppend) {\n+  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n+  vector<int> lengths = {3, 0, 4};\n+  vector<uint8_t> is_valid = {1, 0, 1};\n+  vector<int32_t> offsets = {0, 3, 3};\n+\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n+  ASSERT_OK(vb->Reserve(values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n+  for (int32_t value : values) {\n+    ASSERT_OK(vb->Append(value));\n+  }\n+  Done();\n+  ValidateBasicListArray(result_.get(), values, is_valid);\n+}\n+\n+TEST_F(TestListArray, BulkAppendInvalid) {\n+  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n+  vector<int> lengths = {3, 0, 4};\n+  vector<uint8_t> is_null = {0, 1, 0};\n+  vector<uint8_t> is_valid = {1, 0, 1};\n+  vector<int32_t> offsets = {0, 2, 4};  // should be 0, 3, 3 given the is_null array\n+\n+  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n+  ASSERT_OK(vb->Reserve(values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n+  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n+  for (int32_t value : values) {\n+    ASSERT_OK(vb->Append(value));\n+  }\n+\n+  Done();\n+  ASSERT_RAISES(Invalid, ValidateArray(*result_));\n+}\n+\n+TEST_F(TestListArray, TestZeroLength) {\n+  // All buffers are null\n+  Done();\n+  ASSERT_OK(ValidateArray(*result_));\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/array-struct-test.cc b/cpp/src/arrow/array-struct-test.cc\nnew file mode 100644\nindex 0000000000..dc8bafd4c0\n--- /dev/null\n+++ b/cpp/src/arrow/array-struct-test.cc\n@@ -0,0 +1,465 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <cstdint>\n+#include <cstring>\n+#include <limits>\n+#include <memory>\n+#include <string>\n+#include <vector>\n+\n+#include <gtest/gtest.h>\n+\n+#include \"arrow/array.h\"\n+#include \"arrow/buffer.h\"\n+#include \"arrow/builder.h\"\n+#include \"arrow/status.h\"\n+#include \"arrow/test-common.h\"\n+#include \"arrow/test-util.h\"\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+using std::string;\n+using std::vector;\n+\n+using internal::checked_cast;\n+\n+// ----------------------------------------------------------------------\n+// Struct tests\n+\n+void ValidateBasicStructArray(const StructArray* result,\n+                              const vector<uint8_t>& struct_is_valid,\n+                              const vector<char>& list_values,\n+                              const vector<uint8_t>& list_is_valid,\n+                              const vector<int>& list_lengths,\n+                              const vector<int>& list_offsets,\n+                              const vector<int32_t>& int_values) {\n+  ASSERT_EQ(4, result->length());\n+  ASSERT_OK(ValidateArray(*result));\n+\n+  auto list_char_arr = std::dynamic_pointer_cast<ListArray>(result->field(0));\n+  auto char_arr = std::dynamic_pointer_cast<Int8Array>(list_char_arr->values());\n+  auto int32_arr = std::dynamic_pointer_cast<Int32Array>(result->field(1));\n+\n+  ASSERT_EQ(nullptr, result->GetFieldByName(\"non-existing\"));\n+  ASSERT_TRUE(list_char_arr->Equals(result->GetFieldByName(\"list\")));\n+  ASSERT_TRUE(int32_arr->Equals(result->GetFieldByName(\"int\")));\n+\n+  ASSERT_EQ(0, result->null_count());\n+  ASSERT_EQ(1, list_char_arr->null_count());\n+  ASSERT_EQ(0, int32_arr->null_count());\n+\n+  // List<char>\n+  ASSERT_EQ(4, list_char_arr->length());\n+  ASSERT_EQ(10, list_char_arr->values()->length());\n+  for (size_t i = 0; i < list_offsets.size(); ++i) {\n+    ASSERT_EQ(list_offsets[i], list_char_arr->raw_value_offsets()[i]);\n+  }\n+  for (size_t i = 0; i < list_values.size(); ++i) {\n+    ASSERT_EQ(list_values[i], char_arr->Value(i));\n+  }\n+\n+  // Int32\n+  ASSERT_EQ(4, int32_arr->length());\n+  for (size_t i = 0; i < int_values.size(); ++i) {\n+    ASSERT_EQ(int_values[i], int32_arr->Value(i));\n+  }\n+}\n+\n+// ----------------------------------------------------------------------------------\n+// Struct test\n+class TestStructBuilder : public TestBuilder {\n+ public:\n+  void SetUp() {\n+    TestBuilder::SetUp();\n+\n+    auto int32_type = int32();\n+    auto char_type = int8();\n+    auto list_type = list(char_type);\n+\n+    vector<std::shared_ptr<DataType>> types = {list_type, int32_type};\n+    vector<std::shared_ptr<Field>> fields;\n+    fields.push_back(field(\"list\", list_type));\n+    fields.push_back(field(\"int\", int32_type));\n+\n+    type_ = struct_(fields);\n+    value_fields_ = fields;\n+\n+    std::unique_ptr<ArrayBuilder> tmp;\n+    ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n+    builder_.reset(checked_cast<StructBuilder*>(tmp.release()));\n+    ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n+  }\n+\n+  void Done() {\n+    std::shared_ptr<Array> out;\n+    FinishAndCheckPadding(builder_.get(), &out);\n+    result_ = std::dynamic_pointer_cast<StructArray>(out);\n+  }\n+\n+ protected:\n+  vector<std::shared_ptr<Field>> value_fields_;\n+\n+  std::shared_ptr<StructBuilder> builder_;\n+  std::shared_ptr<StructArray> result_;\n+};\n+\n+TEST_F(TestStructBuilder, TestAppendNull) {\n+  ASSERT_OK(builder_->AppendNull());\n+  ASSERT_OK(builder_->AppendNull());\n+  ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  ASSERT_OK(list_vb->AppendNull());\n+  ASSERT_OK(list_vb->AppendNull());\n+  ASSERT_EQ(2, list_vb->length());\n+\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+  ASSERT_OK(int_vb->AppendNull());\n+  ASSERT_OK(int_vb->AppendNull());\n+  ASSERT_EQ(2, int_vb->length());\n+\n+  Done();\n+\n+  ASSERT_OK(ValidateArray(*result_));\n+\n+  ASSERT_EQ(2, static_cast<int>(result_->num_fields()));\n+  ASSERT_EQ(2, result_->length());\n+  ASSERT_EQ(2, result_->field(0)->length());\n+  ASSERT_EQ(2, result_->field(1)->length());\n+  ASSERT_TRUE(result_->IsNull(0));\n+  ASSERT_TRUE(result_->IsNull(1));\n+  ASSERT_TRUE(result_->field(0)->IsNull(0));\n+  ASSERT_TRUE(result_->field(0)->IsNull(1));\n+  ASSERT_TRUE(result_->field(1)->IsNull(0));\n+  ASSERT_TRUE(result_->field(1)->IsNull(1));\n+\n+  ASSERT_EQ(Type::LIST, result_->field(0)->type_id());\n+  ASSERT_EQ(Type::INT32, result_->field(1)->type_id());\n+}\n+\n+TEST_F(TestStructBuilder, TestBasics) {\n+  vector<int32_t> int_values = {1, 2, 3, 4};\n+  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n+  vector<int> list_lengths = {3, 0, 3, 4};\n+  vector<int> list_offsets = {0, 3, 3, 6, 10};\n+  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n+  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+  ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n+\n+  EXPECT_OK(builder_->Resize(list_lengths.size()));\n+  EXPECT_OK(char_vb->Resize(list_values.size()));\n+  EXPECT_OK(int_vb->Resize(int_values.size()));\n+\n+  int pos = 0;\n+  for (size_t i = 0; i < list_lengths.size(); ++i) {\n+    ASSERT_OK(list_vb->Append(list_is_valid[i] > 0));\n+    int_vb->UnsafeAppend(int_values[i]);\n+    for (int j = 0; j < list_lengths[i]; ++j) {\n+      char_vb->UnsafeAppend(list_values[pos++]);\n+    }\n+  }\n+\n+  for (size_t i = 0; i < struct_is_valid.size(); ++i) {\n+    ASSERT_OK(builder_->Append(struct_is_valid[i] > 0));\n+  }\n+\n+  Done();\n+\n+  ValidateBasicStructArray(result_.get(), struct_is_valid, list_values, list_is_valid,\n+                           list_lengths, list_offsets, int_values);\n+}\n+\n+TEST_F(TestStructBuilder, BulkAppend) {\n+  vector<int32_t> int_values = {1, 2, 3, 4};\n+  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n+  vector<int> list_lengths = {3, 0, 3, 4};\n+  vector<int> list_offsets = {0, 3, 3, 6};\n+  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n+  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+\n+  ASSERT_OK(builder_->Resize(list_lengths.size()));\n+  ASSERT_OK(char_vb->Resize(list_values.size()));\n+  ASSERT_OK(int_vb->Resize(int_values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  Done();\n+  ValidateBasicStructArray(result_.get(), struct_is_valid, list_values, list_is_valid,\n+                           list_lengths, list_offsets, int_values);\n+}\n+\n+TEST_F(TestStructBuilder, BulkAppendInvalid) {\n+  vector<int32_t> int_values = {1, 2, 3, 4};\n+  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n+  vector<int> list_lengths = {3, 0, 3, 4};\n+  vector<int> list_offsets = {0, 3, 3, 6};\n+  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n+  vector<uint8_t> struct_is_valid = {1, 0, 1, 1};  // should be 1, 1, 1, 1\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+\n+  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n+  ASSERT_OK(char_vb->Reserve(list_values.size()));\n+  ASSERT_OK(int_vb->Reserve(int_values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  Done();\n+  // Even null bitmap of the parent Struct is not valid, validate will ignore it.\n+  ASSERT_OK(ValidateArray(*result_));\n+}\n+\n+TEST_F(TestStructBuilder, TestEquality) {\n+  std::shared_ptr<Array> array, equal_array;\n+  std::shared_ptr<Array> unequal_bitmap_array, unequal_offsets_array,\n+      unequal_values_array;\n+\n+  vector<int32_t> int_values = {101, 102, 103, 104};\n+  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n+  vector<int> list_lengths = {3, 0, 3, 4};\n+  vector<int> list_offsets = {0, 3, 3, 6};\n+  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n+  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n+\n+  vector<int32_t> unequal_int_values = {104, 102, 103, 101};\n+  vector<char> unequal_list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'l', 'u', 'c', 'y'};\n+  vector<int> unequal_list_offsets = {0, 3, 4, 6};\n+  vector<uint8_t> unequal_list_is_valid = {1, 1, 1, 1};\n+  vector<uint8_t> unequal_struct_is_valid = {1, 0, 0, 1};\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n+  ASSERT_OK(char_vb->Reserve(list_values.size()));\n+  ASSERT_OK(int_vb->Reserve(int_values.size()));\n+\n+  // setup two equal arrays, one of which takes an unequal bitmap\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  FinishAndCheckPadding(builder_.get(), &array);\n+\n+  ASSERT_OK(builder_->Resize(list_lengths.size()));\n+  ASSERT_OK(char_vb->Resize(list_values.size()));\n+  ASSERT_OK(int_vb->Resize(int_values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  ASSERT_OK(builder_->Finish(&equal_array));\n+\n+  ASSERT_OK(builder_->Resize(list_lengths.size()));\n+  ASSERT_OK(char_vb->Resize(list_values.size()));\n+  ASSERT_OK(int_vb->Resize(int_values.size()));\n+\n+  // setup an unequal one with the unequal bitmap\n+  ASSERT_OK(builder_->AppendValues(unequal_struct_is_valid.size(),\n+                                   unequal_struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  ASSERT_OK(builder_->Finish(&unequal_bitmap_array));\n+\n+  ASSERT_OK(builder_->Resize(list_lengths.size()));\n+  ASSERT_OK(char_vb->Resize(list_values.size()));\n+  ASSERT_OK(int_vb->Resize(int_values.size()));\n+\n+  // setup an unequal one with unequal offsets\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(unequal_list_offsets.data(),\n+                                  unequal_list_offsets.size(),\n+                                  unequal_list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  ASSERT_OK(builder_->Finish(&unequal_offsets_array));\n+\n+  ASSERT_OK(builder_->Resize(list_lengths.size()));\n+  ASSERT_OK(char_vb->Resize(list_values.size()));\n+  ASSERT_OK(int_vb->Resize(int_values.size()));\n+\n+  // setup anunequal one with unequal values\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : unequal_list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : unequal_int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+\n+  ASSERT_OK(builder_->Finish(&unequal_values_array));\n+\n+  // Test array equality\n+  EXPECT_TRUE(array->Equals(array));\n+  EXPECT_TRUE(array->Equals(equal_array));\n+  EXPECT_TRUE(equal_array->Equals(array));\n+  EXPECT_FALSE(equal_array->Equals(unequal_bitmap_array));\n+  EXPECT_FALSE(unequal_bitmap_array->Equals(equal_array));\n+  EXPECT_FALSE(unequal_bitmap_array->Equals(unequal_values_array));\n+  EXPECT_FALSE(unequal_values_array->Equals(unequal_bitmap_array));\n+  EXPECT_FALSE(unequal_bitmap_array->Equals(unequal_offsets_array));\n+  EXPECT_FALSE(unequal_offsets_array->Equals(unequal_bitmap_array));\n+\n+  // Test range equality\n+  EXPECT_TRUE(array->RangeEquals(0, 4, 0, equal_array));\n+  EXPECT_TRUE(array->RangeEquals(3, 4, 3, unequal_bitmap_array));\n+  EXPECT_TRUE(array->RangeEquals(0, 1, 0, unequal_offsets_array));\n+  EXPECT_FALSE(array->RangeEquals(0, 2, 0, unequal_offsets_array));\n+  EXPECT_FALSE(array->RangeEquals(1, 2, 1, unequal_offsets_array));\n+  EXPECT_FALSE(array->RangeEquals(0, 1, 0, unequal_values_array));\n+  EXPECT_TRUE(array->RangeEquals(1, 3, 1, unequal_values_array));\n+  EXPECT_FALSE(array->RangeEquals(3, 4, 3, unequal_values_array));\n+}\n+\n+TEST_F(TestStructBuilder, TestZeroLength) {\n+  // All buffers are null\n+  Done();\n+  ASSERT_OK(ValidateArray(*result_));\n+}\n+\n+TEST_F(TestStructBuilder, TestSlice) {\n+  std::shared_ptr<Array> array, equal_array;\n+  std::shared_ptr<Array> unequal_bitmap_array, unequal_offsets_array,\n+      unequal_values_array;\n+\n+  vector<int32_t> int_values = {101, 102, 103, 104};\n+  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n+  vector<int> list_lengths = {3, 0, 3, 4};\n+  vector<int> list_offsets = {0, 3, 3, 6};\n+  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n+  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n+\n+  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n+  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n+  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n+  ASSERT_OK(char_vb->Reserve(list_values.size()));\n+  ASSERT_OK(int_vb->Reserve(int_values.size()));\n+\n+  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n+                                  list_is_valid.data()));\n+  for (int8_t value : list_values) {\n+    char_vb->UnsafeAppend(value);\n+  }\n+  for (int32_t value : int_values) {\n+    int_vb->UnsafeAppend(value);\n+  }\n+  FinishAndCheckPadding(builder_.get(), &array);\n+\n+  std::shared_ptr<StructArray> slice, slice2;\n+  std::shared_ptr<Int32Array> int_field;\n+  std::shared_ptr<ListArray> list_field;\n+\n+  slice = std::dynamic_pointer_cast<StructArray>(array->Slice(2));\n+  slice2 = std::dynamic_pointer_cast<StructArray>(array->Slice(2));\n+  ASSERT_EQ(array->length() - 2, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(2, slice->length(), 0, slice));\n+\n+  int_field = std::dynamic_pointer_cast<Int32Array>(slice->field(1));\n+  ASSERT_EQ(int_field->length(), slice->length());\n+  ASSERT_EQ(int_field->Value(0), 103);\n+  ASSERT_EQ(int_field->Value(1), 104);\n+  ASSERT_EQ(int_field->null_count(), 0);\n+  list_field = std::dynamic_pointer_cast<ListArray>(slice->field(0));\n+  ASSERT_FALSE(list_field->IsNull(0));\n+  ASSERT_FALSE(list_field->IsNull(1));\n+  ASSERT_EQ(list_field->value_length(0), 3);\n+  ASSERT_EQ(list_field->value_length(1), 4);\n+  ASSERT_EQ(list_field->null_count(), 0);\n+\n+  slice = std::dynamic_pointer_cast<StructArray>(array->Slice(1, 2));\n+  slice2 = std::dynamic_pointer_cast<StructArray>(array->Slice(1, 2));\n+  ASSERT_EQ(2, slice->length());\n+\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(1, 3, 0, slice));\n+\n+  int_field = std::dynamic_pointer_cast<Int32Array>(slice->field(1));\n+  ASSERT_EQ(int_field->length(), slice->length());\n+  ASSERT_EQ(int_field->Value(0), 102);\n+  ASSERT_EQ(int_field->Value(1), 103);\n+  ASSERT_EQ(int_field->null_count(), 0);\n+  list_field = std::dynamic_pointer_cast<ListArray>(slice->field(0));\n+  ASSERT_TRUE(list_field->IsNull(0));\n+  ASSERT_FALSE(list_field->IsNull(1));\n+  ASSERT_EQ(list_field->value_length(0), 0);\n+  ASSERT_EQ(list_field->value_length(1), 3);\n+  ASSERT_EQ(list_field->null_count(), 1);\n+}\n+\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/array-test.cc b/cpp/src/arrow/array-test.cc\nindex 8e8bfcf1ee..d7445d6fa6 100644\n--- a/cpp/src/arrow/array-test.cc\n+++ b/cpp/src/arrow/array-test.cc\n@@ -46,6 +46,9 @@\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/lazy.h\"\n \n+// This file is compiled together with array-*-test.cc into a single\n+// executable array-test.\n+\n namespace arrow {\n \n using std::string;\n@@ -53,42 +56,6 @@ using std::vector;\n \n using internal::checked_cast;\n \n-namespace {\n-// used to prevent compiler optimizing away side-effect-less statements\n-volatile int throw_away = 0;\n-\n-// checks if the padding of the buffers of the array is zero\n-// also causes valgrind warnings if the padding bytes are uninitialized\n-void AssertZeroPadded(const Array& array) {\n-  for (const auto& buffer : array.data()->buffers) {\n-    if (buffer) {\n-      const int64_t padding = buffer->capacity() - buffer->size();\n-      std::vector<uint8_t> zeros(padding);\n-      ASSERT_EQ(0, memcmp(buffer->data() + buffer->size(), zeros.data(), padding));\n-    }\n-  }\n-}\n-\n-// Check if the valid buffer bytes are initialized by\n-// calling memcmp on them which will cause valgrind warnings otherwise\n-void TestInitialized(const Array& array) {\n-  for (const auto& buffer : array.data()->buffers) {\n-    if (buffer) {\n-      std::vector<uint8_t> zeros(buffer->capacity());\n-      throw_away = memcmp(buffer->data(), zeros.data(), buffer->size());\n-    }\n-  }\n-}\n-\n-template <typename BuilderType>\n-void FinishAndCheckPadding(BuilderType* builder, std::shared_ptr<Array>* out) {\n-  ASSERT_OK(builder->Finish(out));\n-  AssertZeroPadded(**out);\n-  TestInitialized(**out);\n-}\n-\n-}  // namespace\n-\n class TestArray : public ::testing::Test {\n  public:\n   void SetUp() { pool_ = default_memory_pool(); }\n@@ -1000,2649 +967,486 @@ TEST(TestPrimitiveAdHoc, FloatingSliceApproxEquals) {\n }\n \n // ----------------------------------------------------------------------\n-// String / Binary tests\n+// FixedSizeBinary tests\n \n-class TestStringArray : public ::testing::Test {\n+class TestFWBinaryArray : public ::testing::Test {\n  public:\n-  void SetUp() {\n-    chars_ = {'a', 'b', 'b', 'c', 'c', 'c'};\n-    offsets_ = {0, 1, 1, 1, 3, 6};\n-    valid_bytes_ = {1, 1, 0, 1, 1};\n-    expected_ = {\"a\", \"\", \"\", \"bb\", \"ccc\"};\n-\n-    MakeArray();\n-  }\n-\n-  void MakeArray() {\n-    length_ = static_cast<int64_t>(offsets_.size()) - 1;\n-    value_buf_ = Buffer::Wrap(chars_);\n-    offsets_buf_ = Buffer::Wrap(offsets_);\n-    ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n-    null_count_ = CountNulls(valid_bytes_);\n+  void SetUp() {}\n \n-    strings_ = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n+  void InitBuilder(int byte_width) {\n+    auto type = fixed_size_binary(byte_width);\n+    builder_.reset(new FixedSizeBinaryBuilder(type, default_memory_pool()));\n   }\n \n  protected:\n-  vector<int32_t> offsets_;\n-  vector<char> chars_;\n-  vector<uint8_t> valid_bytes_;\n+  std::unique_ptr<FixedSizeBinaryBuilder> builder_;\n+};\n \n-  vector<string> expected_;\n+TEST_F(TestFWBinaryArray, Builder) {\n+  int32_t byte_width = 10;\n+  int64_t length = 4096;\n \n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n+  int64_t nbytes = length * byte_width;\n \n-  int64_t null_count_;\n-  int64_t length_;\n+  vector<uint8_t> data(nbytes);\n+  random_bytes(nbytes, 0, data.data());\n \n-  std::shared_ptr<StringArray> strings_;\n-};\n+  vector<uint8_t> is_valid(length);\n+  random_null_bytes(length, 0.1, is_valid.data());\n \n-TEST_F(TestStringArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n-}\n+  const uint8_t* raw_data = data.data();\n \n-TEST_F(TestStringArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n+  std::shared_ptr<Array> result;\n \n-  ASSERT_EQ(Type::STRING, type->id());\n-  ASSERT_EQ(Type::STRING, strings_->type_id());\n-}\n+  auto CheckResult = [&length, &is_valid, &raw_data, &byte_width](const Array& result) {\n+    // Verify output\n+    const auto& fw_result = checked_cast<const FixedSizeBinaryArray&>(result);\n \n-TEST_F(TestStringArray, TestListFunctions) {\n-  int pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += static_cast<int>(expected_[i].size());\n-  }\n-}\n+    ASSERT_EQ(length, result.length());\n \n-TEST_F(TestStringArray, TestDestructor) {\n-  auto arr = std::make_shared<StringArray>(length_, offsets_buf_, value_buf_,\n-                                           null_bitmap_, null_count_);\n-}\n+    for (int64_t i = 0; i < result.length(); ++i) {\n+      if (is_valid[i]) {\n+        ASSERT_EQ(0,\n+                  memcmp(raw_data + byte_width * i, fw_result.GetValue(i), byte_width));\n+      } else {\n+        ASSERT_TRUE(fw_result.IsNull(i));\n+      }\n+    }\n+  };\n \n-TEST_F(TestStringArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n+  // Build using iterative API\n+  InitBuilder(byte_width);\n+  for (int64_t i = 0; i < length; ++i) {\n+    if (is_valid[i]) {\n+      ASSERT_OK(builder_->Append(raw_data + byte_width * i));\n     } else {\n-      ASSERT_EQ(expected_[i], strings_->GetString(i));\n+      ASSERT_OK(builder_->AppendNull());\n     }\n   }\n-}\n \n-TEST_F(TestStringArray, TestEmptyStringComparison) {\n-  offsets_ = {0, 0, 0, 0, 0, 0};\n-  offsets_buf_ = Buffer::Wrap(offsets_);\n-  length_ = static_cast<int64_t>(offsets_.size() - 1);\n+  FinishAndCheckPadding(builder_.get(), &result);\n+  CheckResult(*result);\n \n-  auto strings_a = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  auto strings_b = std::make_shared<StringArray>(length_, offsets_buf_, nullptr,\n-                                                 null_bitmap_, null_count_);\n-  ASSERT_TRUE(strings_a->Equals(strings_b));\n-}\n+  // Build using batch API\n+  InitBuilder(byte_width);\n \n-TEST_F(TestStringArray, CompareNullByteSlots) {\n-  StringBuilder builder;\n-  StringBuilder builder2;\n-  StringBuilder builder3;\n+  const uint8_t* raw_is_valid = is_valid.data();\n \n-  ASSERT_OK(builder.Append(\"foo\"));\n-  ASSERT_OK(builder2.Append(\"foo\"));\n-  ASSERT_OK(builder3.Append(\"foo\"));\n+  ASSERT_OK(builder_->AppendValues(raw_data, 50, raw_is_valid));\n+  ASSERT_OK(\n+      builder_->AppendValues(raw_data + 50 * byte_width, length - 50, raw_is_valid + 50));\n+  FinishAndCheckPadding(builder_.get(), &result);\n \n-  ASSERT_OK(builder.Append(\"bar\"));\n-  ASSERT_OK(builder2.AppendNull());\n+  CheckResult(*result);\n \n-  // same length, but different\n-  ASSERT_OK(builder3.Append(\"xyz\"));\n+  // Build from std::string\n+  InitBuilder(byte_width);\n+  for (int64_t i = 0; i < length; ++i) {\n+    if (is_valid[i]) {\n+      ASSERT_OK(builder_->Append(\n+          string(reinterpret_cast<const char*>(raw_data + byte_width * i), byte_width)));\n+    } else {\n+      ASSERT_OK(builder_->AppendNull());\n+    }\n+  }\n \n-  ASSERT_OK(builder.Append(\"baz\"));\n-  ASSERT_OK(builder2.Append(\"baz\"));\n-  ASSERT_OK(builder3.Append(\"baz\"));\n+  ASSERT_OK(builder_->Finish(&result));\n+  CheckResult(*result);\n+}\n \n-  std::shared_ptr<Array> array, array2, array3;\n-  FinishAndCheckPadding(&builder, &array);\n-  ASSERT_OK(builder2.Finish(&array2));\n-  ASSERT_OK(builder3.Finish(&array3));\n+TEST_F(TestFWBinaryArray, EqualsRangeEquals) {\n+  // Check that we don't compare data in null slots\n \n-  const auto& a1 = checked_cast<const StringArray&>(*array);\n-  const auto& a2 = checked_cast<const StringArray&>(*array2);\n-  const auto& a3 = checked_cast<const StringArray&>(*array3);\n+  auto type = fixed_size_binary(4);\n+  FixedSizeBinaryBuilder builder1(type);\n+  FixedSizeBinaryBuilder builder2(type);\n \n-  // The validity bitmaps are the same, the data is different, but the unequal\n-  // portion is masked out\n-  StringArray equal_array(3, a1.value_offsets(), a1.value_data(), a2.null_bitmap(), 1);\n-  StringArray equal_array2(3, a3.value_offsets(), a3.value_data(), a2.null_bitmap(), 1);\n+  ASSERT_OK(builder1.Append(\"foo1\"));\n+  ASSERT_OK(builder1.AppendNull());\n \n-  ASSERT_TRUE(equal_array.Equals(equal_array2));\n-  ASSERT_TRUE(a2.RangeEquals(equal_array2, 0, 3, 0));\n+  ASSERT_OK(builder2.Append(\"foo1\"));\n+  ASSERT_OK(builder2.Append(\"foo2\"));\n \n-  ASSERT_TRUE(equal_array.Array::Slice(1)->Equals(equal_array2.Array::Slice(1)));\n-  ASSERT_TRUE(\n-      equal_array.Array::Slice(1)->RangeEquals(0, 2, 0, equal_array2.Array::Slice(1)));\n-}\n+  std::shared_ptr<Array> array1, array2;\n+  ASSERT_OK(builder1.Finish(&array1));\n+  ASSERT_OK(builder2.Finish(&array2));\n \n-TEST_F(TestStringArray, TestSliceGetString) {\n-  StringBuilder builder;\n+  const auto& a1 = checked_cast<const FixedSizeBinaryArray&>(*array1);\n+  const auto& a2 = checked_cast<const FixedSizeBinaryArray&>(*array2);\n \n-  ASSERT_OK(builder.Append(\"a\"));\n-  ASSERT_OK(builder.Append(\"b\"));\n-  ASSERT_OK(builder.Append(\"c\"));\n+  FixedSizeBinaryArray equal1(type, 2, a1.values(), a1.null_bitmap(), 1);\n+  FixedSizeBinaryArray equal2(type, 2, a2.values(), a1.null_bitmap(), 1);\n \n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-  auto s = array->Slice(1, 10);\n-  auto arr = std::dynamic_pointer_cast<StringArray>(s);\n-  ASSERT_EQ(arr->GetString(0), \"b\");\n+  ASSERT_TRUE(equal1.Equals(equal2));\n+  ASSERT_TRUE(equal1.RangeEquals(equal2, 0, 2, 0));\n }\n \n-// ----------------------------------------------------------------------\n-// String builder tests\n-\n-class TestStringBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new StringBuilder(pool_));\n-  }\n-\n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n+TEST_F(TestFWBinaryArray, ZeroSize) {\n+  auto type = fixed_size_binary(0);\n+  FixedSizeBinaryBuilder builder(type);\n \n-    result_ = std::dynamic_pointer_cast<StringArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n-  }\n+  ASSERT_OK(builder.Append(\"\"));\n+  ASSERT_OK(builder.Append(std::string()));\n+  ASSERT_OK(builder.Append(static_cast<const uint8_t*>(nullptr)));\n+  ASSERT_OK(builder.AppendNull());\n+  ASSERT_OK(builder.AppendNull());\n+  ASSERT_OK(builder.AppendNull());\n \n- protected:\n-  std::unique_ptr<StringBuilder> builder_;\n-  std::shared_ptr<StringArray> result_;\n-};\n+  std::shared_ptr<Array> array;\n+  ASSERT_OK(builder.Finish(&array));\n \n-TEST_F(TestStringBuilder, TestScalarAppend) {\n-  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n+  const auto& fw_array = checked_cast<const FixedSizeBinaryArray&>(*array);\n \n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n+  // data is never allocated\n+  ASSERT_TRUE(fw_array.values() == nullptr);\n+  ASSERT_EQ(0, fw_array.byte_width());\n \n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (is_null[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n-      } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n-      }\n-    }\n-  }\n-  Done();\n+  ASSERT_EQ(6, array->length());\n+  ASSERT_EQ(3, array->null_count());\n+}\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n+TEST_F(TestFWBinaryArray, ZeroPadding) {\n+  auto type = fixed_size_binary(4);\n+  FixedSizeBinaryBuilder builder(type);\n \n-  int32_t length;\n-  int32_t pos = 0;\n-  for (int i = 0; i < N * reps; ++i) {\n-    if (is_null[i % N]) {\n-      ASSERT_TRUE(result_->IsNull(i));\n-    } else {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      result_->GetValue(i, &length);\n-      ASSERT_EQ(pos, result_->value_offset(i));\n-      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n-      ASSERT_EQ(strings[i % N], result_->GetString(i));\n+  ASSERT_OK(builder.Append(\"foo1\"));\n+  ASSERT_OK(builder.AppendNull());\n+  ASSERT_OK(builder.Append(\"foo2\"));\n+  ASSERT_OK(builder.AppendNull());\n+  ASSERT_OK(builder.Append(\"foo3\"));\n \n-      pos += length;\n-    }\n-  }\n+  std::shared_ptr<Array> array;\n+  FinishAndCheckPadding(&builder, &array);\n }\n \n-TEST_F(TestStringBuilder, TestAppendVector) {\n-  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 1000;\n+TEST_F(TestFWBinaryArray, Slice) {\n+  auto type = fixed_size_binary(4);\n+  FixedSizeBinaryBuilder builder(type);\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, valid_bytes.data()));\n-  }\n-  Done();\n+  vector<string> strings = {\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"};\n+  vector<uint8_t> is_null = {0, 1, 0, 0, 0};\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  int32_t length;\n-  int32_t pos = 0;\n-  for (int i = 0; i < N * reps; ++i) {\n-    if (valid_bytes[i % N]) {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      result_->GetValue(i, &length);\n-      ASSERT_EQ(pos, result_->value_offset(i));\n-      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n-      ASSERT_EQ(strings[i % N], result_->GetString(i));\n-\n-      pos += length;\n+  for (int i = 0; i < 5; ++i) {\n+    if (is_null[i]) {\n+      ASSERT_OK(builder.AppendNull());\n     } else {\n-      ASSERT_TRUE(result_->IsNull(i));\n+      ASSERT_OK(builder.Append(strings[i]));\n     }\n   }\n-}\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithValidBytes) {\n-  const char* strings[] = {nullptr, \"aaa\", nullptr, \"ignored\", \"\"};\n-  vector<uint8_t> valid_bytes = {1, 1, 1, 0, 1};\n-\n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  std::shared_ptr<Array> array;\n+  ASSERT_OK(builder.Finish(&array));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N, valid_bytes.data()));\n-  }\n-  Done();\n+  std::shared_ptr<Array> slice, slice2;\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps * 3, result_->null_count());\n-  ASSERT_EQ(reps * 3, result_->value_data()->size());\n-\n-  int32_t length;\n-  int32_t pos = 0;\n-  for (int i = 0; i < N * reps; ++i) {\n-    auto string = strings[i % N];\n-    if (string && valid_bytes[i % N]) {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      result_->GetValue(i, &length);\n-      ASSERT_EQ(pos, result_->value_offset(i));\n-      ASSERT_EQ(static_cast<int32_t>(strlen(string)), length);\n-      ASSERT_EQ(strings[i % N], result_->GetString(i));\n-\n-      pos += length;\n-    } else {\n-      ASSERT_TRUE(result_->IsNull(i));\n-    }\n-  }\n-}\n+  slice = array->Slice(1);\n+  slice2 = array->Slice(1);\n+  ASSERT_EQ(4, slice->length());\n \n-TEST_F(TestStringBuilder, TestAppendCStringsWithoutValidBytes) {\n-  const char* strings[] = {\"\", \"bb\", \"a\", nullptr, \"ccc\"};\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(1, slice->length(), 0, slice));\n \n-  int N = static_cast<int>(sizeof(strings) / sizeof(strings[0]));\n-  int reps = 1000;\n+  // Chained slices\n+  slice = array->Slice(2);\n+  slice2 = array->Slice(1)->Slice(1);\n+  ASSERT_TRUE(slice->Equals(slice2));\n \n-  for (int j = 0; j < reps; ++j) {\n-    ASSERT_OK(builder_->AppendValues(strings, N));\n-  }\n-  Done();\n+  slice = array->Slice(1, 3);\n+  ASSERT_EQ(3, slice->length());\n \n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  int32_t length;\n-  int32_t pos = 0;\n-  for (int i = 0; i < N * reps; ++i) {\n-    if (strings[i % N]) {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      result_->GetValue(i, &length);\n-      ASSERT_EQ(pos, result_->value_offset(i));\n-      ASSERT_EQ(static_cast<int32_t>(strlen(strings[i % N])), length);\n-      ASSERT_EQ(strings[i % N], result_->GetString(i));\n-\n-      pos += length;\n-    } else {\n-      ASSERT_TRUE(result_->IsNull(i));\n-    }\n-  }\n+  slice2 = array->Slice(1, 3);\n+  ASSERT_TRUE(slice->Equals(slice2));\n+  ASSERT_TRUE(array->RangeEquals(1, 3, 0, slice));\n }\n \n-TEST_F(TestStringBuilder, TestZeroLength) {\n-  // All buffers are null\n-  Done();\n-}\n+// ----------------------------------------------------------------------\n+// AdaptiveInt tests\n \n-// Binary container type\n-// TODO(emkornfield) there should be some way to refactor these to avoid code duplicating\n-// with String\n-class TestBinaryArray : public ::testing::Test {\n+class TestAdaptiveIntBuilder : public TestBuilder {\n  public:\n   void SetUp() {\n-    chars_ = {'a', 'b', 'b', 'c', 'c', 'c'};\n-    offsets_ = {0, 1, 1, 1, 3, 6};\n-    valid_bytes_ = {1, 1, 0, 1, 1};\n-    expected_ = {\"a\", \"\", \"\", \"bb\", \"ccc\"};\n-\n-    MakeArray();\n+    TestBuilder::SetUp();\n+    builder_ = std::make_shared<AdaptiveIntBuilder>(pool_);\n   }\n \n-  void MakeArray() {\n-    length_ = static_cast<int64_t>(offsets_.size() - 1);\n-    value_buf_ = Buffer::Wrap(chars_);\n-    offsets_buf_ = Buffer::Wrap(offsets_);\n-\n-    ASSERT_OK(BitUtil::BytesToBits(valid_bytes_, default_memory_pool(), &null_bitmap_));\n-    null_count_ = CountNulls(valid_bytes_);\n-\n-    strings_ = std::make_shared<BinaryArray>(length_, offsets_buf_, value_buf_,\n-                                             null_bitmap_, null_count_);\n-  }\n+  void Done() { FinishAndCheckPadding(builder_.get(), &result_); }\n \n  protected:\n-  vector<int32_t> offsets_;\n-  vector<char> chars_;\n-  vector<uint8_t> valid_bytes_;\n-\n-  vector<string> expected_;\n+  std::shared_ptr<AdaptiveIntBuilder> builder_;\n \n-  std::shared_ptr<Buffer> value_buf_;\n-  std::shared_ptr<Buffer> offsets_buf_;\n-  std::shared_ptr<Buffer> null_bitmap_;\n+  std::shared_ptr<Array> expected_;\n+  std::shared_ptr<Array> result_;\n+};\n \n-  int64_t null_count_;\n-  int64_t length_;\n+TEST_F(TestAdaptiveIntBuilder, TestInt8) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(builder_->Append(127));\n+  ASSERT_OK(builder_->Append(-128));\n \n-  std::shared_ptr<BinaryArray> strings_;\n-};\n+  Done();\n \n-TEST_F(TestBinaryArray, TestArrayBasics) {\n-  ASSERT_EQ(length_, strings_->length());\n-  ASSERT_EQ(1, strings_->null_count());\n-  ASSERT_OK(ValidateArray(*strings_));\n+  std::vector<int8_t> expected_values({0, 127, -128});\n+  ArrayFromVector<Int8Type, int8_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST_F(TestBinaryArray, TestType) {\n-  std::shared_ptr<DataType> type = strings_->type();\n+TEST_F(TestAdaptiveIntBuilder, TestInt16) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(builder_->Append(128));\n+  Done();\n \n-  ASSERT_EQ(Type::BINARY, type->id());\n-  ASSERT_EQ(Type::BINARY, strings_->type_id());\n-}\n+  std::vector<int16_t> expected_values({0, 128});\n+  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-TEST_F(TestBinaryArray, TestListFunctions) {\n-  size_t pos = 0;\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    ASSERT_EQ(pos, strings_->value_offset(i));\n-    ASSERT_EQ(static_cast<int>(expected_[i].size()), strings_->value_length(i));\n-    pos += expected_[i].size();\n-  }\n-}\n+  SetUp();\n+  ASSERT_OK(builder_->Append(-129));\n+  expected_values = {-129};\n+  Done();\n \n-TEST_F(TestBinaryArray, TestDestructor) {\n-  auto arr = std::make_shared<BinaryArray>(length_, offsets_buf_, value_buf_,\n-                                           null_bitmap_, null_count_);\n-}\n+  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-TEST_F(TestBinaryArray, TestGetValue) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n-    } else {\n-      ASSERT_FALSE(strings_->IsNull(i));\n-      ASSERT_EQ(strings_->GetString(i), expected_[i]);\n-    }\n-  }\n-}\n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int16_t>::max()));\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int16_t>::min()));\n+  expected_values = {std::numeric_limits<int16_t>::max(),\n+                     std::numeric_limits<int16_t>::min()};\n+  Done();\n \n-TEST_F(TestBinaryArray, TestNullValuesInitialized) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n-    } else {\n-      ASSERT_FALSE(strings_->IsNull(i));\n-      ASSERT_EQ(strings_->GetString(i), expected_[i]);\n-    }\n-  }\n-  TestInitialized(*strings_);\n+  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST_F(TestBinaryArray, TestPaddingZeroed) { AssertZeroPadded(*strings_); }\n-\n-TEST_F(TestBinaryArray, TestGetString) {\n-  for (size_t i = 0; i < expected_.size(); ++i) {\n-    if (valid_bytes_[i] == 0) {\n-      ASSERT_TRUE(strings_->IsNull(i));\n-    } else {\n-      std::string val = strings_->GetString(i);\n-      ASSERT_EQ(0, std::memcmp(expected_[i].data(), val.c_str(), val.size()));\n-    }\n-  }\n-}\n-\n-TEST_F(TestBinaryArray, TestEqualsEmptyStrings) {\n-  BinaryBuilder builder;\n-\n-  string empty_string(\"\");\n-  for (int i = 0; i < 5; ++i) {\n-    ASSERT_OK(builder.Append(empty_string));\n-  }\n-\n-  std::shared_ptr<Array> left_arr;\n-  FinishAndCheckPadding(&builder, &left_arr);\n-\n-  const BinaryArray& left = checked_cast<const BinaryArray&>(*left_arr);\n-  std::shared_ptr<Array> right =\n-      std::make_shared<BinaryArray>(left.length(), left.value_offsets(), nullptr,\n-                                    left.null_bitmap(), left.null_count());\n-\n-  ASSERT_TRUE(left.Equals(right));\n-  ASSERT_TRUE(left.RangeEquals(0, left.length(), 0, right));\n-}\n-\n-class TestBinaryBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_.reset(new BinaryBuilder(pool_));\n-  }\n-\n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-\n-    result_ = std::dynamic_pointer_cast<BinaryArray>(out);\n-    ASSERT_OK(ValidateArray(*result_));\n-  }\n-\n- protected:\n-  std::unique_ptr<BinaryBuilder> builder_;\n-  std::shared_ptr<BinaryArray> result_;\n-};\n-\n-TEST_F(TestBinaryBuilder, TestScalarAppend) {\n-  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 10;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (is_null[i]) {\n-        ASSERT_OK(builder_->AppendNull());\n-      } else {\n-        ASSERT_OK(builder_->Append(strings[i]));\n-      }\n-    }\n-  }\n-  Done();\n-  ASSERT_OK(ValidateArray(*result_));\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * 6, result_->value_data()->size());\n-\n-  int32_t length;\n-  for (int i = 0; i < N * reps; ++i) {\n-    if (is_null[i % N]) {\n-      ASSERT_TRUE(result_->IsNull(i));\n-    } else {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      const uint8_t* vals = result_->GetValue(i, &length);\n-      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n-      ASSERT_EQ(0, std::memcmp(vals, strings[i % N].data(), length));\n-    }\n-  }\n-}\n-\n-TEST_F(TestBinaryBuilder, TestScalarAppendUnsafe) {\n-  vector<string> strings = {\"\", \"bb\", \"a\", \"\", \"ccc\"};\n-  vector<uint8_t> is_null = {0, 0, 0, 1, 0};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 13;\n-  int total_length = 0;\n-  for (auto&& s : strings) total_length += static_cast<int>(s.size());\n-\n-  ASSERT_OK(builder_->Reserve(N * reps));\n-  ASSERT_OK(builder_->ReserveData(total_length * reps));\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (is_null[i]) {\n-        builder_->UnsafeAppendNull();\n-      } else {\n-        builder_->UnsafeAppend(strings[i]);\n-      }\n-    }\n-  }\n-  ASSERT_EQ(builder_->value_data_length(), total_length * reps);\n-  Done();\n-  ASSERT_OK(ValidateArray(*result_));\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(reps, result_->null_count());\n-  ASSERT_EQ(reps * total_length, result_->value_data()->size());\n-\n-  int32_t length;\n-  for (int i = 0; i < N * reps; ++i) {\n-    if (is_null[i % N]) {\n-      ASSERT_TRUE(result_->IsNull(i));\n-    } else {\n-      ASSERT_FALSE(result_->IsNull(i));\n-      const uint8_t* vals = result_->GetValue(i, &length);\n-      ASSERT_EQ(static_cast<int>(strings[i % N].size()), length);\n-      ASSERT_EQ(0, std::memcmp(vals, strings[i % N].data(), length));\n-    }\n-  }\n-}\n-\n-TEST_F(TestBinaryBuilder, TestCapacityReserve) {\n-  vector<string> strings = {\"aaaaa\", \"bbbbbbbbbb\", \"ccccccccccccccc\", \"dddddddddd\"};\n-  int N = static_cast<int>(strings.size());\n-  int reps = 15;\n-  int64_t length = 0;\n-  int64_t capacity = 1000;\n-  int64_t expected_capacity = BitUtil::RoundUpToMultipleOf64(capacity);\n-\n-  ASSERT_OK(builder_->ReserveData(capacity));\n-\n-  ASSERT_EQ(length, builder_->value_data_length());\n-  ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      ASSERT_OK(builder_->Append(strings[i]));\n-      length += static_cast<int>(strings[i].size());\n-\n-      ASSERT_EQ(length, builder_->value_data_length());\n-      ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n-    }\n-  }\n-\n-  int extra_capacity = 500;\n-  expected_capacity = BitUtil::RoundUpToMultipleOf64(length + extra_capacity);\n-\n-  ASSERT_OK(builder_->ReserveData(extra_capacity));\n-\n-  ASSERT_EQ(length, builder_->value_data_length());\n-  ASSERT_EQ(expected_capacity, builder_->value_data_capacity());\n-\n-  Done();\n-\n-  ASSERT_EQ(reps * N, result_->length());\n-  ASSERT_EQ(0, result_->null_count());\n-  ASSERT_EQ(reps * 40, result_->value_data()->size());\n-\n-  // Capacity is shrunk after `Finish`\n-  ASSERT_EQ(640, result_->value_data()->capacity());\n-}\n-\n-TEST_F(TestBinaryBuilder, TestZeroLength) {\n-  // All buffers are null\n-  Done();\n-}\n-\n-// ----------------------------------------------------------------------\n-// Slice tests\n-\n-template <typename TYPE>\n-void CheckSliceEquality() {\n-  using Traits = TypeTraits<TYPE>;\n-  using BuilderType = typename Traits::BuilderType;\n-\n-  BuilderType builder;\n-\n-  vector<string> strings = {\"foo\", \"\", \"bar\", \"baz\", \"qux\", \"\"};\n-  vector<uint8_t> is_null = {0, 1, 0, 1, 0, 0};\n-\n-  int N = static_cast<int>(strings.size());\n-  int reps = 10;\n-\n-  for (int j = 0; j < reps; ++j) {\n-    for (int i = 0; i < N; ++i) {\n-      if (is_null[i]) {\n-        ASSERT_OK(builder.AppendNull());\n-      } else {\n-        ASSERT_OK(builder.Append(strings[i]));\n-      }\n-    }\n-  }\n-\n-  std::shared_ptr<Array> array;\n-  FinishAndCheckPadding(&builder, &array);\n-\n-  std::shared_ptr<Array> slice, slice2;\n-\n-  slice = array->Slice(5);\n-  slice2 = array->Slice(5);\n-  ASSERT_EQ(N * reps - 5, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(5, slice->length(), 0, slice));\n-\n-  // Chained slices\n-  slice2 = array->Slice(2)->Slice(3);\n-  ASSERT_TRUE(slice->Equals(slice2));\n-\n-  slice = array->Slice(5, 20);\n-  slice2 = array->Slice(5, 20);\n-  ASSERT_EQ(20, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(5, 25, 0, slice));\n-}\n-\n-TEST_F(TestBinaryArray, TestSliceEquality) { CheckSliceEquality<BinaryType>(); }\n-\n-TEST_F(TestStringArray, TestSliceEquality) { CheckSliceEquality<BinaryType>(); }\n-\n-TEST_F(TestBinaryArray, LengthZeroCtor) { BinaryArray array(0, nullptr, nullptr); }\n-\n-// ----------------------------------------------------------------------\n-// FixedSizeBinary tests\n-\n-class TestFWBinaryArray : public ::testing::Test {\n- public:\n-  void SetUp() {}\n-\n-  void InitBuilder(int byte_width) {\n-    auto type = fixed_size_binary(byte_width);\n-    builder_.reset(new FixedSizeBinaryBuilder(type, default_memory_pool()));\n-  }\n-\n- protected:\n-  std::unique_ptr<FixedSizeBinaryBuilder> builder_;\n-};\n-\n-TEST_F(TestFWBinaryArray, Builder) {\n-  int32_t byte_width = 10;\n-  int64_t length = 4096;\n-\n-  int64_t nbytes = length * byte_width;\n-\n-  vector<uint8_t> data(nbytes);\n-  random_bytes(nbytes, 0, data.data());\n-\n-  vector<uint8_t> is_valid(length);\n-  random_null_bytes(length, 0.1, is_valid.data());\n-\n-  const uint8_t* raw_data = data.data();\n-\n-  std::shared_ptr<Array> result;\n-\n-  auto CheckResult = [&length, &is_valid, &raw_data, &byte_width](const Array& result) {\n-    // Verify output\n-    const auto& fw_result = checked_cast<const FixedSizeBinaryArray&>(result);\n-\n-    ASSERT_EQ(length, result.length());\n-\n-    for (int64_t i = 0; i < result.length(); ++i) {\n-      if (is_valid[i]) {\n-        ASSERT_EQ(0,\n-                  memcmp(raw_data + byte_width * i, fw_result.GetValue(i), byte_width));\n-      } else {\n-        ASSERT_TRUE(fw_result.IsNull(i));\n-      }\n-    }\n-  };\n-\n-  // Build using iterative API\n-  InitBuilder(byte_width);\n-  for (int64_t i = 0; i < length; ++i) {\n-    if (is_valid[i]) {\n-      ASSERT_OK(builder_->Append(raw_data + byte_width * i));\n-    } else {\n-      ASSERT_OK(builder_->AppendNull());\n-    }\n-  }\n-\n-  FinishAndCheckPadding(builder_.get(), &result);\n-  CheckResult(*result);\n-\n-  // Build using batch API\n-  InitBuilder(byte_width);\n-\n-  const uint8_t* raw_is_valid = is_valid.data();\n-\n-  ASSERT_OK(builder_->AppendValues(raw_data, 50, raw_is_valid));\n-  ASSERT_OK(\n-      builder_->AppendValues(raw_data + 50 * byte_width, length - 50, raw_is_valid + 50));\n-  FinishAndCheckPadding(builder_.get(), &result);\n-\n-  CheckResult(*result);\n-\n-  // Build from std::string\n-  InitBuilder(byte_width);\n-  for (int64_t i = 0; i < length; ++i) {\n-    if (is_valid[i]) {\n-      ASSERT_OK(builder_->Append(\n-          string(reinterpret_cast<const char*>(raw_data + byte_width * i), byte_width)));\n-    } else {\n-      ASSERT_OK(builder_->AppendNull());\n-    }\n-  }\n-\n-  ASSERT_OK(builder_->Finish(&result));\n-  CheckResult(*result);\n-}\n-\n-TEST_F(TestFWBinaryArray, EqualsRangeEquals) {\n-  // Check that we don't compare data in null slots\n-\n-  auto type = fixed_size_binary(4);\n-  FixedSizeBinaryBuilder builder1(type);\n-  FixedSizeBinaryBuilder builder2(type);\n-\n-  ASSERT_OK(builder1.Append(\"foo1\"));\n-  ASSERT_OK(builder1.AppendNull());\n-\n-  ASSERT_OK(builder2.Append(\"foo1\"));\n-  ASSERT_OK(builder2.Append(\"foo2\"));\n-\n-  std::shared_ptr<Array> array1, array2;\n-  ASSERT_OK(builder1.Finish(&array1));\n-  ASSERT_OK(builder2.Finish(&array2));\n-\n-  const auto& a1 = checked_cast<const FixedSizeBinaryArray&>(*array1);\n-  const auto& a2 = checked_cast<const FixedSizeBinaryArray&>(*array2);\n-\n-  FixedSizeBinaryArray equal1(type, 2, a1.values(), a1.null_bitmap(), 1);\n-  FixedSizeBinaryArray equal2(type, 2, a2.values(), a1.null_bitmap(), 1);\n-\n-  ASSERT_TRUE(equal1.Equals(equal2));\n-  ASSERT_TRUE(equal1.RangeEquals(equal2, 0, 2, 0));\n-}\n-\n-TEST_F(TestFWBinaryArray, ZeroSize) {\n-  auto type = fixed_size_binary(0);\n-  FixedSizeBinaryBuilder builder(type);\n-\n-  ASSERT_OK(builder.Append(\"\"));\n-  ASSERT_OK(builder.Append(std::string()));\n-  ASSERT_OK(builder.Append(static_cast<const uint8_t*>(nullptr)));\n-  ASSERT_OK(builder.AppendNull());\n-  ASSERT_OK(builder.AppendNull());\n-  ASSERT_OK(builder.AppendNull());\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-\n-  const auto& fw_array = checked_cast<const FixedSizeBinaryArray&>(*array);\n-\n-  // data is never allocated\n-  ASSERT_TRUE(fw_array.values() == nullptr);\n-  ASSERT_EQ(0, fw_array.byte_width());\n-\n-  ASSERT_EQ(6, array->length());\n-  ASSERT_EQ(3, array->null_count());\n-}\n-\n-TEST_F(TestFWBinaryArray, ZeroPadding) {\n-  auto type = fixed_size_binary(4);\n-  FixedSizeBinaryBuilder builder(type);\n-\n-  ASSERT_OK(builder.Append(\"foo1\"));\n-  ASSERT_OK(builder.AppendNull());\n-  ASSERT_OK(builder.Append(\"foo2\"));\n-  ASSERT_OK(builder.AppendNull());\n-  ASSERT_OK(builder.Append(\"foo3\"));\n-\n-  std::shared_ptr<Array> array;\n-  FinishAndCheckPadding(&builder, &array);\n-}\n-\n-TEST_F(TestFWBinaryArray, Slice) {\n-  auto type = fixed_size_binary(4);\n-  FixedSizeBinaryBuilder builder(type);\n-\n-  vector<string> strings = {\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"};\n-  vector<uint8_t> is_null = {0, 1, 0, 0, 0};\n-\n-  for (int i = 0; i < 5; ++i) {\n-    if (is_null[i]) {\n-      ASSERT_OK(builder.AppendNull());\n-    } else {\n-      ASSERT_OK(builder.Append(strings[i]));\n-    }\n-  }\n-\n-  std::shared_ptr<Array> array;\n-  ASSERT_OK(builder.Finish(&array));\n-\n-  std::shared_ptr<Array> slice, slice2;\n-\n-  slice = array->Slice(1);\n-  slice2 = array->Slice(1);\n-  ASSERT_EQ(4, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(1, slice->length(), 0, slice));\n-\n-  // Chained slices\n-  slice = array->Slice(2);\n-  slice2 = array->Slice(1)->Slice(1);\n-  ASSERT_TRUE(slice->Equals(slice2));\n-\n-  slice = array->Slice(1, 3);\n-  ASSERT_EQ(3, slice->length());\n-\n-  slice2 = array->Slice(1, 3);\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(1, 3, 0, slice));\n-}\n-\n-// ----------------------------------------------------------------------\n-// AdaptiveInt tests\n-\n-class TestAdaptiveIntBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_ = std::make_shared<AdaptiveIntBuilder>(pool_);\n-  }\n-\n-  void Done() { FinishAndCheckPadding(builder_.get(), &result_); }\n-\n- protected:\n-  std::shared_ptr<AdaptiveIntBuilder> builder_;\n-\n-  std::shared_ptr<Array> expected_;\n-  std::shared_ptr<Array> result_;\n-};\n-\n-TEST_F(TestAdaptiveIntBuilder, TestInt8) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(builder_->Append(127));\n-  ASSERT_OK(builder_->Append(-128));\n-\n-  Done();\n-\n-  std::vector<int8_t> expected_values({0, 127, -128});\n-  ArrayFromVector<Int8Type, int8_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestInt16) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(builder_->Append(128));\n-  Done();\n-\n-  std::vector<int16_t> expected_values({0, 128});\n-  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(-129));\n-  expected_values = {-129};\n-  Done();\n-\n-  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int16_t>::max()));\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int16_t>::min()));\n-  expected_values = {std::numeric_limits<int16_t>::max(),\n-                     std::numeric_limits<int16_t>::min()};\n-  Done();\n-\n-  ArrayFromVector<Int16Type, int16_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestInt32) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(\n-      builder_->Append(static_cast<int64_t>(std::numeric_limits<int16_t>::max()) + 1));\n-  Done();\n-\n-  std::vector<int32_t> expected_values(\n-      {0, static_cast<int32_t>(std::numeric_limits<int16_t>::max()) + 1});\n-  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(\n-      builder_->Append(static_cast<int64_t>(std::numeric_limits<int16_t>::min()) - 1));\n-  expected_values = {static_cast<int32_t>(std::numeric_limits<int16_t>::min()) - 1};\n-  Done();\n-\n-  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int32_t>::max()));\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int32_t>::min()));\n-  expected_values = {std::numeric_limits<int32_t>::max(),\n-                     std::numeric_limits<int32_t>::min()};\n-  Done();\n-\n-  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestInt64) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(\n-      builder_->Append(static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1));\n-  Done();\n-\n-  std::vector<int64_t> expected_values(\n-      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n-  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(\n-      builder_->Append(static_cast<int64_t>(std::numeric_limits<int32_t>::min()) - 1));\n-  expected_values = {static_cast<int64_t>(std::numeric_limits<int32_t>::min()) - 1};\n-  Done();\n-\n-  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int64_t>::max()));\n-  ASSERT_OK(builder_->Append(std::numeric_limits<int64_t>::min()));\n-  expected_values = {std::numeric_limits<int64_t>::max(),\n-                     std::numeric_limits<int64_t>::min()};\n-  Done();\n-\n-  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestAppendValues) {\n-  std::vector<int64_t> expected_values(\n-      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n-  ASSERT_OK(builder_->AppendValues(expected_values.data(), expected_values.size()));\n-  Done();\n-\n-  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestAssertZeroPadded) {\n-  std::vector<int64_t> values(\n-      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n-  ASSERT_OK(builder_->AppendValues(values.data(), values.size()));\n-  Done();\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestAppendNull) {\n-  int64_t size = 1000;\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_OK(builder_->AppendNull());\n-  }\n-\n-  Done();\n-\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_TRUE(result_->IsNull(index));\n-  }\n-}\n-\n-TEST_F(TestAdaptiveIntBuilder, TestAppendNulls) {\n-  constexpr int64_t size = 10;\n-  const uint8_t valid_bytes[size] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n-  ASSERT_OK(builder_->AppendNulls(valid_bytes, size));\n-\n-  Done();\n-\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_EQ(result_->IsValid(index), static_cast<bool>(valid_bytes[index]));\n-  }\n-}\n-\n-class TestAdaptiveUIntBuilder : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-    builder_ = std::make_shared<AdaptiveUIntBuilder>(pool_);\n-  }\n-\n-  void Done() { FinishAndCheckPadding(builder_.get(), &result_); }\n-\n- protected:\n-  std::shared_ptr<AdaptiveUIntBuilder> builder_;\n-\n-  std::shared_ptr<Array> expected_;\n-  std::shared_ptr<Array> result_;\n-};\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestUInt8) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(builder_->Append(255));\n-\n-  Done();\n-\n-  std::vector<uint8_t> expected_values({0, 255});\n-  ArrayFromVector<UInt8Type, uint8_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestUInt16) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(builder_->Append(256));\n-  Done();\n-\n-  std::vector<uint16_t> expected_values({0, 256});\n-  ArrayFromVector<UInt16Type, uint16_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<uint16_t>::max()));\n-  expected_values = {std::numeric_limits<uint16_t>::max()};\n-  Done();\n-\n-  ArrayFromVector<UInt16Type, uint16_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestUInt32) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(\n-      builder_->Append(static_cast<uint64_t>(std::numeric_limits<uint16_t>::max()) + 1));\n-  Done();\n-\n-  std::vector<uint32_t> expected_values(\n-      {0, static_cast<uint32_t>(std::numeric_limits<uint16_t>::max()) + 1});\n-  ArrayFromVector<UInt32Type, uint32_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<uint32_t>::max()));\n-  expected_values = {std::numeric_limits<uint32_t>::max()};\n-  Done();\n-\n-  ArrayFromVector<UInt32Type, uint32_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestUInt64) {\n-  ASSERT_OK(builder_->Append(0));\n-  ASSERT_OK(\n-      builder_->Append(static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1));\n-  Done();\n-\n-  std::vector<uint64_t> expected_values(\n-      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n-  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-\n-  SetUp();\n-  ASSERT_OK(builder_->Append(std::numeric_limits<uint64_t>::max()));\n-  expected_values = {std::numeric_limits<uint64_t>::max()};\n-  Done();\n-\n-  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestAppendValues) {\n-  std::vector<uint64_t> expected_values(\n-      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n-  ASSERT_OK(builder_->AppendValues(expected_values.data(), expected_values.size()));\n-  Done();\n-\n-  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n-  ASSERT_TRUE(expected_->Equals(result_));\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestAssertZeroPadded) {\n-  std::vector<uint64_t> values(\n-      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n-  ASSERT_OK(builder_->AppendValues(values.data(), values.size()));\n-  Done();\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestAppendNull) {\n-  int64_t size = 1000;\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_OK(builder_->AppendNull());\n-  }\n-\n-  Done();\n-\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_TRUE(result_->IsNull(index));\n-  }\n-}\n-\n-TEST_F(TestAdaptiveUIntBuilder, TestAppendNulls) {\n-  constexpr int64_t size = 10;\n-  const uint8_t valid_bytes[size] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n-  ASSERT_OK(builder_->AppendNulls(valid_bytes, size));\n-\n-  Done();\n-\n-  for (unsigned index = 0; index < size; ++index) {\n-    ASSERT_EQ(result_->IsValid(index), static_cast<bool>(valid_bytes[index]));\n-  }\n-}\n-\n-// ----------------------------------------------------------------------\n-// Dictionary tests\n-\n-template <typename Type>\n-class TestDictionaryBuilder : public TestBuilder {};\n-\n-typedef ::testing::Types<Int8Type, UInt8Type, Int16Type, UInt16Type, Int32Type,\n-                         UInt32Type, Int64Type, UInt64Type, FloatType, DoubleType>\n-    PrimitiveDictionaries;\n-\n-TYPED_TEST_CASE(TestDictionaryBuilder, PrimitiveDictionaries);\n-\n-TYPED_TEST(TestDictionaryBuilder, Basic) {\n-  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Build expected data\n-  NumericBuilder<TypeParam> dict_builder;\n-  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> dict_array;\n-  ASSERT_OK(dict_builder.Finish(&dict_array));\n-  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n-\n-  Int8Builder int_builder;\n-  ASSERT_OK(int_builder.Append(0));\n-  ASSERT_OK(int_builder.Append(1));\n-  ASSERT_OK(int_builder.Append(0));\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TYPED_TEST(TestDictionaryBuilder, ArrayConversion) {\n-  NumericBuilder<TypeParam> builder;\n-  // DictionaryBuilder<TypeParam> builder;\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-\n-  std::shared_ptr<Array> intermediate_result;\n-  ASSERT_OK(builder.Finish(&intermediate_result));\n-  DictionaryBuilder<TypeParam> dictionary_builder(default_memory_pool());\n-  ASSERT_OK(dictionary_builder.AppendArray(*intermediate_result));\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(dictionary_builder.Finish(&result));\n-\n-  // Build expected data\n-  NumericBuilder<TypeParam> dict_builder;\n-  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(dict_builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> dict_array;\n-  ASSERT_OK(dict_builder.Finish(&dict_array));\n-  auto dtype = std::make_shared<DictionaryType>(int8(), dict_array);\n-\n-  Int8Builder int_builder;\n-  ASSERT_OK(int_builder.Append(0));\n-  ASSERT_OK(int_builder.Append(1));\n-  ASSERT_OK(int_builder.Append(0));\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TYPED_TEST(TestDictionaryBuilder, DoubleTableSize) {\n-  using Scalar = typename TypeParam::c_type;\n-  // Skip this test for (u)int8\n-  if (sizeof(Scalar) > 1) {\n-    // Build the dictionary Array\n-    DictionaryBuilder<TypeParam> builder(default_memory_pool());\n-    // Build expected data\n-    NumericBuilder<TypeParam> dict_builder;\n-    Int16Builder int_builder;\n-\n-    // Fill with 1024 different values\n-    for (int64_t i = 0; i < 1024; i++) {\n-      ASSERT_OK(builder.Append(static_cast<Scalar>(i)));\n-      ASSERT_OK(dict_builder.Append(static_cast<Scalar>(i)));\n-      ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n-    }\n-    // Fill with an already existing value\n-    for (int64_t i = 0; i < 1024; i++) {\n-      ASSERT_OK(builder.Append(static_cast<Scalar>(1)));\n-      ASSERT_OK(int_builder.Append(1));\n-    }\n-\n-    // Finalize result\n-    std::shared_ptr<Array> result;\n-    FinishAndCheckPadding(&builder, &result);\n-\n-    // Finalize expected data\n-    std::shared_ptr<Array> dict_array;\n-    ASSERT_OK(dict_builder.Finish(&dict_array));\n-    auto dtype = std::make_shared<DictionaryType>(int16(), dict_array);\n-    std::shared_ptr<Array> int_array;\n-    ASSERT_OK(int_builder.Finish(&int_array));\n-\n-    DictionaryArray expected(dtype, int_array);\n-    ASSERT_TRUE(expected.Equals(result));\n-  }\n-}\n-\n-TYPED_TEST(TestDictionaryBuilder, DeltaDictionary) {\n-  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n-\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> result;\n-  FinishAndCheckPadding(&builder, &result);\n-\n-  // Build expected data for the initial dictionary\n-  NumericBuilder<TypeParam> dict_builder1;\n-  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> dict_array1;\n-  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n-  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n-\n-  Int8Builder int_builder1;\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  std::shared_ptr<Array> int_array1;\n-  ASSERT_OK(int_builder1.Finish(&int_array1));\n-\n-  DictionaryArray expected(dtype1, int_array1);\n-  ASSERT_TRUE(expected.Equals(result));\n-\n-  // extend the dictionary builder with new data\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-\n-  std::shared_ptr<Array> result_delta;\n-  ASSERT_OK(builder.Finish(&result_delta));\n-\n-  // Build expected data for the delta dictionary\n-  NumericBuilder<TypeParam> dict_builder2;\n-  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n-  std::shared_ptr<Array> dict_array2;\n-  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n-  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n-\n-  Int8Builder int_builder2;\n-  ASSERT_OK(int_builder2.Append(1));\n-  ASSERT_OK(int_builder2.Append(2));\n-  ASSERT_OK(int_builder2.Append(2));\n-  ASSERT_OK(int_builder2.Append(0));\n-  ASSERT_OK(int_builder2.Append(2));\n-  std::shared_ptr<Array> int_array2;\n-  ASSERT_OK(int_builder2.Finish(&int_array2));\n-\n-  DictionaryArray expected_delta(dtype2, int_array2);\n-  ASSERT_TRUE(expected_delta.Equals(result_delta));\n-}\n-\n-TYPED_TEST(TestDictionaryBuilder, DoubleDeltaDictionary) {\n-  DictionaryBuilder<TypeParam> builder(default_memory_pool());\n-\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> result;\n-  FinishAndCheckPadding(&builder, &result);\n-\n-  // Build expected data for the initial dictionary\n-  NumericBuilder<TypeParam> dict_builder1;\n-  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(dict_builder1.Append(static_cast<typename TypeParam::c_type>(2)));\n-  std::shared_ptr<Array> dict_array1;\n-  ASSERT_OK(dict_builder1.Finish(&dict_array1));\n-  auto dtype1 = std::make_shared<DictionaryType>(int8(), dict_array1);\n-\n-  Int8Builder int_builder1;\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  std::shared_ptr<Array> int_array1;\n-  ASSERT_OK(int_builder1.Finish(&int_array1));\n-\n-  DictionaryArray expected(dtype1, int_array1);\n-  ASSERT_TRUE(expected.Equals(result));\n-\n-  // extend the dictionary builder with new data\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-\n-  std::shared_ptr<Array> result_delta1;\n-  ASSERT_OK(builder.Finish(&result_delta1));\n-\n-  // Build expected data for the delta dictionary\n-  NumericBuilder<TypeParam> dict_builder2;\n-  ASSERT_OK(dict_builder2.Append(static_cast<typename TypeParam::c_type>(3)));\n-  std::shared_ptr<Array> dict_array2;\n-  ASSERT_OK(dict_builder2.Finish(&dict_array2));\n-  auto dtype2 = std::make_shared<DictionaryType>(int8(), dict_array2);\n-\n-  Int8Builder int_builder2;\n-  ASSERT_OK(int_builder2.Append(1));\n-  ASSERT_OK(int_builder2.Append(2));\n-  ASSERT_OK(int_builder2.Append(2));\n-  ASSERT_OK(int_builder2.Append(0));\n-  ASSERT_OK(int_builder2.Append(2));\n-  std::shared_ptr<Array> int_array2;\n-  ASSERT_OK(int_builder2.Finish(&int_array2));\n-\n-  DictionaryArray expected_delta1(dtype2, int_array2);\n-  ASSERT_TRUE(expected_delta1.Equals(result_delta1));\n-\n-  // extend the dictionary builder with new data again\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(1)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(2)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(3)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(4)));\n-  ASSERT_OK(builder.Append(static_cast<typename TypeParam::c_type>(5)));\n-\n-  std::shared_ptr<Array> result_delta2;\n-  ASSERT_OK(builder.Finish(&result_delta2));\n-\n-  // Build expected data for the delta dictionary again\n-  NumericBuilder<TypeParam> dict_builder3;\n-  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(4)));\n-  ASSERT_OK(dict_builder3.Append(static_cast<typename TypeParam::c_type>(5)));\n-  std::shared_ptr<Array> dict_array3;\n-  ASSERT_OK(dict_builder3.Finish(&dict_array3));\n-  auto dtype3 = std::make_shared<DictionaryType>(int8(), dict_array3);\n-\n-  Int8Builder int_builder3;\n-  ASSERT_OK(int_builder3.Append(0));\n-  ASSERT_OK(int_builder3.Append(1));\n-  ASSERT_OK(int_builder3.Append(2));\n-  ASSERT_OK(int_builder3.Append(3));\n-  ASSERT_OK(int_builder3.Append(4));\n-  std::shared_ptr<Array> int_array3;\n-  ASSERT_OK(int_builder3.Finish(&int_array3));\n-\n-  DictionaryArray expected_delta2(dtype3, int_array3);\n-  ASSERT_TRUE(expected_delta2.Equals(result_delta2));\n-}\n-\n-TEST(TestStringDictionaryBuilder, Basic) {\n-  // Build the dictionary Array\n-  StringDictionaryBuilder builder(default_memory_pool());\n-  ASSERT_OK(builder.Append(\"test\"));\n-  ASSERT_OK(builder.Append(\"test2\"));\n-  ASSERT_OK(builder.Append(\"test\"));\n-\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Build expected data\n-  StringBuilder str_builder;\n-  ASSERT_OK(str_builder.Append(\"test\"));\n-  ASSERT_OK(str_builder.Append(\"test2\"));\n-  std::shared_ptr<Array> str_array;\n-  ASSERT_OK(str_builder.Finish(&str_array));\n-  auto dtype = std::make_shared<DictionaryType>(int8(), str_array);\n-\n-  Int8Builder int_builder;\n-  ASSERT_OK(int_builder.Append(0));\n-  ASSERT_OK(int_builder.Append(1));\n-  ASSERT_OK(int_builder.Append(0));\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TEST(TestStringDictionaryBuilder, DoubleTableSize) {\n-  // Build the dictionary Array\n-  StringDictionaryBuilder builder(default_memory_pool());\n-  // Build expected data\n-  StringBuilder str_builder;\n-  Int16Builder int_builder;\n-\n-  // Fill with 1024 different values\n-  for (int64_t i = 0; i < 1024; i++) {\n-    std::stringstream ss;\n-    ss << \"test\" << i;\n-    ASSERT_OK(builder.Append(ss.str()));\n-    ASSERT_OK(str_builder.Append(ss.str()));\n-    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n-  }\n-  // Fill with an already existing value\n-  for (int64_t i = 0; i < 1024; i++) {\n-    ASSERT_OK(builder.Append(\"test1\"));\n-    ASSERT_OK(int_builder.Append(1));\n-  }\n-\n-  // Finalize result\n-  std::shared_ptr<Array> result;\n-  FinishAndCheckPadding(&builder, &result);\n-\n-  // Finalize expected data\n-  std::shared_ptr<Array> str_array;\n-  ASSERT_OK(str_builder.Finish(&str_array));\n-  auto dtype = std::make_shared<DictionaryType>(int16(), str_array);\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TEST(TestStringDictionaryBuilder, DeltaDictionary) {\n-  // Build the dictionary Array\n-  StringDictionaryBuilder builder(default_memory_pool());\n-  ASSERT_OK(builder.Append(\"test\"));\n-  ASSERT_OK(builder.Append(\"test2\"));\n-  ASSERT_OK(builder.Append(\"test\"));\n-\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Build expected data\n-  StringBuilder str_builder1;\n-  ASSERT_OK(str_builder1.Append(\"test\"));\n-  ASSERT_OK(str_builder1.Append(\"test2\"));\n-  std::shared_ptr<Array> str_array1;\n-  ASSERT_OK(str_builder1.Finish(&str_array1));\n-  auto dtype1 = std::make_shared<DictionaryType>(int8(), str_array1);\n-\n-  Int8Builder int_builder1;\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  ASSERT_OK(int_builder1.Append(0));\n-  std::shared_ptr<Array> int_array1;\n-  ASSERT_OK(int_builder1.Finish(&int_array1));\n-\n-  DictionaryArray expected(dtype1, int_array1);\n-  ASSERT_TRUE(expected.Equals(result));\n-\n-  // build a delta dictionary\n-  ASSERT_OK(builder.Append(\"test2\"));\n-  ASSERT_OK(builder.Append(\"test3\"));\n-  ASSERT_OK(builder.Append(\"test2\"));\n-\n-  std::shared_ptr<Array> result_delta;\n-  FinishAndCheckPadding(&builder, &result_delta);\n-\n-  // Build expected data\n-  StringBuilder str_builder2;\n-  ASSERT_OK(str_builder2.Append(\"test3\"));\n-  std::shared_ptr<Array> str_array2;\n-  ASSERT_OK(str_builder2.Finish(&str_array2));\n-  auto dtype2 = std::make_shared<DictionaryType>(int8(), str_array2);\n-\n-  Int8Builder int_builder2;\n-  ASSERT_OK(int_builder2.Append(1));\n-  ASSERT_OK(int_builder2.Append(2));\n-  ASSERT_OK(int_builder2.Append(1));\n-  std::shared_ptr<Array> int_array2;\n-  ASSERT_OK(int_builder2.Finish(&int_array2));\n-\n-  DictionaryArray expected_delta(dtype2, int_array2);\n-  ASSERT_TRUE(expected_delta.Equals(result_delta));\n-}\n-\n-TEST(TestStringDictionaryBuilder, BigDeltaDictionary) {\n-  constexpr int16_t kTestLength = 2048;\n-  // Build the dictionary Array\n-  StringDictionaryBuilder builder(default_memory_pool());\n-\n-  StringBuilder str_builder1;\n-  Int16Builder int_builder1;\n-\n-  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n-    std::stringstream sstream;\n-    sstream << \"test\" << idx;\n-    ASSERT_OK(builder.Append(sstream.str()));\n-    ASSERT_OK(str_builder1.Append(sstream.str()));\n-    ASSERT_OK(int_builder1.Append(idx));\n-  }\n-\n-  std::shared_ptr<Array> result;\n-  FinishAndCheckPadding(&builder, &result);\n-\n-  std::shared_ptr<Array> str_array1;\n-  ASSERT_OK(str_builder1.Finish(&str_array1));\n-  auto dtype1 = std::make_shared<DictionaryType>(int16(), str_array1);\n-\n-  std::shared_ptr<Array> int_array1;\n-  ASSERT_OK(int_builder1.Finish(&int_array1));\n-\n-  DictionaryArray expected(dtype1, int_array1);\n-  ASSERT_TRUE(expected.Equals(result));\n-\n-  // build delta 1\n-  StringBuilder str_builder2;\n-  Int16Builder int_builder2;\n-\n-  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n-    ASSERT_OK(builder.Append(\"test1\"));\n-    ASSERT_OK(int_builder2.Append(1));\n-  }\n-\n-  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n-    ASSERT_OK(builder.Append(\"test_new_value1\"));\n-    ASSERT_OK(int_builder2.Append(kTestLength));\n-  }\n-  ASSERT_OK(str_builder2.Append(\"test_new_value1\"));\n-\n-  std::shared_ptr<Array> result2;\n-  ASSERT_OK(builder.Finish(&result2));\n-\n-  std::shared_ptr<Array> str_array2;\n-  ASSERT_OK(str_builder2.Finish(&str_array2));\n-  auto dtype2 = std::make_shared<DictionaryType>(int16(), str_array2);\n-\n-  std::shared_ptr<Array> int_array2;\n-  ASSERT_OK(int_builder2.Finish(&int_array2));\n-\n-  DictionaryArray expected2(dtype2, int_array2);\n-  ASSERT_TRUE(expected2.Equals(result2));\n-\n-  // build delta 2\n-  StringBuilder str_builder3;\n-  Int16Builder int_builder3;\n-\n-  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n-    ASSERT_OK(builder.Append(\"test2\"));\n-    ASSERT_OK(int_builder3.Append(2));\n-  }\n-\n-  for (int16_t idx = 0; idx < kTestLength; ++idx) {\n-    ASSERT_OK(builder.Append(\"test_new_value2\"));\n-    ASSERT_OK(int_builder3.Append(kTestLength + 1));\n-  }\n-  ASSERT_OK(str_builder3.Append(\"test_new_value2\"));\n-\n-  std::shared_ptr<Array> result3;\n-  ASSERT_OK(builder.Finish(&result3));\n-\n-  std::shared_ptr<Array> str_array3;\n-  ASSERT_OK(str_builder3.Finish(&str_array3));\n-  auto dtype3 = std::make_shared<DictionaryType>(int16(), str_array3);\n-\n-  std::shared_ptr<Array> int_array3;\n-  ASSERT_OK(int_builder3.Finish(&int_array3));\n-\n-  DictionaryArray expected3(dtype3, int_array3);\n-  ASSERT_TRUE(expected3.Equals(result3));\n-}\n-\n-TEST(TestFixedSizeBinaryDictionaryBuilder, Basic) {\n-  // Build the dictionary Array\n-  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n-                                                 default_memory_pool());\n-  std::vector<uint8_t> test{12, 12, 11, 12};\n-  std::vector<uint8_t> test2{12, 12, 11, 11};\n-  ASSERT_OK(builder.Append(test.data()));\n-  ASSERT_OK(builder.Append(test2.data()));\n-  ASSERT_OK(builder.Append(test.data()));\n-\n-  std::shared_ptr<Array> result;\n-  FinishAndCheckPadding(&builder, &result);\n-\n-  // Build expected data\n-  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n-  ASSERT_OK(fsb_builder.Append(test.data()));\n-  ASSERT_OK(fsb_builder.Append(test2.data()));\n-  std::shared_ptr<Array> fsb_array;\n-  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n-  auto dtype = std::make_shared<DictionaryType>(int8(), fsb_array);\n-\n-  Int8Builder int_builder;\n-  ASSERT_OK(int_builder.Append(0));\n-  ASSERT_OK(int_builder.Append(1));\n-  ASSERT_OK(int_builder.Append(0));\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TEST(TestFixedSizeBinaryDictionaryBuilder, DeltaDictionary) {\n-  // Build the dictionary Array\n-  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n-                                                 default_memory_pool());\n-  std::vector<uint8_t> test{12, 12, 11, 12};\n-  std::vector<uint8_t> test2{12, 12, 11, 11};\n-  std::vector<uint8_t> test3{12, 12, 11, 10};\n-\n-  ASSERT_OK(builder.Append(test.data()));\n-  ASSERT_OK(builder.Append(test2.data()));\n-  ASSERT_OK(builder.Append(test.data()));\n-\n-  std::shared_ptr<Array> result1;\n-  FinishAndCheckPadding(&builder, &result1);\n-\n-  // Build expected data\n-  FixedSizeBinaryBuilder fsb_builder1(arrow::fixed_size_binary(4));\n-  ASSERT_OK(fsb_builder1.Append(test.data()));\n-  ASSERT_OK(fsb_builder1.Append(test2.data()));\n-  std::shared_ptr<Array> fsb_array1;\n-  ASSERT_OK(fsb_builder1.Finish(&fsb_array1));\n-  auto dtype1 = std::make_shared<DictionaryType>(int8(), fsb_array1);\n-\n-  Int8Builder int_builder1;\n-  ASSERT_OK(int_builder1.Append(0));\n-  ASSERT_OK(int_builder1.Append(1));\n-  ASSERT_OK(int_builder1.Append(0));\n-  std::shared_ptr<Array> int_array1;\n-  ASSERT_OK(int_builder1.Finish(&int_array1));\n-\n-  DictionaryArray expected1(dtype1, int_array1);\n-  ASSERT_TRUE(expected1.Equals(result1));\n-\n-  // build delta dictionary\n-  ASSERT_OK(builder.Append(test.data()));\n-  ASSERT_OK(builder.Append(test2.data()));\n-  ASSERT_OK(builder.Append(test3.data()));\n-\n-  std::shared_ptr<Array> result2;\n-  FinishAndCheckPadding(&builder, &result2);\n-\n-  // Build expected data\n-  FixedSizeBinaryBuilder fsb_builder2(arrow::fixed_size_binary(4));\n-  ASSERT_OK(fsb_builder2.Append(test3.data()));\n-  std::shared_ptr<Array> fsb_array2;\n-  ASSERT_OK(fsb_builder2.Finish(&fsb_array2));\n-  auto dtype2 = std::make_shared<DictionaryType>(int8(), fsb_array2);\n-\n-  Int8Builder int_builder2;\n-  ASSERT_OK(int_builder2.Append(0));\n-  ASSERT_OK(int_builder2.Append(1));\n-  ASSERT_OK(int_builder2.Append(2));\n-  std::shared_ptr<Array> int_array2;\n-  ASSERT_OK(int_builder2.Finish(&int_array2));\n-\n-  DictionaryArray expected2(dtype2, int_array2);\n-  ASSERT_TRUE(expected2.Equals(result2));\n-}\n-\n-TEST(TestFixedSizeBinaryDictionaryBuilder, DoubleTableSize) {\n-  // Build the dictionary Array\n-  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n-                                                 default_memory_pool());\n-  // Build expected data\n-  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(4));\n-  Int16Builder int_builder;\n-\n-  // Fill with 1024 different values\n-  for (int64_t i = 0; i < 1024; i++) {\n-    std::vector<uint8_t> value{12, 12, static_cast<uint8_t>(i / 128),\n-                               static_cast<uint8_t>(i % 128)};\n-    ASSERT_OK(builder.Append(value.data()));\n-    ASSERT_OK(fsb_builder.Append(value.data()));\n-    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n-  }\n-  // Fill with an already existing value\n-  std::vector<uint8_t> known_value{12, 12, 0, 1};\n-  for (int64_t i = 0; i < 1024; i++) {\n-    ASSERT_OK(builder.Append(known_value.data()));\n-    ASSERT_OK(int_builder.Append(1));\n-  }\n-\n-  // Finalize result\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Finalize expected data\n-  std::shared_ptr<Array> fsb_array;\n-  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n-  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TEST(TestFixedSizeBinaryDictionaryBuilder, InvalidTypeAppend) {\n-  // Build the dictionary Array\n-  DictionaryBuilder<FixedSizeBinaryType> builder(arrow::fixed_size_binary(4),\n-                                                 default_memory_pool());\n-  // Build an array with different byte width\n-  FixedSizeBinaryBuilder fsb_builder(arrow::fixed_size_binary(5));\n-  std::vector<uint8_t> value{100, 1, 1, 1, 1};\n-  ASSERT_OK(fsb_builder.Append(value.data()));\n-  std::shared_ptr<Array> fsb_array;\n-  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n-\n-  ASSERT_RAISES(Invalid, builder.AppendArray(*fsb_array));\n-}\n-\n-TEST(TestDecimalDictionaryBuilder, Basic) {\n-  // Build the dictionary Array\n-  const auto& decimal_type = arrow::decimal(2, 0);\n-  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n-\n-  // Test data\n-  std::vector<Decimal128> test{12, 12, 11, 12};\n-  for (const auto& value : test) {\n-    ASSERT_OK(builder.Append(value.ToBytes().data()));\n-  }\n-\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Build expected data\n-  FixedSizeBinaryBuilder decimal_builder(decimal_type);\n-  ASSERT_OK(decimal_builder.Append(Decimal128(12).ToBytes()));\n-  ASSERT_OK(decimal_builder.Append(Decimal128(11).ToBytes()));\n-\n-  std::shared_ptr<Array> decimal_array;\n-  ASSERT_OK(decimal_builder.Finish(&decimal_array));\n-  auto dtype = arrow::dictionary(int8(), decimal_array);\n-\n-  Int8Builder int_builder;\n-  ASSERT_OK(int_builder.AppendValues({0, 0, 1, 0}));\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-TEST(TestDecimalDictionaryBuilder, DoubleTableSize) {\n-  const auto& decimal_type = arrow::decimal(21, 0);\n-\n-  // Build the dictionary Array\n-  DictionaryBuilder<FixedSizeBinaryType> builder(decimal_type, default_memory_pool());\n-\n-  // Build expected data\n-  FixedSizeBinaryBuilder fsb_builder(decimal_type);\n-  Int16Builder int_builder;\n-\n-  // Fill with 1024 different values\n-  for (int64_t i = 0; i < 1024; i++) {\n-    const uint8_t bytes[] = {0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             0,\n-                             12,\n-                             12,\n-                             static_cast<uint8_t>(i / 128),\n-                             static_cast<uint8_t>(i % 128)};\n-    ASSERT_OK(builder.Append(bytes));\n-    ASSERT_OK(fsb_builder.Append(bytes));\n-    ASSERT_OK(int_builder.Append(static_cast<uint16_t>(i)));\n-  }\n-  // Fill with an already existing value\n-  const uint8_t known_value[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 12, 0, 1};\n-  for (int64_t i = 0; i < 1024; i++) {\n-    ASSERT_OK(builder.Append(known_value));\n-    ASSERT_OK(int_builder.Append(1));\n-  }\n-\n-  // Finalize result\n-  std::shared_ptr<Array> result;\n-  ASSERT_OK(builder.Finish(&result));\n-\n-  // Finalize expected data\n-  std::shared_ptr<Array> fsb_array;\n-  ASSERT_OK(fsb_builder.Finish(&fsb_array));\n-\n-  auto dtype = std::make_shared<DictionaryType>(int16(), fsb_array);\n-  std::shared_ptr<Array> int_array;\n-  ASSERT_OK(int_builder.Finish(&int_array));\n-\n-  DictionaryArray expected(dtype, int_array);\n-  ASSERT_TRUE(expected.Equals(result));\n-}\n-\n-// ----------------------------------------------------------------------\n-// List tests\n-\n-class TestListArray : public TestBuilder {\n- public:\n-  void SetUp() {\n-    TestBuilder::SetUp();\n-\n-    value_type_ = int32();\n-    type_ = list(value_type_);\n-\n-    std::unique_ptr<ArrayBuilder> tmp;\n-    ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_.reset(checked_cast<ListBuilder*>(tmp.release()));\n-  }\n-\n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-    result_ = std::dynamic_pointer_cast<ListArray>(out);\n-  }\n-\n- protected:\n-  std::shared_ptr<DataType> value_type_;\n-\n-  std::shared_ptr<ListBuilder> builder_;\n-  std::shared_ptr<ListArray> result_;\n-};\n-\n-TEST_F(TestListArray, Equality) {\n-  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n-\n-  std::shared_ptr<Array> array, equal_array, unequal_array;\n-  vector<int32_t> equal_offsets = {0, 1, 2, 5, 6, 7, 8, 10};\n-  vector<int32_t> equal_values = {1, 2, 3, 4, 5, 2, 2, 2, 5, 6};\n-  vector<int32_t> unequal_offsets = {0, 1, 4, 7};\n-  vector<int32_t> unequal_values = {1, 2, 2, 2, 3, 4, 5};\n-\n-  // setup two equal arrays\n-  ASSERT_OK(builder_->AppendValues(equal_offsets.data(), equal_offsets.size()));\n-  ASSERT_OK(vb->AppendValues(equal_values.data(), equal_values.size()));\n-\n-  ASSERT_OK(builder_->Finish(&array));\n-  ASSERT_OK(builder_->AppendValues(equal_offsets.data(), equal_offsets.size()));\n-  ASSERT_OK(vb->AppendValues(equal_values.data(), equal_values.size()));\n-\n-  ASSERT_OK(builder_->Finish(&equal_array));\n-  // now an unequal one\n-  ASSERT_OK(builder_->AppendValues(unequal_offsets.data(), unequal_offsets.size()));\n-  ASSERT_OK(vb->AppendValues(unequal_values.data(), unequal_values.size()));\n-\n-  ASSERT_OK(builder_->Finish(&unequal_array));\n-\n-  // Test array equality\n-  EXPECT_TRUE(array->Equals(array));\n-  EXPECT_TRUE(array->Equals(equal_array));\n-  EXPECT_TRUE(equal_array->Equals(array));\n-  EXPECT_FALSE(equal_array->Equals(unequal_array));\n-  EXPECT_FALSE(unequal_array->Equals(equal_array));\n-\n-  // Test range equality\n-  EXPECT_TRUE(array->RangeEquals(0, 1, 0, unequal_array));\n-  EXPECT_FALSE(array->RangeEquals(0, 2, 0, unequal_array));\n-  EXPECT_FALSE(array->RangeEquals(1, 2, 1, unequal_array));\n-  EXPECT_TRUE(array->RangeEquals(2, 3, 2, unequal_array));\n-\n-  // Check with slices, ARROW-33\n-  std::shared_ptr<Array> slice, slice2;\n-\n-  slice = array->Slice(2);\n-  slice2 = array->Slice(2);\n-  ASSERT_EQ(array->length() - 2, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(2, slice->length(), 0, slice));\n-\n-  // Chained slices\n-  slice2 = array->Slice(1)->Slice(1);\n-  ASSERT_TRUE(slice->Equals(slice2));\n-\n-  slice = array->Slice(1, 4);\n-  slice2 = array->Slice(1, 4);\n-  ASSERT_EQ(4, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(1, 5, 0, slice));\n-}\n-\n-TEST_F(TestListArray, TestResize) {}\n-\n-TEST_F(TestListArray, TestFromArrays) {\n-  std::shared_ptr<Array> offsets1, offsets2, offsets3, offsets4, values;\n-\n-  std::vector<bool> offsets_is_valid3 = {true, false, true, true};\n-  std::vector<bool> offsets_is_valid4 = {true, true, false, true};\n-\n-  std::vector<bool> values_is_valid = {true, false, true, true, true, true};\n-\n-  std::vector<int32_t> offset1_values = {0, 2, 2, 6};\n-  std::vector<int32_t> offset2_values = {0, 2, 6, 6};\n-\n-  std::vector<int8_t> values_values = {0, 1, 2, 3, 4, 5};\n-  const int length = 3;\n-\n-  ArrayFromVector<Int32Type, int32_t>(offset1_values, &offsets1);\n-  ArrayFromVector<Int32Type, int32_t>(offset2_values, &offsets2);\n-\n-  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid3, offset1_values, &offsets3);\n-  ArrayFromVector<Int32Type, int32_t>(offsets_is_valid4, offset2_values, &offsets4);\n-\n-  ArrayFromVector<Int8Type, int8_t>(values_is_valid, values_values, &values);\n-\n-  auto list_type = list(int8());\n-\n-  std::shared_ptr<Array> list1, list3, list4;\n-  ASSERT_OK(ListArray::FromArrays(*offsets1, *values, pool_, &list1));\n-  ASSERT_OK(ListArray::FromArrays(*offsets3, *values, pool_, &list3));\n-  ASSERT_OK(ListArray::FromArrays(*offsets4, *values, pool_, &list4));\n-\n-  ListArray expected1(list_type, length, offsets1->data()->buffers[1], values,\n-                      offsets1->data()->buffers[0], 0);\n-  AssertArraysEqual(expected1, *list1);\n-\n-  // Use null bitmap from offsets3, but clean offsets from non-null version\n-  ListArray expected3(list_type, length, offsets1->data()->buffers[1], values,\n-                      offsets3->data()->buffers[0], 1);\n-  AssertArraysEqual(expected3, *list3);\n-\n-  // Check that the last offset bit is zero\n-  ASSERT_FALSE(BitUtil::GetBit(list3->null_bitmap()->data(), length + 1));\n-\n-  ListArray expected4(list_type, length, offsets2->data()->buffers[1], values,\n-                      offsets4->data()->buffers[0], 1);\n-  AssertArraysEqual(expected4, *list4);\n-\n-  // Test failure modes\n-\n-  std::shared_ptr<Array> tmp;\n-\n-  // Zero-length offsets\n-  ASSERT_RAISES(Invalid,\n-                ListArray::FromArrays(*offsets1->Slice(0, 0), *values, pool_, &tmp));\n-\n-  // Offsets not int32\n-  ASSERT_RAISES(Invalid, ListArray::FromArrays(*values, *offsets1, pool_, &tmp));\n-}\n-\n-TEST_F(TestListArray, TestAppendNull) {\n-  ASSERT_OK(builder_->AppendNull());\n-  ASSERT_OK(builder_->AppendNull());\n-\n-  Done();\n-\n-  ASSERT_OK(ValidateArray(*result_));\n-  ASSERT_TRUE(result_->IsNull(0));\n-  ASSERT_TRUE(result_->IsNull(1));\n-\n-  ASSERT_EQ(0, result_->raw_value_offsets()[0]);\n-  ASSERT_EQ(0, result_->value_offset(1));\n-  ASSERT_EQ(0, result_->value_offset(2));\n-\n-  auto values = result_->values();\n-  ASSERT_EQ(0, values->length());\n-  // Values buffer should be non-null\n-  ASSERT_NE(nullptr, values->data()->buffers[1]);\n-}\n-\n-void ValidateBasicListArray(const ListArray* result, const vector<int32_t>& values,\n-                            const vector<uint8_t>& is_valid) {\n-  ASSERT_OK(ValidateArray(*result));\n-  ASSERT_EQ(1, result->null_count());\n-  ASSERT_EQ(0, result->values()->null_count());\n-\n-  ASSERT_EQ(3, result->length());\n-  vector<int32_t> ex_offsets = {0, 3, 3, 7};\n-  for (size_t i = 0; i < ex_offsets.size(); ++i) {\n-    ASSERT_EQ(ex_offsets[i], result->value_offset(i));\n-  }\n-\n-  for (int i = 0; i < result->length(); ++i) {\n-    ASSERT_EQ(is_valid[i] == 0, result->IsNull(i));\n-  }\n-\n-  ASSERT_EQ(7, result->values()->length());\n-  auto varr = std::dynamic_pointer_cast<Int32Array>(result->values());\n-\n-  for (size_t i = 0; i < values.size(); ++i) {\n-    ASSERT_EQ(values[i], varr->Value(i));\n-  }\n-}\n-\n-TEST_F(TestListArray, TestBasics) {\n-  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n-  vector<int> lengths = {3, 0, 4};\n-  vector<uint8_t> is_valid = {1, 0, 1};\n-\n-  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n-\n-  ASSERT_OK(builder_->Reserve(lengths.size()));\n-  ASSERT_OK(vb->Reserve(values.size()));\n-\n-  int pos = 0;\n-  for (size_t i = 0; i < lengths.size(); ++i) {\n-    ASSERT_OK(builder_->Append(is_valid[i] > 0));\n-    for (int j = 0; j < lengths[i]; ++j) {\n-      ASSERT_OK(vb->Append(values[pos++]));\n-    }\n-  }\n-\n+TEST_F(TestAdaptiveIntBuilder, TestInt32) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(\n+      builder_->Append(static_cast<int64_t>(std::numeric_limits<int16_t>::max()) + 1));\n   Done();\n-  ValidateBasicListArray(result_.get(), values, is_valid);\n-}\n-\n-TEST_F(TestListArray, BulkAppend) {\n-  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n-  vector<int> lengths = {3, 0, 4};\n-  vector<uint8_t> is_valid = {1, 0, 1};\n-  vector<int32_t> offsets = {0, 3, 3};\n \n-  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n-  ASSERT_OK(vb->Reserve(values.size()));\n+  std::vector<int32_t> expected_values(\n+      {0, static_cast<int32_t>(std::numeric_limits<int16_t>::max()) + 1});\n+  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n-  for (int32_t value : values) {\n-    ASSERT_OK(vb->Append(value));\n-  }\n+  SetUp();\n+  ASSERT_OK(\n+      builder_->Append(static_cast<int64_t>(std::numeric_limits<int16_t>::min()) - 1));\n+  expected_values = {static_cast<int32_t>(std::numeric_limits<int16_t>::min()) - 1};\n   Done();\n-  ValidateBasicListArray(result_.get(), values, is_valid);\n-}\n \n-TEST_F(TestListArray, BulkAppendInvalid) {\n-  vector<int32_t> values = {0, 1, 2, 3, 4, 5, 6};\n-  vector<int> lengths = {3, 0, 4};\n-  vector<uint8_t> is_null = {0, 1, 0};\n-  vector<uint8_t> is_valid = {1, 0, 1};\n-  vector<int32_t> offsets = {0, 2, 4};  // should be 0, 3, 3 given the is_null array\n-\n-  Int32Builder* vb = checked_cast<Int32Builder*>(builder_->value_builder());\n-  ASSERT_OK(vb->Reserve(values.size()));\n-\n-  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n-  ASSERT_OK(builder_->AppendValues(offsets.data(), offsets.size(), is_valid.data()));\n-  for (int32_t value : values) {\n-    ASSERT_OK(vb->Append(value));\n-  }\n+  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int32_t>::max()));\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int32_t>::min()));\n+  expected_values = {std::numeric_limits<int32_t>::max(),\n+                     std::numeric_limits<int32_t>::min()};\n   Done();\n-  ASSERT_RAISES(Invalid, ValidateArray(*result_));\n-}\n \n-TEST_F(TestListArray, TestZeroLength) {\n-  // All buffers are null\n-  Done();\n-  ASSERT_OK(ValidateArray(*result_));\n+  ArrayFromVector<Int32Type, int32_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-// ----------------------------------------------------------------------\n-// DictionaryArray tests\n-\n-TEST(TestDictionary, Basics) {\n-  vector<int32_t> values = {100, 1000, 10000, 100000};\n-  std::shared_ptr<Array> dict;\n-  ArrayFromVector<Int32Type, int32_t>(values, &dict);\n+TEST_F(TestAdaptiveIntBuilder, TestInt64) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(\n+      builder_->Append(static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1));\n+  Done();\n \n-  std::shared_ptr<DictionaryType> type1 =\n-      std::dynamic_pointer_cast<DictionaryType>(dictionary(int16(), dict));\n+  std::vector<int64_t> expected_values(\n+      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n+  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-  auto type2 =\n-      std::dynamic_pointer_cast<DictionaryType>(::arrow::dictionary(int16(), dict, true));\n+  SetUp();\n+  ASSERT_OK(\n+      builder_->Append(static_cast<int64_t>(std::numeric_limits<int32_t>::min()) - 1));\n+  expected_values = {static_cast<int64_t>(std::numeric_limits<int32_t>::min()) - 1};\n+  Done();\n \n-  ASSERT_TRUE(int16()->Equals(type1->index_type()));\n-  ASSERT_TRUE(type1->dictionary()->Equals(dict));\n+  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-  ASSERT_TRUE(int16()->Equals(type2->index_type()));\n-  ASSERT_TRUE(type2->dictionary()->Equals(dict));\n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int64_t>::max()));\n+  ASSERT_OK(builder_->Append(std::numeric_limits<int64_t>::min()));\n+  expected_values = {std::numeric_limits<int64_t>::max(),\n+                     std::numeric_limits<int64_t>::min()};\n+  Done();\n \n-  ASSERT_EQ(\"dictionary<values=int32, indices=int16, ordered=0>\", type1->ToString());\n-  ASSERT_EQ(\"dictionary<values=int32, indices=int16, ordered=1>\", type2->ToString());\n+  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST(TestDictionary, Equals) {\n-  vector<bool> is_valid = {true, true, false, true, true, true};\n-\n-  std::shared_ptr<Array> dict;\n-  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n-  ArrayFromVector<StringType, string>(dict_values, &dict);\n-  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n-\n-  std::shared_ptr<Array> dict2;\n-  vector<string> dict2_values = {\"foo\", \"bar\", \"baz\", \"qux\"};\n-  ArrayFromVector<StringType, string>(dict2_values, &dict2);\n-  std::shared_ptr<DataType> dict2_type = dictionary(int16(), dict2);\n-\n-  std::shared_ptr<Array> indices;\n-  vector<int16_t> indices_values = {1, 2, -1, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid, indices_values, &indices);\n-\n-  std::shared_ptr<Array> indices2;\n-  vector<int16_t> indices2_values = {1, 2, 0, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid, indices2_values, &indices2);\n-\n-  std::shared_ptr<Array> indices3;\n-  vector<int16_t> indices3_values = {1, 1, 0, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid, indices3_values, &indices3);\n-\n-  auto array = std::make_shared<DictionaryArray>(dict_type, indices);\n-  auto array2 = std::make_shared<DictionaryArray>(dict_type, indices2);\n-  auto array3 = std::make_shared<DictionaryArray>(dict2_type, indices);\n-  auto array4 = std::make_shared<DictionaryArray>(dict_type, indices3);\n-\n-  ASSERT_TRUE(array->Equals(array));\n-\n-  // Equal, because the unequal index is masked by null\n-  ASSERT_TRUE(array->Equals(array2));\n-\n-  // Unequal dictionaries\n-  ASSERT_FALSE(array->Equals(array3));\n-\n-  // Unequal indices\n-  ASSERT_FALSE(array->Equals(array4));\n-\n-  // RangeEquals\n-  ASSERT_TRUE(array->RangeEquals(3, 6, 3, array4));\n-  ASSERT_FALSE(array->RangeEquals(1, 3, 1, array4));\n-\n-  // ARROW-33 Test slices\n-  const int64_t size = array->length();\n-\n-  std::shared_ptr<Array> slice, slice2;\n-  slice = array->Array::Slice(2);\n-  slice2 = array->Array::Slice(2);\n-  ASSERT_EQ(size - 2, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(2, array->length(), 0, slice));\n-\n-  // Chained slices\n-  slice2 = array->Array::Slice(1)->Array::Slice(1);\n-  ASSERT_TRUE(slice->Equals(slice2));\n-\n-  slice = array->Slice(1, 3);\n-  slice2 = array->Slice(1, 3);\n-  ASSERT_EQ(3, slice->length());\n+TEST_F(TestAdaptiveIntBuilder, TestAppendValues) {\n+  std::vector<int64_t> expected_values(\n+      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n+  ASSERT_OK(builder_->AppendValues(expected_values.data(), expected_values.size()));\n+  Done();\n \n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(1, 4, 0, slice));\n+  ArrayFromVector<Int64Type, int64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST(TestDictionary, Validate) {\n-  vector<bool> is_valid = {true, true, false, true, true, true};\n-\n-  std::shared_ptr<Array> dict;\n-  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n-  ArrayFromVector<StringType, string>(dict_values, &dict);\n-  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n-\n-  std::shared_ptr<Array> indices;\n-  vector<int16_t> indices_values = {1, 2, 0, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid, indices_values, &indices);\n-\n-  std::shared_ptr<Array> arr = std::make_shared<DictionaryArray>(dict_type, indices);\n-\n-  // Only checking index type for now\n-  ASSERT_OK(ValidateArray(*arr));\n+TEST_F(TestAdaptiveIntBuilder, TestAssertZeroPadded) {\n+  std::vector<int64_t> values(\n+      {0, static_cast<int64_t>(std::numeric_limits<int32_t>::max()) + 1});\n+  ASSERT_OK(builder_->AppendValues(values.data(), values.size()));\n+  Done();\n+}\n \n-  // TODO(wesm) In ARROW-1199, there is now a DCHECK to compare the indices\n-  // type with the dict_type. How can we test for this?\n+TEST_F(TestAdaptiveIntBuilder, TestAppendNull) {\n+  int64_t size = 1000;\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_OK(builder_->AppendNull());\n+  }\n \n-  // std::shared_ptr<Array> indices2;\n-  // vector<float> indices2_values = {1., 2., 0., 0., 2., 0.};\n-  // ArrayFromVector<FloatType, float>(is_valid, indices2_values, &indices2);\n+  Done();\n \n-  // std::shared_ptr<Array> indices3;\n-  // vector<int64_t> indices3_values = {1, 2, 0, 0, 2, 0};\n-  // ArrayFromVector<Int64Type, int64_t>(is_valid, indices3_values, &indices3);\n-  // std::shared_ptr<Array> arr2 = std::make_shared<DictionaryArray>(dict_type, indices2);\n-  // std::shared_ptr<Array> arr3 = std::make_shared<DictionaryArray>(dict_type, indices3);\n-  // ASSERT_OK(ValidateArray(*arr3));\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_TRUE(result_->IsNull(index));\n+  }\n }\n \n-TEST(TestDictionary, FromArray) {\n-  std::shared_ptr<Array> dict;\n-  vector<string> dict_values = {\"foo\", \"bar\", \"baz\"};\n-  ArrayFromVector<StringType, string>(dict_values, &dict);\n-  std::shared_ptr<DataType> dict_type = dictionary(int16(), dict);\n-\n-  std::shared_ptr<Array> indices1;\n-  vector<int16_t> indices_values1 = {1, 2, 0, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(indices_values1, &indices1);\n-\n-  std::shared_ptr<Array> indices2;\n-  vector<int16_t> indices_values2 = {1, 2, 0, 3, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(indices_values2, &indices2);\n-\n-  std::shared_ptr<Array> indices3;\n-  vector<bool> is_valid3 = {true, true, false, true, true, true};\n-  vector<int16_t> indices_values3 = {1, 2, -1, 0, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid3, indices_values3, &indices3);\n-\n-  std::shared_ptr<Array> indices4;\n-  vector<bool> is_valid4 = {true, true, false, true, true, true};\n-  vector<int16_t> indices_values4 = {1, 2, 1, 3, 2, 0};\n-  ArrayFromVector<Int16Type, int16_t>(is_valid4, indices_values4, &indices4);\n-\n-  std::shared_ptr<Array> arr1, arr2, arr3, arr4;\n-  ASSERT_OK(DictionaryArray::FromArrays(dict_type, indices1, &arr1));\n-  ASSERT_RAISES(Invalid, DictionaryArray::FromArrays(dict_type, indices2, &arr2));\n-  ASSERT_OK(DictionaryArray::FromArrays(dict_type, indices3, &arr3));\n-  ASSERT_RAISES(Invalid, DictionaryArray::FromArrays(dict_type, indices4, &arr4));\n-}\n+TEST_F(TestAdaptiveIntBuilder, TestAppendNulls) {\n+  constexpr int64_t size = 10;\n+  const uint8_t valid_bytes[size] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n+  ASSERT_OK(builder_->AppendNulls(valid_bytes, size));\n \n-// ----------------------------------------------------------------------\n-// Struct tests\n-\n-void ValidateBasicStructArray(const StructArray* result,\n-                              const vector<uint8_t>& struct_is_valid,\n-                              const vector<char>& list_values,\n-                              const vector<uint8_t>& list_is_valid,\n-                              const vector<int>& list_lengths,\n-                              const vector<int>& list_offsets,\n-                              const vector<int32_t>& int_values) {\n-  ASSERT_EQ(4, result->length());\n-  ASSERT_OK(ValidateArray(*result));\n-\n-  auto list_char_arr = std::dynamic_pointer_cast<ListArray>(result->field(0));\n-  auto char_arr = std::dynamic_pointer_cast<Int8Array>(list_char_arr->values());\n-  auto int32_arr = std::dynamic_pointer_cast<Int32Array>(result->field(1));\n-\n-  ASSERT_EQ(nullptr, result->GetFieldByName(\"non-existing\"));\n-  ASSERT_TRUE(list_char_arr->Equals(result->GetFieldByName(\"list\")));\n-  ASSERT_TRUE(int32_arr->Equals(result->GetFieldByName(\"int\")));\n-\n-  ASSERT_EQ(0, result->null_count());\n-  ASSERT_EQ(1, list_char_arr->null_count());\n-  ASSERT_EQ(0, int32_arr->null_count());\n-\n-  // List<char>\n-  ASSERT_EQ(4, list_char_arr->length());\n-  ASSERT_EQ(10, list_char_arr->values()->length());\n-  for (size_t i = 0; i < list_offsets.size(); ++i) {\n-    ASSERT_EQ(list_offsets[i], list_char_arr->raw_value_offsets()[i]);\n-  }\n-  for (size_t i = 0; i < list_values.size(); ++i) {\n-    ASSERT_EQ(list_values[i], char_arr->Value(i));\n-  }\n+  Done();\n \n-  // Int32\n-  ASSERT_EQ(4, int32_arr->length());\n-  for (size_t i = 0; i < int_values.size(); ++i) {\n-    ASSERT_EQ(int_values[i], int32_arr->Value(i));\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_EQ(result_->IsValid(index), static_cast<bool>(valid_bytes[index]));\n   }\n }\n \n-// ----------------------------------------------------------------------------------\n-// Struct test\n-class TestStructBuilder : public TestBuilder {\n+class TestAdaptiveUIntBuilder : public TestBuilder {\n  public:\n   void SetUp() {\n     TestBuilder::SetUp();\n-\n-    auto int32_type = int32();\n-    auto char_type = int8();\n-    auto list_type = list(char_type);\n-\n-    vector<std::shared_ptr<DataType>> types = {list_type, int32_type};\n-    vector<std::shared_ptr<Field>> fields;\n-    fields.push_back(field(\"list\", list_type));\n-    fields.push_back(field(\"int\", int32_type));\n-\n-    type_ = struct_(fields);\n-    value_fields_ = fields;\n-\n-    std::unique_ptr<ArrayBuilder> tmp;\n-    ASSERT_OK(MakeBuilder(pool_, type_, &tmp));\n-    builder_.reset(checked_cast<StructBuilder*>(tmp.release()));\n-    ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n+    builder_ = std::make_shared<AdaptiveUIntBuilder>(pool_);\n   }\n \n-  void Done() {\n-    std::shared_ptr<Array> out;\n-    FinishAndCheckPadding(builder_.get(), &out);\n-    result_ = std::dynamic_pointer_cast<StructArray>(out);\n-  }\n+  void Done() { FinishAndCheckPadding(builder_.get(), &result_); }\n \n  protected:\n-  vector<std::shared_ptr<Field>> value_fields_;\n+  std::shared_ptr<AdaptiveUIntBuilder> builder_;\n \n-  std::shared_ptr<StructBuilder> builder_;\n-  std::shared_ptr<StructArray> result_;\n+  std::shared_ptr<Array> expected_;\n+  std::shared_ptr<Array> result_;\n };\n \n-TEST_F(TestStructBuilder, TestAppendNull) {\n-  ASSERT_OK(builder_->AppendNull());\n-  ASSERT_OK(builder_->AppendNull());\n-  ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n-\n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  ASSERT_OK(list_vb->AppendNull());\n-  ASSERT_OK(list_vb->AppendNull());\n-  ASSERT_EQ(2, list_vb->length());\n-\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n-  ASSERT_OK(int_vb->AppendNull());\n-  ASSERT_OK(int_vb->AppendNull());\n-  ASSERT_EQ(2, int_vb->length());\n+TEST_F(TestAdaptiveUIntBuilder, TestUInt8) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(builder_->Append(255));\n \n   Done();\n \n-  ASSERT_OK(ValidateArray(*result_));\n-\n-  ASSERT_EQ(2, static_cast<int>(result_->num_fields()));\n-  ASSERT_EQ(2, result_->length());\n-  ASSERT_EQ(2, result_->field(0)->length());\n-  ASSERT_EQ(2, result_->field(1)->length());\n-  ASSERT_TRUE(result_->IsNull(0));\n-  ASSERT_TRUE(result_->IsNull(1));\n-  ASSERT_TRUE(result_->field(0)->IsNull(0));\n-  ASSERT_TRUE(result_->field(0)->IsNull(1));\n-  ASSERT_TRUE(result_->field(1)->IsNull(0));\n-  ASSERT_TRUE(result_->field(1)->IsNull(1));\n-\n-  ASSERT_EQ(Type::LIST, result_->field(0)->type_id());\n-  ASSERT_EQ(Type::INT32, result_->field(1)->type_id());\n+  std::vector<uint8_t> expected_values({0, 255});\n+  ArrayFromVector<UInt8Type, uint8_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST_F(TestStructBuilder, TestBasics) {\n-  vector<int32_t> int_values = {1, 2, 3, 4};\n-  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n-  vector<int> list_lengths = {3, 0, 3, 4};\n-  vector<int> list_offsets = {0, 3, 3, 6, 10};\n-  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n-  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n-\n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n-  ASSERT_EQ(2, static_cast<int>(builder_->num_fields()));\n-\n-  EXPECT_OK(builder_->Resize(list_lengths.size()));\n-  EXPECT_OK(char_vb->Resize(list_values.size()));\n-  EXPECT_OK(int_vb->Resize(int_values.size()));\n-\n-  int pos = 0;\n-  for (size_t i = 0; i < list_lengths.size(); ++i) {\n-    ASSERT_OK(list_vb->Append(list_is_valid[i] > 0));\n-    int_vb->UnsafeAppend(int_values[i]);\n-    for (int j = 0; j < list_lengths[i]; ++j) {\n-      char_vb->UnsafeAppend(list_values[pos++]);\n-    }\n-  }\n+TEST_F(TestAdaptiveUIntBuilder, TestUInt16) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(builder_->Append(256));\n+  Done();\n \n-  for (size_t i = 0; i < struct_is_valid.size(); ++i) {\n-    ASSERT_OK(builder_->Append(struct_is_valid[i] > 0));\n-  }\n+  std::vector<uint16_t> expected_values({0, 256});\n+  ArrayFromVector<UInt16Type, uint16_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<uint16_t>::max()));\n+  expected_values = {std::numeric_limits<uint16_t>::max()};\n   Done();\n \n-  ValidateBasicStructArray(result_.get(), struct_is_valid, list_values, list_is_valid,\n-                           list_lengths, list_offsets, int_values);\n+  ArrayFromVector<UInt16Type, uint16_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n }\n \n-TEST_F(TestStructBuilder, BulkAppend) {\n-  vector<int32_t> int_values = {1, 2, 3, 4};\n-  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n-  vector<int> list_lengths = {3, 0, 3, 4};\n-  vector<int> list_offsets = {0, 3, 3, 6};\n-  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n-  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n-\n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+TEST_F(TestAdaptiveUIntBuilder, TestUInt32) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(\n+      builder_->Append(static_cast<uint64_t>(std::numeric_limits<uint16_t>::max()) + 1));\n+  Done();\n \n-  ASSERT_OK(builder_->Resize(list_lengths.size()));\n-  ASSERT_OK(char_vb->Resize(list_values.size()));\n-  ASSERT_OK(int_vb->Resize(int_values.size()));\n+  std::vector<uint32_t> expected_values(\n+      {0, static_cast<uint32_t>(std::numeric_limits<uint16_t>::max()) + 1});\n+  ArrayFromVector<UInt32Type, uint32_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<uint32_t>::max()));\n+  expected_values = {std::numeric_limits<uint32_t>::max()};\n+  Done();\n \n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n-  }\n+  ArrayFromVector<UInt32Type, uint32_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n+}\n \n+TEST_F(TestAdaptiveUIntBuilder, TestUInt64) {\n+  ASSERT_OK(builder_->Append(0));\n+  ASSERT_OK(\n+      builder_->Append(static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1));\n   Done();\n-  ValidateBasicStructArray(result_.get(), struct_is_valid, list_values, list_is_valid,\n-                           list_lengths, list_offsets, int_values);\n-}\n \n-TEST_F(TestStructBuilder, BulkAppendInvalid) {\n-  vector<int32_t> int_values = {1, 2, 3, 4};\n-  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n-  vector<int> list_lengths = {3, 0, 3, 4};\n-  vector<int> list_offsets = {0, 3, 3, 6};\n-  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n-  vector<uint8_t> struct_is_valid = {1, 0, 1, 1};  // should be 1, 1, 1, 1\n+  std::vector<uint64_t> expected_values(\n+      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n+  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n \n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n+  SetUp();\n+  ASSERT_OK(builder_->Append(std::numeric_limits<uint64_t>::max()));\n+  expected_values = {std::numeric_limits<uint64_t>::max()};\n+  Done();\n \n-  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n-  ASSERT_OK(char_vb->Reserve(list_values.size()));\n-  ASSERT_OK(int_vb->Reserve(int_values.size()));\n+  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n+}\n \n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n+TEST_F(TestAdaptiveUIntBuilder, TestAppendValues) {\n+  std::vector<uint64_t> expected_values(\n+      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n+  ASSERT_OK(builder_->AppendValues(expected_values.data(), expected_values.size()));\n+  Done();\n \n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n-  }\n+  ArrayFromVector<UInt64Type, uint64_t>(expected_values, &expected_);\n+  ASSERT_TRUE(expected_->Equals(result_));\n+}\n \n+TEST_F(TestAdaptiveUIntBuilder, TestAssertZeroPadded) {\n+  std::vector<uint64_t> values(\n+      {0, static_cast<uint64_t>(std::numeric_limits<uint32_t>::max()) + 1});\n+  ASSERT_OK(builder_->AppendValues(values.data(), values.size()));\n   Done();\n-  // Even null bitmap of the parent Struct is not valid, validate will ignore it.\n-  ASSERT_OK(ValidateArray(*result_));\n }\n \n-TEST_F(TestStructBuilder, TestEquality) {\n-  std::shared_ptr<Array> array, equal_array;\n-  std::shared_ptr<Array> unequal_bitmap_array, unequal_offsets_array,\n-      unequal_values_array;\n-\n-  vector<int32_t> int_values = {101, 102, 103, 104};\n-  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n-  vector<int> list_lengths = {3, 0, 3, 4};\n-  vector<int> list_offsets = {0, 3, 3, 6};\n-  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n-  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n-\n-  vector<int32_t> unequal_int_values = {104, 102, 103, 101};\n-  vector<char> unequal_list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'l', 'u', 'c', 'y'};\n-  vector<int> unequal_list_offsets = {0, 3, 4, 6};\n-  vector<uint8_t> unequal_list_is_valid = {1, 1, 1, 1};\n-  vector<uint8_t> unequal_struct_is_valid = {1, 0, 0, 1};\n-\n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n-  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n-  ASSERT_OK(char_vb->Reserve(list_values.size()));\n-  ASSERT_OK(int_vb->Reserve(int_values.size()));\n-\n-  // setup two equal arrays, one of which takes an unequal bitmap\n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n-  }\n-\n-  FinishAndCheckPadding(builder_.get(), &array);\n-\n-  ASSERT_OK(builder_->Resize(list_lengths.size()));\n-  ASSERT_OK(char_vb->Resize(list_values.size()));\n-  ASSERT_OK(int_vb->Resize(int_values.size()));\n-\n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n-  }\n-\n-  ASSERT_OK(builder_->Finish(&equal_array));\n-\n-  ASSERT_OK(builder_->Resize(list_lengths.size()));\n-  ASSERT_OK(char_vb->Resize(list_values.size()));\n-  ASSERT_OK(int_vb->Resize(int_values.size()));\n-\n-  // setup an unequal one with the unequal bitmap\n-  ASSERT_OK(builder_->AppendValues(unequal_struct_is_valid.size(),\n-                                   unequal_struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n-  }\n-\n-  ASSERT_OK(builder_->Finish(&unequal_bitmap_array));\n-\n-  ASSERT_OK(builder_->Resize(list_lengths.size()));\n-  ASSERT_OK(char_vb->Resize(list_values.size()));\n-  ASSERT_OK(int_vb->Resize(int_values.size()));\n-\n-  // setup an unequal one with unequal offsets\n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(unequal_list_offsets.data(),\n-                                  unequal_list_offsets.size(),\n-                                  unequal_list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n+TEST_F(TestAdaptiveUIntBuilder, TestAppendNull) {\n+  int64_t size = 1000;\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_OK(builder_->AppendNull());\n   }\n \n-  ASSERT_OK(builder_->Finish(&unequal_offsets_array));\n-\n-  ASSERT_OK(builder_->Resize(list_lengths.size()));\n-  ASSERT_OK(char_vb->Resize(list_values.size()));\n-  ASSERT_OK(int_vb->Resize(int_values.size()));\n+  Done();\n \n-  // setup anunequal one with unequal values\n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : unequal_list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : unequal_int_values) {\n-    int_vb->UnsafeAppend(value);\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_TRUE(result_->IsNull(index));\n   }\n-\n-  ASSERT_OK(builder_->Finish(&unequal_values_array));\n-\n-  // Test array equality\n-  EXPECT_TRUE(array->Equals(array));\n-  EXPECT_TRUE(array->Equals(equal_array));\n-  EXPECT_TRUE(equal_array->Equals(array));\n-  EXPECT_FALSE(equal_array->Equals(unequal_bitmap_array));\n-  EXPECT_FALSE(unequal_bitmap_array->Equals(equal_array));\n-  EXPECT_FALSE(unequal_bitmap_array->Equals(unequal_values_array));\n-  EXPECT_FALSE(unequal_values_array->Equals(unequal_bitmap_array));\n-  EXPECT_FALSE(unequal_bitmap_array->Equals(unequal_offsets_array));\n-  EXPECT_FALSE(unequal_offsets_array->Equals(unequal_bitmap_array));\n-\n-  // Test range equality\n-  EXPECT_TRUE(array->RangeEquals(0, 4, 0, equal_array));\n-  EXPECT_TRUE(array->RangeEquals(3, 4, 3, unequal_bitmap_array));\n-  EXPECT_TRUE(array->RangeEquals(0, 1, 0, unequal_offsets_array));\n-  EXPECT_FALSE(array->RangeEquals(0, 2, 0, unequal_offsets_array));\n-  EXPECT_FALSE(array->RangeEquals(1, 2, 1, unequal_offsets_array));\n-  EXPECT_FALSE(array->RangeEquals(0, 1, 0, unequal_values_array));\n-  EXPECT_TRUE(array->RangeEquals(1, 3, 1, unequal_values_array));\n-  EXPECT_FALSE(array->RangeEquals(3, 4, 3, unequal_values_array));\n }\n \n-TEST_F(TestStructBuilder, TestZeroLength) {\n-  // All buffers are null\n+TEST_F(TestAdaptiveUIntBuilder, TestAppendNulls) {\n+  constexpr int64_t size = 10;\n+  const uint8_t valid_bytes[size] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n+  ASSERT_OK(builder_->AppendNulls(valid_bytes, size));\n+\n   Done();\n-  ASSERT_OK(ValidateArray(*result_));\n-}\n \n-TEST_F(TestStructBuilder, TestSlice) {\n-  std::shared_ptr<Array> array, equal_array;\n-  std::shared_ptr<Array> unequal_bitmap_array, unequal_offsets_array,\n-      unequal_values_array;\n-\n-  vector<int32_t> int_values = {101, 102, 103, 104};\n-  vector<char> list_values = {'j', 'o', 'e', 'b', 'o', 'b', 'm', 'a', 'r', 'k'};\n-  vector<int> list_lengths = {3, 0, 3, 4};\n-  vector<int> list_offsets = {0, 3, 3, 6};\n-  vector<uint8_t> list_is_valid = {1, 0, 1, 1};\n-  vector<uint8_t> struct_is_valid = {1, 1, 1, 1};\n-\n-  ListBuilder* list_vb = checked_cast<ListBuilder*>(builder_->field_builder(0));\n-  Int8Builder* char_vb = checked_cast<Int8Builder*>(list_vb->value_builder());\n-  Int32Builder* int_vb = checked_cast<Int32Builder*>(builder_->field_builder(1));\n-  ASSERT_OK(builder_->Reserve(list_lengths.size()));\n-  ASSERT_OK(char_vb->Reserve(list_values.size()));\n-  ASSERT_OK(int_vb->Reserve(int_values.size()));\n-\n-  ASSERT_OK(builder_->AppendValues(struct_is_valid.size(), struct_is_valid.data()));\n-  ASSERT_OK(list_vb->AppendValues(list_offsets.data(), list_offsets.size(),\n-                                  list_is_valid.data()));\n-  for (int8_t value : list_values) {\n-    char_vb->UnsafeAppend(value);\n-  }\n-  for (int32_t value : int_values) {\n-    int_vb->UnsafeAppend(value);\n+  for (unsigned index = 0; index < size; ++index) {\n+    ASSERT_EQ(result_->IsValid(index), static_cast<bool>(valid_bytes[index]));\n   }\n-  FinishAndCheckPadding(builder_.get(), &array);\n-\n-  std::shared_ptr<StructArray> slice, slice2;\n-  std::shared_ptr<Int32Array> int_field;\n-  std::shared_ptr<ListArray> list_field;\n-\n-  slice = std::dynamic_pointer_cast<StructArray>(array->Slice(2));\n-  slice2 = std::dynamic_pointer_cast<StructArray>(array->Slice(2));\n-  ASSERT_EQ(array->length() - 2, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(2, slice->length(), 0, slice));\n-\n-  int_field = std::dynamic_pointer_cast<Int32Array>(slice->field(1));\n-  ASSERT_EQ(int_field->length(), slice->length());\n-  ASSERT_EQ(int_field->Value(0), 103);\n-  ASSERT_EQ(int_field->Value(1), 104);\n-  ASSERT_EQ(int_field->null_count(), 0);\n-  list_field = std::dynamic_pointer_cast<ListArray>(slice->field(0));\n-  ASSERT_FALSE(list_field->IsNull(0));\n-  ASSERT_FALSE(list_field->IsNull(1));\n-  ASSERT_EQ(list_field->value_length(0), 3);\n-  ASSERT_EQ(list_field->value_length(1), 4);\n-  ASSERT_EQ(list_field->null_count(), 0);\n-\n-  slice = std::dynamic_pointer_cast<StructArray>(array->Slice(1, 2));\n-  slice2 = std::dynamic_pointer_cast<StructArray>(array->Slice(1, 2));\n-  ASSERT_EQ(2, slice->length());\n-\n-  ASSERT_TRUE(slice->Equals(slice2));\n-  ASSERT_TRUE(array->RangeEquals(1, 3, 0, slice));\n-\n-  int_field = std::dynamic_pointer_cast<Int32Array>(slice->field(1));\n-  ASSERT_EQ(int_field->length(), slice->length());\n-  ASSERT_EQ(int_field->Value(0), 102);\n-  ASSERT_EQ(int_field->Value(1), 103);\n-  ASSERT_EQ(int_field->null_count(), 0);\n-  list_field = std::dynamic_pointer_cast<ListArray>(slice->field(0));\n-  ASSERT_TRUE(list_field->IsNull(0));\n-  ASSERT_FALSE(list_field->IsNull(1));\n-  ASSERT_EQ(list_field->value_length(0), 0);\n-  ASSERT_EQ(list_field->value_length(1), 3);\n-  ASSERT_EQ(list_field->null_count(), 1);\n }\n \n // ----------------------------------------------------------------------\ndiff --git a/cpp/src/arrow/test-common.h b/cpp/src/arrow/test-common.h\nindex 9cd8ffd364..eecdd90ac8 100644\n--- a/cpp/src/arrow/test-common.h\n+++ b/cpp/src/arrow/test-common.h\n@@ -54,7 +54,7 @@ class TestBase : public ::testing::Test {\n   }\n \n   template <typename ArrayType>\n-  std::shared_ptr<Array> MakeRandomArray(int64_t length, int64_t null_count = 0);\n+  inline std::shared_ptr<Array> MakeRandomArray(int64_t length, int64_t null_count = 0);\n \n  protected:\n   uint32_t random_seed_;\n@@ -75,13 +75,13 @@ std::shared_ptr<Array> TestBase::MakeRandomArray(int64_t length, int64_t null_co\n }\n \n template <>\n-std::shared_ptr<Array> TestBase::MakeRandomArray<NullArray>(int64_t length,\n-                                                            int64_t null_count) {\n+inline std::shared_ptr<Array> TestBase::MakeRandomArray<NullArray>(int64_t length,\n+                                                                   int64_t null_count) {\n   return std::make_shared<NullArray>(length);\n }\n \n template <>\n-std::shared_ptr<Array> TestBase::MakeRandomArray<FixedSizeBinaryArray>(\n+inline std::shared_ptr<Array> TestBase::MakeRandomArray<FixedSizeBinaryArray>(\n     int64_t length, int64_t null_count) {\n   const int byte_width = 10;\n   std::shared_ptr<Buffer> null_bitmap = MakeRandomNullBitmap(length, null_count);\n@@ -94,8 +94,8 @@ std::shared_ptr<Array> TestBase::MakeRandomArray<FixedSizeBinaryArray>(\n }\n \n template <>\n-std::shared_ptr<Array> TestBase::MakeRandomArray<BinaryArray>(int64_t length,\n-                                                              int64_t null_count) {\n+inline std::shared_ptr<Array> TestBase::MakeRandomArray<BinaryArray>(int64_t length,\n+                                                                     int64_t null_count) {\n   std::vector<uint8_t> valid_bytes(length, 1);\n   for (int64_t i = 0; i < null_count; i++) {\n     valid_bytes[i * 2] = 0;\ndiff --git a/cpp/src/arrow/test-util.cc b/cpp/src/arrow/test-util.cc\nindex 60e5fd39d5..84c76ee1ae 100644\n--- a/cpp/src/arrow/test-util.cc\n+++ b/cpp/src/arrow/test-util.cc\n@@ -296,4 +296,30 @@ void CompareBatch(const RecordBatch& left, const RecordBatch& right) {\n   }\n }\n \n+namespace {\n+\n+// Used to prevent compiler optimizing away side-effect-less statements\n+volatile int throw_away = 0;\n+\n+}  // namespace\n+\n+void AssertZeroPadded(const Array& array) {\n+  for (const auto& buffer : array.data()->buffers) {\n+    if (buffer) {\n+      const int64_t padding = buffer->capacity() - buffer->size();\n+      std::vector<uint8_t> zeros(padding);\n+      ASSERT_EQ(0, memcmp(buffer->data() + buffer->size(), zeros.data(), padding));\n+    }\n+  }\n+}\n+\n+void TestInitialized(const Array& array) {\n+  for (const auto& buffer : array.data()->buffers) {\n+    if (buffer) {\n+      std::vector<uint8_t> zeros(buffer->capacity());\n+      throw_away = memcmp(buffer->data(), zeros.data(), buffer->size());\n+    }\n+  }\n+}\n+\n }  // namespace arrow\ndiff --git a/cpp/src/arrow/test-util.h b/cpp/src/arrow/test-util.h\nindex 7cab89ea60..950cf02a05 100644\n--- a/cpp/src/arrow/test-util.h\n+++ b/cpp/src/arrow/test-util.h\n@@ -192,6 +192,21 @@ ARROW_EXPORT void AssertTablesEqual(const Table& expected, const Table& actual,\n \n ARROW_EXPORT void CompareBatch(const RecordBatch& left, const RecordBatch& right);\n \n+// Check if the padding of the buffers of the array is zero.\n+// Also cause valgrind warnings if the padding bytes are uninitialized.\n+ARROW_EXPORT void AssertZeroPadded(const Array& array);\n+\n+// Check if the valid buffer bytes are initialized\n+// and cause valgrind warnings otherwise.\n+ARROW_EXPORT void TestInitialized(const Array& array);\n+\n+template <typename BuilderType>\n+void FinishAndCheckPadding(BuilderType* builder, std::shared_ptr<Array>* out) {\n+  ASSERT_OK(builder->Finish(out));\n+  AssertZeroPadded(**out);\n+  TestInitialized(**out);\n+}\n+\n template <typename T, typename U>\n void rand_uniform_int(int64_t n, uint32_t seed, T min_value, T max_value, U* out) {\n   DCHECK(out || (n == 0));\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-11-29T15:40:40.046+0000",
                    "updated": "2018-11-29T15:40:40.046+0000",
                    "started": "2018-11-29T15:40:40.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "170675",
                    "issueId": "13182901"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 9600,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@5d6e63a0[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7a16a7ff[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2ce714f7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@638177cb[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ebcaabc[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2c772084[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@38a3d951[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@5074cea1[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4b067759[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@5e600dbd[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@782f3e71[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@e58f613[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 9600,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Nov 29 15:40:27 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-11-29T15:40:27.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-3169/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-09-04T19:33:48.000+0000",
        "updated": "2018-11-29T15:43:43.000+0000",
        "timeoriginalestimate": null,
        "description": "To improve readability I suggest splitting array-test.cc into multiple compilation units (which will still be linked into an executable {{array-test}}). We can do the same thing with array.h/array.cc, while maintaining the {{arrow/array.h}} public header. Some of these could go into {{arrow/columnar}} or {{arrow/impl}}, or something similar. ",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "2h 40m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 9600
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Break array-test.cc and array.cc into multiple compilation units",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/comment/16702089",
                    "id": "16702089",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "{{builder.cc}} is also a good candidate for splitting up (recompiling it takes several seconds here).",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-11-28T16:18:28.639+0000",
                    "updated": "2018-11-28T17:25:39.995+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13182901/comment/16703371",
                    "id": "16703371",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 3047\n[https://github.com/apache/arrow/pull/3047]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-11-29T15:40:27.058+0000",
                    "updated": "2018-11-29T15:40:27.058+0000"
                }
            ],
            "maxResults": 2,
            "total": 2,
            "startAt": 0
        },
        "customfield_12311820": "0|i3xq07:",
        "customfield_12314139": null
    }
}