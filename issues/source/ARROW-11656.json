{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13358945",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945",
    "key": "ARROW-11656",
    "fields": {
        "parent": {
            "id": "13352985",
            "key": "ARROW-11298",
            "self": "https://issues.apache.org/jira/rest/api/2/issue/13352985",
            "fields": {
                "summary": "[Rust][DataFusion] Implement Postgres String Functions",
                "status": {
                    "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                    "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                    "name": "Closed",
                    "id": "6",
                    "statusCategory": {
                        "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                        "id": 3,
                        "key": "done",
                        "colorName": "green",
                        "name": "Done"
                    }
                },
                "priority": {
                    "self": "https://issues.apache.org/jira/rest/api/2/priority/4",
                    "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/minor.svg",
                    "name": "Minor",
                    "id": "4"
                },
                "issuetype": {
                    "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                    "id": "2",
                    "description": "A new feature of the product, which has yet to be developed.",
                    "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                    "name": "New Feature",
                    "subtask": false,
                    "avatarId": 21141
                }
            }
        },
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12349493",
                "id": "12349493",
                "description": "",
                "name": "4.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-04-26"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=MikeSeddonAU",
            "name": "MikeSeddonAU",
            "key": "mikeseddonau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Mike Seddon",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12335005",
                "id": "12335005",
                "name": "Rust - DataFusion"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=MikeSeddonAU",
            "name": "MikeSeddonAU",
            "key": "mikeseddonau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Mike Seddon",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=MikeSeddonAU",
            "name": "MikeSeddonAU",
            "key": "mikeseddonau",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
            },
            "displayName": "Mike Seddon",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 18000,
            "total": 18000,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 18000,
            "total": 18000,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11656/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 30,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562071",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 opened a new pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654\n\n\n   @alamb the last one (for now).\r\n   \r\n   This PR does a few things:\r\n   \r\n   - adds `regexp_replace`, `replace`, `split_part`, `starts_with`, `strpos` and `translate`.\r\n   - adds feature flag `unicode_expressions` and moves anything that depends on `unicode-segmentation` crate into it.\r\n   - adds feature flag `regex_expressions` and adds `regex` and `lazy_static` crates to it.\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-07T23:25:50.402+0000",
                    "updated": "2021-03-07T23:25:50.402+0000",
                    "started": "2021-03-07T23:25:50.402+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562071",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562073",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#issuecomment-792373859\n\n\n   https://issues.apache.org/jira/browse/ARROW-11656\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-07T23:26:07.236+0000",
                    "updated": "2021-03-07T23:26:07.236+0000",
                    "started": "2021-03-07T23:26:07.236+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562073",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562413",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#issuecomment-792833070\n\n\n   Thanks @seddonm1  -- I'll plan to  look at this later today or tomorrow\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T15:30:28.456+0000",
                    "updated": "2021-03-08T15:30:28.456+0000",
                    "started": "2021-03-08T15:30:28.456+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562413",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562604",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589757540\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n+                    (_, None, _) => None,\n+                    (_, _, None) => None,\n+                    (Some(string), Some(length), Some(fill)) => {\n+                        let length = length as usize;\n+\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n\nReview comment:\n       Is `String` necessary or could we use `&str` in those iterators? (to avoid an extra allocation per item)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:23:06.814+0000",
                    "updated": "2021-03-08T21:23:06.814+0000",
                    "started": "2021-03-08T21:23:06.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562604",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562607",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589759764\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n\nReview comment:\n       For any `unwrap()` I think it makes sense to put a comment why the unwrap is ok, and/or use `.expect`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:26:57.043+0000",
                    "updated": "2021-03-08T21:26:57.043+0000",
                    "started": "2021-03-08T21:26:57.043+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562607",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562609",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589762124\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/string_expressions.rs\n##########\n@@ -621,139 +463,28 @@ pub fn repeat<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     Ok(Arc::new(result) as ArrayRef)\n }\n \n-/// Reverses the order of the characters in the string.\n-/// reverse('abcde') = 'edcba'\n-pub fn reverse<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+/// Replaces all occurrences in string of substring from with substring to.\n+/// replace('abcdefabcdef', 'cd', 'XX') = 'abXXefabXXef'\n+pub fn replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let from_array = downcast_string_arg!(args[1], \"from\", T);\n+    let to_array = downcast_string_arg!(args[2], \"to\", T);\n \n     let result = string_array\n         .iter()\n-        .map(|string| {\n-            string.map(|string: &str| string.graphemes(true).rev().collect::<String>())\n+        .zip(from_array.iter())\n+        .zip(to_array.iter())\n+        .map(|((string, from), to)| match (string, from, to) {\n+            (None, _, _) => None,\n\nReview comment:\n       Those cases can be converted to one wildcard case below\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:30:55.945+0000",
                    "updated": "2021-03-08T21:30:55.945+0000",
                    "started": "2021-03-08T21:30:55.945+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562609",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562610",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589762510\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/string_expressions.rs\n##########\n@@ -794,85 +525,57 @@ pub fn rtrim<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     }\n }\n \n-/// Extracts the substring of string starting at the start'th character, and extending for count characters if that is specified. (Same as substring(string from start for count).)\n-/// substr('alphabet', 3) = 'phabet'\n-/// substr('alphabet', 3, 2) = 'ph'\n-pub fn substr<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n-    match args.len() {\n-        2 => {\n-            let string_array = downcast_string_arg!(args[0], \"string\", T);\n-            let start_array = downcast_arg!(args[1], \"start\", Int64Array);\n+/// Splits string at occurrences of delimiter and returns the n'th field (counting from one).\n+/// split_part('abc~@~def~@~ghi', '~@~', 2) = 'def'\n+pub fn split_part<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let delimiter_array = downcast_string_arg!(args[1], \"delimiter\", T);\n+    let n_array = downcast_arg!(args[2], \"n\", Int64Array);\n \n-            let result = string_array\n-                .iter()\n-                .zip(start_array.iter())\n-                .map(|(string, start)| match (string, start) {\n-                    (None, _) => None,\n-                    (_, None) => None,\n-                    (Some(string), Some(start)) => {\n-                        if start <= 0 {\n-                            Some(string.to_string())\n-                        } else {\n-                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n-                            let start_pos = start as usize - 1;\n-                            if graphemes.len() < start_pos {\n-                                Some(\"\".to_string())\n-                            } else {\n-                                Some(graphemes[start_pos..].concat())\n-                            }\n-                        }\n+    let result = string_array\n+        .iter()\n+        .zip(delimiter_array.iter())\n+        .zip(n_array.iter())\n+        .map(|((string, delimiter), n)| match (string, delimiter, n) {\n+            (None, _, _) => Ok(None),\n\nReview comment:\n       Here the same, could be `_ -> None`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:31:28.911+0000",
                    "updated": "2021-03-08T21:31:28.911+0000",
                    "started": "2021-03-08T21:31:28.910+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562610",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562611",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589762510\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/string_expressions.rs\n##########\n@@ -794,85 +525,57 @@ pub fn rtrim<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     }\n }\n \n-/// Extracts the substring of string starting at the start'th character, and extending for count characters if that is specified. (Same as substring(string from start for count).)\n-/// substr('alphabet', 3) = 'phabet'\n-/// substr('alphabet', 3, 2) = 'ph'\n-pub fn substr<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n-    match args.len() {\n-        2 => {\n-            let string_array = downcast_string_arg!(args[0], \"string\", T);\n-            let start_array = downcast_arg!(args[1], \"start\", Int64Array);\n+/// Splits string at occurrences of delimiter and returns the n'th field (counting from one).\n+/// split_part('abc~@~def~@~ghi', '~@~', 2) = 'def'\n+pub fn split_part<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let delimiter_array = downcast_string_arg!(args[1], \"delimiter\", T);\n+    let n_array = downcast_arg!(args[2], \"n\", Int64Array);\n \n-            let result = string_array\n-                .iter()\n-                .zip(start_array.iter())\n-                .map(|(string, start)| match (string, start) {\n-                    (None, _) => None,\n-                    (_, None) => None,\n-                    (Some(string), Some(start)) => {\n-                        if start <= 0 {\n-                            Some(string.to_string())\n-                        } else {\n-                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n-                            let start_pos = start as usize - 1;\n-                            if graphemes.len() < start_pos {\n-                                Some(\"\".to_string())\n-                            } else {\n-                                Some(graphemes[start_pos..].concat())\n-                            }\n-                        }\n+    let result = string_array\n+        .iter()\n+        .zip(delimiter_array.iter())\n+        .zip(n_array.iter())\n+        .map(|((string, delimiter), n)| match (string, delimiter, n) {\n+            (None, _, _) => Ok(None),\n\nReview comment:\n       Here the same, could be `_ -> Ok(None)`\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:31:51.935+0000",
                    "updated": "2021-03-08T21:31:51.935+0000",
                    "started": "2021-03-08T21:31:51.935+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562611",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562612",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589762868\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/string_expressions.rs\n##########\n@@ -794,85 +525,57 @@ pub fn rtrim<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     }\n }\n \n-/// Extracts the substring of string starting at the start'th character, and extending for count characters if that is specified. (Same as substring(string from start for count).)\n-/// substr('alphabet', 3) = 'phabet'\n-/// substr('alphabet', 3, 2) = 'ph'\n-pub fn substr<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n-    match args.len() {\n-        2 => {\n-            let string_array = downcast_string_arg!(args[0], \"string\", T);\n-            let start_array = downcast_arg!(args[1], \"start\", Int64Array);\n+/// Splits string at occurrences of delimiter and returns the n'th field (counting from one).\n+/// split_part('abc~@~def~@~ghi', '~@~', 2) = 'def'\n+pub fn split_part<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let delimiter_array = downcast_string_arg!(args[1], \"delimiter\", T);\n+    let n_array = downcast_arg!(args[2], \"n\", Int64Array);\n \n-            let result = string_array\n-                .iter()\n-                .zip(start_array.iter())\n-                .map(|(string, start)| match (string, start) {\n-                    (None, _) => None,\n-                    (_, None) => None,\n-                    (Some(string), Some(start)) => {\n-                        if start <= 0 {\n-                            Some(string.to_string())\n-                        } else {\n-                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n-                            let start_pos = start as usize - 1;\n-                            if graphemes.len() < start_pos {\n-                                Some(\"\".to_string())\n-                            } else {\n-                                Some(graphemes[start_pos..].concat())\n-                            }\n-                        }\n+    let result = string_array\n+        .iter()\n+        .zip(delimiter_array.iter())\n+        .zip(n_array.iter())\n+        .map(|((string, delimiter), n)| match (string, delimiter, n) {\n+            (None, _, _) => Ok(None),\n+            (_, None, _) => Ok(None),\n+            (_, _, None) => Ok(None),\n+            (Some(string), Some(delimiter), Some(n)) => {\n+                if n <= 0 {\n+                    Err(DataFusionError::Execution(\n+                        \"field position must be greater than zero\".to_string(),\n+                    ))\n+                } else {\n+                    let split_string: Vec<&str> = string.split(delimiter).collect();\n+                    match split_string.get(n as usize - 1) {\n+                        Some(s) => Ok(Some(*s)),\n+                        None => Ok(Some(\"\")),\n                     }\n-                })\n-                .collect::<GenericStringArray<T>>();\n+                }\n+            }\n+        })\n+        .collect::<Result<GenericStringArray<T>>>()?;\n \n-            Ok(Arc::new(result) as ArrayRef)\n-        }\n-        3 => {\n-            let string_array = downcast_string_arg!(args[0], \"string\", T);\n-            let start_array = downcast_arg!(args[1], \"start\", Int64Array);\n-            let count_array = downcast_arg!(args[2], \"count\", Int64Array);\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n \n-            let result = string_array\n-                .iter()\n-                .zip(start_array.iter())\n-                .zip(count_array.iter())\n-                .map(|((string, start), count)| match (string, start, count) {\n-                    (None, _, _) => Ok(None),\n-                    (_, None, _) => Ok(None),\n-                    (_, _, None) => Ok(None),\n-                    (Some(string), Some(start), Some(count)) => {\n-                        if count < 0 {\n-                            Err(DataFusionError::Execution(\n-                                \"negative substring length not allowed\".to_string(),\n-                            ))\n-                        } else if start <= 0 {\n-                            Ok(Some(string.to_string()))\n-                        } else {\n-                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n-                            let start_pos = start as usize - 1;\n-                            let count_usize = count as usize;\n-                            if graphemes.len() < start_pos {\n-                                Ok(Some(\"\".to_string()))\n-                            } else if graphemes.len() < start_pos + count_usize {\n-                                Ok(Some(graphemes[start_pos..].concat()))\n-                            } else {\n-                                Ok(Some(\n-                                    graphemes[start_pos..start_pos + count_usize]\n-                                        .concat(),\n-                                ))\n-                            }\n-                        }\n-                    }\n-                })\n-                .collect::<Result<GenericStringArray<T>>>()?;\n+/// Returns true if string starts with prefix.\n+/// starts_with('alphabet', 'alph') = 't'\n+pub fn starts_with<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let prefix_array = downcast_string_arg!(args[1], \"prefix\", T);\n \n-            Ok(Arc::new(result) as ArrayRef)\n-        }\n-        other => Err(DataFusionError::Internal(format!(\n-            \"substr was called with {} arguments. It requires 2 or 3.\",\n-            other\n-        ))),\n-    }\n+    let result = string_array\n+        .iter()\n+        .zip(prefix_array.iter())\n+        .map(|(string, prefix)| match (string, prefix) {\n+            (None, _) => None,\n+            (_, None) => None,\n\nReview comment:\n       Same as above\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:32:14.823+0000",
                    "updated": "2021-03-08T21:32:14.823+0000",
                    "started": "2021-03-08T21:32:14.823+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562612",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562613",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589763204\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n\nReview comment:\n       You got the idea \ud83d\ude03\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:32:47.754+0000",
                    "updated": "2021-03-08T21:32:47.754+0000",
                    "started": "2021-03-08T21:32:47.754+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562613",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562614",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589765978\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n\nReview comment:\n       I think at some point this could be in arrow (and more parts of your string contributions).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:37:33.824+0000",
                    "updated": "2021-03-08T21:37:33.824+0000",
                    "started": "2021-03-08T21:37:33.823+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562614",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562622",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "Dandandan commented on pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#issuecomment-793107168\n\n\n   Truly looks great @seddonm1 I added some comments \n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T21:53:04.110+0000",
                    "updated": "2021-03-08T21:53:04.110+0000",
                    "started": "2021-03-08T21:53:04.110+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562622",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562639",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#issuecomment-793121615\n\n\n   Integration test failure looked like https://issues.apache.org/jira/browse/ARROW-11908 so I retriggered the CI checks\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:16:32.348+0000",
                    "updated": "2021-03-08T22:16:32.348+0000",
                    "started": "2021-03-08T22:16:32.347+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562639",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562668",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "alamb commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589789458\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/functions.rs\n##########\n@@ -494,6 +532,27 @@ pub fn return_type(\n                 ));\n             }\n         }),\n+        BuiltinScalarFunction::SplitPart => Ok(match arg_types[0] {\n+            DataType::LargeUtf8 => DataType::LargeUtf8,\n+            DataType::Utf8 => DataType::Utf8,\n+            _ => {\n+                // this error is internal as `data_types` should have captured this.\n+                return Err(DataFusionError::Internal(\n+                    \"The split_part function can only accept strings.\".to_string(),\n+                ));\n+            }\n+        }),\n+        BuiltinScalarFunction::StartsWith => Ok(DataType::Boolean),\n\nReview comment:\n       I wonder if there is a reason not to check the arg types of `starts_with` given we are checking all the others?\n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    // creating Regex is expensive so create hashmap for memoization\n+    let mut patterns: HashMap<String, Regex> = HashMap::new();\n\nReview comment:\n       \ud83d\udc4d \n\n##########\nFile path: rust/datafusion/Cargo.toml\n##########\n@@ -40,10 +40,12 @@ name = \"datafusion-cli\"\n path = \"src/bin/main.rs\"\n \n [features]\n-default = [\"cli\", \"crypto_expressions\"]\n+default = [\"cli\", \"crypto_expressions\", \"regex_expressions\", \"unicode_expressions\"]\n cli = [\"rustyline\"]\n simd = [\"arrow/simd\"]\n crypto_expressions = [\"md-5\", \"sha2\"]\n+regex_expressions = [\"regex\", \"lazy_static\"]\n+unicode_expressions = [\"unicode-segmentation\"]\n\nReview comment:\n       \u2764\ufe0f \n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n+                    (_, None, _) => None,\n+                    (_, _, None) => None,\n+                    (Some(string), Some(length), Some(fill)) => {\n+                        let length = length as usize;\n+\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            let fill_chars = fill.chars().collect::<Vec<char>>();\n+\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else if fill_chars.is_empty() {\n+                                Some(string.to_string())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                let mut char_vector =\n+                                    Vec::<char>::with_capacity(length - graphemes.len());\n+                                for l in 0..length - graphemes.len() {\n+                                    char_vector.push(\n+                                        *fill_chars.get(l % fill_chars.len()).unwrap(),\n+                                    );\n+                                }\n+                                s.insert_str(\n+                                    0,\n+                                    char_vector.iter().collect::<String>().as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        other => Err(DataFusionError::Internal(format!(\n+            \"lpad was called with {} arguments. It requires at least 2 and at most 3.\",\n+            other\n+        ))),\n+    }\n+}\n+\n+/// Reverses the order of the characters in the string.\n+/// reverse('abcde') = 'edcba'\n+pub fn reverse<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| string.graphemes(true).rev().collect::<String>())\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns last n characters in the string, or when n is negative, returns all but first |n| characters.\n+/// right('abcde', 2) = 'de'\n+pub fn right<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n as usize - 1)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[i..]).unwrap()\n\nReview comment:\n       here is another use of unwrap because of trying to find grapheme boundaries based on `grapheme_indicies` -- if we could use character length math rather than byte boundaries we might be able to avoid the unwraps\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n\nReview comment:\n       ```suggestion\r\n   /// Extends the string to length `length` by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\r\n   ```\n\n##########\nFile path: rust/datafusion/src/physical_plan/string_expressions.rs\n##########\n@@ -621,139 +463,28 @@ pub fn repeat<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     Ok(Arc::new(result) as ArrayRef)\n }\n \n-/// Reverses the order of the characters in the string.\n-/// reverse('abcde') = 'edcba'\n-pub fn reverse<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+/// Replaces all occurrences in string of substring from with substring to.\n+/// replace('abcdefabcdef', 'cd', 'XX') = 'abXXefabXXef'\n+pub fn replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n     let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let from_array = downcast_string_arg!(args[1], \"from\", T);\n+    let to_array = downcast_string_arg!(args[2], \"to\", T);\n \n     let result = string_array\n         .iter()\n-        .map(|string| {\n-            string.map(|string: &str| string.graphemes(true).rev().collect::<String>())\n+        .zip(from_array.iter())\n+        .zip(to_array.iter())\n+        .map(|((string, from), to)| match (string, from, to) {\n+            (None, _, _) => None,\n\nReview comment:\n       same applies to `regex_replace` if you want to use a different pattern\n\n##########\nFile path: rust/datafusion/tests/sql.rs\n##########\n@@ -2273,35 +2192,178 @@ async fn test_interval_expressions() -> Result<()> {\n }\n \n #[tokio::test]\n-#[cfg_attr(not(feature = \"crypto_expressions\"), ignore)]\n-async fn test_crypto_expressions() -> Result<()> {\n-    test_expression!(\"md5('tom')\", \"34b7da764b21d298ef307d04d8152dc5\");\n-    test_expression!(\"md5('')\", \"d41d8cd98f00b204e9800998ecf8427e\");\n-    test_expression!(\"md5(NULL)\", \"NULL\");\n-    test_expression!(\n-        \"sha224('tom')\",\n-        \"0bf6cb62649c42a9ae3876ab6f6d92ad36cb5414e495f8873292be4d\"\n-    );\n+async fn test_string_expressions() -> Result<()> {\n\nReview comment:\n       the test cases look really good, as always\n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    // creating Regex is expensive so create hashmap for memoization\n+    let mut patterns: HashMap<String, Regex> = HashMap::new();\n+\n+    match args.len() {\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let pattern_array = downcast_string_arg!(args[1], \"pattern\", T);\n+            let replacement_array = downcast_string_arg!(args[2], \"replacement\", T);\n+\n+            let result = string_array\n+            .iter()\n+            .zip(pattern_array.iter())\n+            .zip(replacement_array.iter())\n+            .map(|((string, pattern), replacement)| match (string, pattern, replacement) {\n+                (None, _, _) => Ok(None),\n+                (_, None, _) => Ok(None),\n+                (_, _, None) => Ok(None),\n+                (Some(string), Some(pattern), Some(replacement)) => {\n+                    let replacement = regex_replace_posix_groups(replacement);\n+\n+                    // if patterns hashmap already has regexp then use else else create and return\n+                    let re = match patterns.get(pattern) {\n+                        Some(re) => Ok(re.clone()),\n+                        None => {\n+                            match Regex::new(pattern) {\n+                                Ok(re) => {\n+                                    patterns.insert(pattern.to_string(), re.clone());\n+                                    Ok(re)\n+                                },\n+                                Err(err) => Err(DataFusionError::Execution(err.to_string())),\n+                            }\n+                        }\n+                    };\n+\n+                    Some(re.map(|re| re.replace(string, replacement.as_str()))).transpose()\n+                }\n+            })\n+            .collect::<Result<GenericStringArray<T>>>()?;\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        4 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let pattern_array = downcast_string_arg!(args[1], \"pattern\", T);\n+            let replacement_array = downcast_string_arg!(args[2], \"replacement\", T);\n+            let flags_array = downcast_string_arg!(args[3], \"flags\", T);\n+\n+            let result = string_array\n+            .iter()\n+            .zip(pattern_array.iter())\n+            .zip(replacement_array.iter())\n+            .zip(flags_array.iter())\n+            .map(|(((string, pattern), replacement), flags)| match (string, pattern, replacement, flags) {\n+                (None, _, _, _) => Ok(None),\n+                (_, None, _, _) => Ok(None),\n+                (_, _, None, _) => Ok(None),\n+                (_, _, _, None) => Ok(None),\n+                (Some(string), Some(pattern), Some(replacement), Some(flags)) => {\n+                    let replacement = regex_replace_posix_groups(replacement);\n+\n+                    // format flags into rust pattern\n+                    let (pattern, replace_all) = if flags == \"g\" {\n+                        (pattern.to_string(), true)\n+                    } else if flags.contains('g') {\n+                        (format!(\"(?{}){}\", flags.to_string().replace(\"g\", \"\"), pattern), true)\n+                    } else {\n+                        (format!(\"(?{}){}\", flags, pattern), false)\n+                    };\n+\n+                    // if patterns hashmap already has regexp then use else else create and return\n+                    let re = match patterns.get(&pattern) {\n\nReview comment:\n       I was worried that the key into the hashmap might not include the flags, but that seems not the be the case \r\n   \r\n   This clause seems basically copy/paste from the `3` case above -- maybe (in a future PR) or something we could consolidate them into a helper or something\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n\nReview comment:\n       I spent some time poking around in https://docs.rs/unicode-segmentation/1.7.1/unicode_segmentation/trait.UnicodeSegmentation.html#tymethod.graphemes\r\n   \r\n   I couldn't find anything that would let you get back a `&str` from the grapheme indices. I wonder if it might be possible to use the `graphemes()` call itself and count up the lengths of the `&str` that came back\r\n   \r\n   https://docs.rs/unicode-segmentation/1.7.1/unicode_segmentation/trait.UnicodeSegmentation.html#tymethod.graphemes\r\n   \r\n   Something like (untested)\r\n   \r\n   ```rust\r\n   let i = strings\r\n     .graphemes()\r\n     .limit(n as usize)\r\n     .map(|s| s.len())\r\n     .sum()\r\n   \r\n   string[..i]\r\n   ```\r\n   \r\n   Or something like that. I am not sure how important this is\r\n   \n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n\nReview comment:\n       Yeah -- it might be worth a discussion on the mailing list of what functions belong in datafusion and what are more \"core\" and broadly applicable to bring them into the core arrow kernels\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n+                    (_, None, _) => None,\n+                    (_, _, None) => None,\n+                    (Some(string), Some(length), Some(fill)) => {\n+                        let length = length as usize;\n+\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            let fill_chars = fill.chars().collect::<Vec<char>>();\n+\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else if fill_chars.is_empty() {\n+                                Some(string.to_string())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                let mut char_vector =\n+                                    Vec::<char>::with_capacity(length - graphemes.len());\n+                                for l in 0..length - graphemes.len() {\n+                                    char_vector.push(\n+                                        *fill_chars.get(l % fill_chars.len()).unwrap(),\n+                                    );\n+                                }\n+                                s.insert_str(\n+                                    0,\n+                                    char_vector.iter().collect::<String>().as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        other => Err(DataFusionError::Internal(format!(\n+            \"lpad was called with {} arguments. It requires at least 2 and at most 3.\",\n+            other\n+        ))),\n+    }\n+}\n+\n+/// Reverses the order of the characters in the string.\n+/// reverse('abcde') = 'edcba'\n+pub fn reverse<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| string.graphemes(true).rev().collect::<String>())\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns last n characters in the string, or when n is negative, returns all but first |n| characters.\n+/// right('abcde', 2) = 'de'\n+pub fn right<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n as usize - 1)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[i..]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n.abs() as usize)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[i..]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by appending the characters fill (a space by default). If the string is already longer than length then it is truncated.\n\nReview comment:\n       ```suggestion\r\n   /// Extends the string to length `length` by appending the characters fill (a space by default). If the string is already longer than length then it is truncated.\r\n   ```\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T22:54:51.406+0000",
                    "updated": "2021-03-08T22:54:51.406+0000",
                    "started": "2021-03-08T22:54:51.406+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562668",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562680",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589813533\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/functions.rs\n##########\n@@ -494,6 +532,27 @@ pub fn return_type(\n                 ));\n             }\n         }),\n+        BuiltinScalarFunction::SplitPart => Ok(match arg_types[0] {\n+            DataType::LargeUtf8 => DataType::LargeUtf8,\n+            DataType::Utf8 => DataType::Utf8,\n+            _ => {\n+                // this error is internal as `data_types` should have captured this.\n+                return Err(DataFusionError::Internal(\n+                    \"The split_part function can only accept strings.\".to_string(),\n+                ));\n+            }\n+        }),\n+        BuiltinScalarFunction::StartsWith => Ok(DataType::Boolean),\n\nReview comment:\n       Because this is just the return type and will always be Boolean whereas something like `InitCap` will return either `Utf8`  or `LargeUtf8` depending on input \ud83d\ude01 \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:02:54.626+0000",
                    "updated": "2021-03-08T23:02:54.626+0000",
                    "started": "2021-03-08T23:02:54.625+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562680",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562682",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589813852\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    // creating Regex is expensive so create hashmap for memoization\n+    let mut patterns: HashMap<String, Regex> = HashMap::new();\n\nReview comment:\n       There is definitely more work to be done with regex but we have feature flagged it so we should easily be able to add more here then promote them up.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:03:36.613+0000",
                    "updated": "2021-03-08T23:03:36.613+0000",
                    "started": "2021-03-08T23:03:36.612+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562682",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562685",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589814645\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/regex_expressions.rs\n##########\n@@ -0,0 +1,161 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Regex expressions\n+\n+use std::any::type_name;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::array::{ArrayRef, GenericStringArray, StringOffsetSizeTrait};\n+use hashbrown::HashMap;\n+use regex::Regex;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+/// replace POSIX capture groups (like \\1) with Rust Regex group (like ${1})\n+/// used by regexp_replace\n+fn regex_replace_posix_groups(replacement: &str) -> String {\n+    lazy_static! {\n+        static ref CAPTURE_GROUPS_RE: Regex = Regex::new(\"(\\\\\\\\)(\\\\d*)\").unwrap();\n+    }\n+    CAPTURE_GROUPS_RE\n+        .replace_all(replacement, \"$${$2}\")\n+        .into_owned()\n+}\n+\n+/// Replaces substring(s) matching a POSIX regular expression\n+/// regexp_replace('Thomas', '.[mN]a.', 'M') = 'ThM'\n+pub fn regexp_replace<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    // creating Regex is expensive so create hashmap for memoization\n+    let mut patterns: HashMap<String, Regex> = HashMap::new();\n+\n+    match args.len() {\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let pattern_array = downcast_string_arg!(args[1], \"pattern\", T);\n+            let replacement_array = downcast_string_arg!(args[2], \"replacement\", T);\n+\n+            let result = string_array\n+            .iter()\n+            .zip(pattern_array.iter())\n+            .zip(replacement_array.iter())\n+            .map(|((string, pattern), replacement)| match (string, pattern, replacement) {\n+                (None, _, _) => Ok(None),\n+                (_, None, _) => Ok(None),\n+                (_, _, None) => Ok(None),\n+                (Some(string), Some(pattern), Some(replacement)) => {\n+                    let replacement = regex_replace_posix_groups(replacement);\n+\n+                    // if patterns hashmap already has regexp then use else else create and return\n+                    let re = match patterns.get(pattern) {\n+                        Some(re) => Ok(re.clone()),\n+                        None => {\n+                            match Regex::new(pattern) {\n+                                Ok(re) => {\n+                                    patterns.insert(pattern.to_string(), re.clone());\n+                                    Ok(re)\n+                                },\n+                                Err(err) => Err(DataFusionError::Execution(err.to_string())),\n+                            }\n+                        }\n+                    };\n+\n+                    Some(re.map(|re| re.replace(string, replacement.as_str()))).transpose()\n+                }\n+            })\n+            .collect::<Result<GenericStringArray<T>>>()?;\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        4 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let pattern_array = downcast_string_arg!(args[1], \"pattern\", T);\n+            let replacement_array = downcast_string_arg!(args[2], \"replacement\", T);\n+            let flags_array = downcast_string_arg!(args[3], \"flags\", T);\n+\n+            let result = string_array\n+            .iter()\n+            .zip(pattern_array.iter())\n+            .zip(replacement_array.iter())\n+            .zip(flags_array.iter())\n+            .map(|(((string, pattern), replacement), flags)| match (string, pattern, replacement, flags) {\n+                (None, _, _, _) => Ok(None),\n+                (_, None, _, _) => Ok(None),\n+                (_, _, None, _) => Ok(None),\n+                (_, _, _, None) => Ok(None),\n+                (Some(string), Some(pattern), Some(replacement), Some(flags)) => {\n+                    let replacement = regex_replace_posix_groups(replacement);\n+\n+                    // format flags into rust pattern\n+                    let (pattern, replace_all) = if flags == \"g\" {\n+                        (pattern.to_string(), true)\n+                    } else if flags.contains('g') {\n+                        (format!(\"(?{}){}\", flags.to_string().replace(\"g\", \"\"), pattern), true)\n+                    } else {\n+                        (format!(\"(?{}){}\", flags, pattern), false)\n+                    };\n+\n+                    // if patterns hashmap already has regexp then use else else create and return\n+                    let re = match patterns.get(&pattern) {\n\nReview comment:\n       The code at line 115 does overload `pattern` (the key) with the flags. There is going to be opportunity to make some helper functions to manage these flags as we add more functions.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:05:24.813+0000",
                    "updated": "2021-03-08T23:05:24.813+0000",
                    "started": "2021-03-08T23:05:24.813+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562685",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562688",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589815674\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n\nReview comment:\n       :+1:\r\n   \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:07:36.127+0000",
                    "updated": "2021-03-08T23:07:36.127+0000",
                    "started": "2021-03-08T23:07:36.127+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562688",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562690",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589816050\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n+                    (_, None, _) => None,\n+                    (_, _, None) => None,\n+                    (Some(string), Some(length), Some(fill)) => {\n+                        let length = length as usize;\n+\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            let fill_chars = fill.chars().collect::<Vec<char>>();\n+\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else if fill_chars.is_empty() {\n+                                Some(string.to_string())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                let mut char_vector =\n+                                    Vec::<char>::with_capacity(length - graphemes.len());\n+                                for l in 0..length - graphemes.len() {\n+                                    char_vector.push(\n+                                        *fill_chars.get(l % fill_chars.len()).unwrap(),\n+                                    );\n+                                }\n+                                s.insert_str(\n+                                    0,\n+                                    char_vector.iter().collect::<String>().as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        other => Err(DataFusionError::Internal(format!(\n+            \"lpad was called with {} arguments. It requires at least 2 and at most 3.\",\n+            other\n+        ))),\n+    }\n+}\n+\n+/// Reverses the order of the characters in the string.\n+/// reverse('abcde') = 'edcba'\n+pub fn reverse<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| string.graphemes(true).rev().collect::<String>())\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns last n characters in the string, or when n is negative, returns all but first |n| characters.\n+/// right('abcde', 2) = 'de'\n+pub fn right<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n as usize - 1)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[i..]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n.abs() as usize)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[i..]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by appending the characters fill (a space by default). If the string is already longer than length then it is truncated.\n\nReview comment:\n       \ud83d\udc4d \n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:08:20.245+0000",
                    "updated": "2021-03-08T23:08:20.245+0000",
                    "started": "2021-03-08T23:08:20.245+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562690",
                    "issueId": "13358945"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/worklog/562693",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "seddonm1 commented on a change in pull request #9654:\nURL: https://github.com/apache/arrow/pull/9654#discussion_r589816670\n\n\n\n##########\nFile path: rust/datafusion/src/physical_plan/unicode_expressions.rs\n##########\n@@ -0,0 +1,537 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+// Some of these functions reference the Postgres documentation\n+// or implementation to ensure compatibility and are subject to\n+// the Postgres license.\n+\n+//! Unicode expressions\n+\n+use std::any::type_name;\n+use std::cmp::Ordering;\n+use std::str::from_utf8;\n+use std::sync::Arc;\n+\n+use crate::error::{DataFusionError, Result};\n+use arrow::{\n+    array::{\n+        ArrayRef, GenericStringArray, Int64Array, PrimitiveArray, StringOffsetSizeTrait,\n+    },\n+    datatypes::{ArrowNativeType, ArrowPrimitiveType},\n+};\n+use hashbrown::HashMap;\n+use unicode_segmentation::UnicodeSegmentation;\n+\n+macro_rules! downcast_string_arg {\n+    ($ARG:expr, $NAME:expr, $T:ident) => {{\n+        $ARG.as_any()\n+            .downcast_ref::<GenericStringArray<T>>()\n+            .ok_or_else(|| {\n+                DataFusionError::Internal(format!(\n+                    \"could not cast {} to {}\",\n+                    $NAME,\n+                    type_name::<GenericStringArray<T>>()\n+                ))\n+            })?\n+    }};\n+}\n+\n+macro_rules! downcast_arg {\n+    ($ARG:expr, $NAME:expr, $ARRAY_TYPE:ident) => {{\n+        $ARG.as_any().downcast_ref::<$ARRAY_TYPE>().ok_or_else(|| {\n+            DataFusionError::Internal(format!(\n+                \"could not cast {} to {}\",\n+                $NAME,\n+                type_name::<$ARRAY_TYPE>()\n+            ))\n+        })?\n+    }};\n+}\n+\n+/// Returns number of characters in the string.\n+/// character_length('jos\u00e9') = 4\n+pub fn character_length<T: ArrowPrimitiveType>(args: &[ArrayRef]) -> Result<ArrayRef>\n+where\n+    T::Native: StringOffsetSizeTrait,\n+{\n+    let string_array: &GenericStringArray<T::Native> = args[0]\n+        .as_any()\n+        .downcast_ref::<GenericStringArray<T::Native>>()\n+        .ok_or_else(|| {\n+            DataFusionError::Internal(\"could not cast string to StringArray\".to_string())\n+        })?;\n+\n+    let result = string_array\n+        .iter()\n+        .map(|string| {\n+            string.map(|string: &str| {\n+                T::Native::from_usize(string.graphemes(true).count()).unwrap()\n+            })\n+        })\n+        .collect::<PrimitiveArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Returns first n characters in the string, or when n is negative, returns all but last |n| characters.\n+/// left('abcde', 2) = 'ab'\n+pub fn left<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    let string_array = downcast_string_arg!(args[0], \"string\", T);\n+    let n_array = downcast_arg!(args[1], \"n\", Int64Array);\n+\n+    let result = string_array\n+        .iter()\n+        .zip(n_array.iter())\n+        .map(|(string, n)| match (string, n) {\n+            (None, _) => None,\n+            (_, None) => None,\n+            (Some(string), Some(n)) => match n.cmp(&0) {\n+                Ordering::Equal => Some(\"\"),\n+                Ordering::Greater => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .nth(n as usize)\n+                        .map_or(string, |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+                Ordering::Less => Some(\n+                    string\n+                        .grapheme_indices(true)\n+                        .rev()\n+                        .nth(n.abs() as usize - 1)\n+                        .map_or(\"\", |(i, _)| {\n+                            &from_utf8(&string.as_bytes()[..i]).unwrap()\n+                        }),\n+                ),\n+            },\n+        })\n+        .collect::<GenericStringArray<T>>();\n+\n+    Ok(Arc::new(result) as ArrayRef)\n+}\n+\n+/// Extends the string to length length by prepending the characters fill (a space by default). If the string is already longer than length then it is truncated (on the right).\n+/// lpad('hi', 5, 'xy') = 'xyxhi'\n+pub fn lpad<T: StringOffsetSizeTrait>(args: &[ArrayRef]) -> Result<ArrayRef> {\n+    match args.len() {\n+        2 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .map(|(string, length)| match (string, length) {\n+                    (None, _) => None,\n+                    (_, None) => None,\n+                    (Some(string), Some(length)) => {\n+                        let length = length as usize;\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n+                        } else {\n+                            let graphemes = string.graphemes(true).collect::<Vec<&str>>();\n+                            if length < graphemes.len() {\n+                                Some(graphemes[..length].concat())\n+                            } else {\n+                                let mut s = string.to_string();\n+                                s.insert_str(\n+                                    0,\n+                                    \" \".repeat(length - graphemes.len()).as_str(),\n+                                );\n+                                Some(s)\n+                            }\n+                        }\n+                    }\n+                })\n+                .collect::<GenericStringArray<T>>();\n+\n+            Ok(Arc::new(result) as ArrayRef)\n+        }\n+        3 => {\n+            let string_array = downcast_string_arg!(args[0], \"string\", T);\n+            let length_array = downcast_arg!(args[1], \"length\", Int64Array);\n+            let fill_array = downcast_string_arg!(args[2], \"fill\", T);\n+\n+            let result = string_array\n+                .iter()\n+                .zip(length_array.iter())\n+                .zip(fill_array.iter())\n+                .map(|((string, length), fill)| match (string, length, fill) {\n+                    (None, _, _) => None,\n+                    (_, None, _) => None,\n+                    (_, _, None) => None,\n+                    (Some(string), Some(length), Some(fill)) => {\n+                        let length = length as usize;\n+\n+                        if length == 0 {\n+                            Some(\"\".to_string())\n\nReview comment:\n       I'm hitting issues with the borrow checker so I think that the `String` allocation is required.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2021-03-08T23:09:37.879+0000",
                    "updated": "2021-03-08T23:09:37.879+0000",
                    "started": "2021-03-08T23:09:37.879+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "562693",
                    "issueId": "13358945"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/7",
            "id": "7",
            "description": "The sub-task of the issue",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21146&avatarType=issuetype",
            "name": "Sub-task",
            "subtask": true,
            "avatarId": 21146
        },
        "timespent": 18000,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@26bb3fcb[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@616db5d1[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4bbc83de[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@47f36445[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@56d9c11[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@4d512f9[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2b58c3ce[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@77555bac[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e31dc43[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@32df47a6[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@5f74a480[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@2a11cf9[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 18000,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Mar 10 23:28:35 UTC 2021",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2021-03-10T23:28:35.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-11656/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2021-02-16T21:19:56.000+0000",
        "updated": "2021-03-10T23:28:38.000+0000",
        "timeoriginalestimate": null,
        "description": null,
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "5h",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 18000
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "Left over functions/fixes",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13358945/comment/17299190",
                    "id": "17299190",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 9654\n[https://github.com/apache/arrow/pull/9654]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=alamb",
                        "name": "alamb",
                        "key": "alamb",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=alamb&avatarId=43364",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=alamb&avatarId=43364",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=alamb&avatarId=43364",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=alamb&avatarId=43364"
                        },
                        "displayName": "Andrew Lamb",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2021-03-10T23:28:35.615+0000",
                    "updated": "2021-03-10T23:28:35.615+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0nqeg:",
        "customfield_12314139": null
    }
}