{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13166238",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238",
    "key": "ARROW-2712",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12343858",
                "id": "12343858",
                "description": "",
                "name": "0.12.0",
                "archived": false,
                "released": true,
                "releaseDate": "2019-01-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "features",
            "newbie",
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": null,
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12334712",
                "id": "12334712",
                "name": "C#"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
            "name": "Jamie Elliott",
            "key": "jamie elliott",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
            },
            "displayName": "Jamie Elliott",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
            "name": "Jamie Elliott",
            "key": "jamie elliott",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
            },
            "displayName": "Jamie Elliott",
            "active": true,
            "timeZone": "Etc/UTC"
        },
        "aggregateprogress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 4800,
            "total": 4800,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2712/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 8,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/157213",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "chutchinson opened a new pull request #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815\n \n \n   PR to merge in the WIP C# implementation as directed by Wes McKinney.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-22T21:37:25.054+0000",
                    "updated": "2018-10-22T21:37:25.054+0000",
                    "started": "2018-10-22T21:37:25.053+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "157213",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/158511",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-432924213\n \n \n   The IP clearance vote has passed. We can merge this once the release audit issues are resolved:\r\n   \r\n   ```\r\n   NOT APPROVED: csharp/.gitattributes (apache-arrow/csharp/.gitattributes): false\r\n   NOT APPROVED: csharp/README.md (apache-arrow/csharp/README.md): false\r\n   NOT APPROVED: csharp/build/Common.props (apache-arrow/csharp/build/Common.props): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Apache.Arrow.csproj (apache-arrow/csharp/src/Apache.Arrow/Apache.Arrow.csproj): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Block.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Block.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Buffer.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Buffer.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/DictionaryBatch.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/DictionaryBatch.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/DictionaryEncoding.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/DictionaryEncoding.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/DateUnit.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/DateUnit.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/Endianness.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/Endianness.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/IntervalUnit.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/IntervalUnit.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/MessageHeader.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/MessageHeader.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/Precision.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/Precision.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/TimeUnit.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/TimeUnit.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Enums/UnionMode.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Enums/UnionMode.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Field.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Field.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/FieldNode.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/FieldNode.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/FixedSizeBinary.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/FixedSizeBinary.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/FixedSizeList.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/FixedSizeList.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Footer.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Footer.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/KeyValue.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/KeyValue.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Map.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Map.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Message.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Message.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Schema.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Schema.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Tensor.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Tensor.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/TensorDim.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/TensorDim.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Binary.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Binary.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Bool.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Bool.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Date.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Date.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/FloatingPoint.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/FloatingPoint.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Int.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Int.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Interval.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Interval.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/List.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/List.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Null.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Null.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Struct_.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Struct_.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Time.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Time.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Timestamp.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Timestamp.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Union.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Union.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Flatbuf/Types/Utf8.cs (apache-arrow/csharp/src/Apache.Arrow/Flatbuf/Types/Utf8.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Properties/Resources.Designer.cs (apache-arrow/csharp/src/Apache.Arrow/Properties/Resources.Designer.cs): false\r\n   NOT APPROVED: csharp/src/Apache.Arrow/Properties/Resources.resx (apache-arrow/csharp/src/Apache.Arrow/Properties/Resources.resx): false\r\n   NOT APPROVED: csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj (apache-arrow/csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj): false\r\n   NOT APPROVED: csharp/test/Apache.Arrow.Tests/app.config (apache-arrow/csharp/test/Apache.Arrow.Tests/app.config): false\r\n   47 unapproved licences. Check rat report: rat.txt\r\n   ```\r\n   \r\n   Some of these files can be added to `dev/release/rat_exclude_files.txt`. Do you definitely want to check in the generated Flatbuffers files? If so, then these should be excluded\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-25T05:56:46.132+0000",
                    "updated": "2018-10-25T05:56:46.132+0000",
                    "started": "2018-10-25T05:56:46.132+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "158511",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/158740",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "chutchinson commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-433091327\n \n \n   Just a heads up, the MSBuild project files (*.csproj) have some NuGet package information referencing the Apache Foundation (copyright, company name, etc). We can remove or replace that if necessary. Not sure what's going on with Common.props and gitattributes. \r\n   \r\n   Ideally the Flatbuffer models would be generated on build, but that's not currently part of build pipeline. We can work on getting that done but it's going to take a week or so. Does it make sense to check in the code as-is with the generated flatbuffers, or wait until the pipeline is modified to use the Flatbuffer tooling on build?\r\n   \r\n   If you agree on moving forward I will add all of the files to the exclusion list and resubmit the PR.\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-25T15:15:11.161+0000",
                    "updated": "2018-10-25T15:15:11.161+0000",
                    "started": "2018-10-25T15:15:11.160+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "158740",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/158763",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-433118401\n \n \n   Sounds good. You can go ahead and push additional commits to this PR branch. No need to open a new PR. \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-25T16:28:54.961+0000",
                    "updated": "2018-10-25T16:28:54.961+0000",
                    "started": "2018-10-25T16:28:54.960+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "158763",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/158764",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-433118679\n \n \n   I see that this PR is made out of your master branch. In the future you will want to create a feature branch to use for PRs\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-25T16:29:36.772+0000",
                    "updated": "2018-10-25T16:29:36.772+0000",
                    "started": "2018-10-25T16:29:36.771+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "158764",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/159543",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-433601419\n \n \n   I added the RAT excludes. I'll merge this once we get the green light\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-27T08:17:42.727+0000",
                    "updated": "2018-10-27T08:17:42.727+0000",
                    "started": "2018-10-27T08:17:42.726+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "159543",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/159546",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm closed pull request #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/csharp/.gitattributes b/csharp/.gitattributes\nnew file mode 100644\nindex 0000000000..d2ff52b121\n--- /dev/null\n+++ b/csharp/.gitattributes\n@@ -0,0 +1,36 @@\n+###############################################################################\n+# Set default behavior to automatically normalize line endings.\n+###############################################################################\n+* text=auto\n+\n+###############################################################################\n+# Set default behavior for command prompt diff.\n+#\n+# This is need for earlier builds of msysgit that does not have it on by\n+# default for csharp files.\n+# Note: This is only used by command line\n+###############################################################################\n+#*.cs     diff=csharp\n+\n+###############################################################################\n+# Set the merge driver for project and solution files\n+#\n+# Merging from the command prompt will add diff markers to the files if there\n+# are conflicts (Merging from VS is not affected by the settings below, in VS\n+# the diff markers are never inserted). Diff markers may cause the following\n+# file extensions to fail to load in VS. An alternative would be to treat\n+# these files as binary and thus will always conflict and require user\n+# intervention with every merge. To do so, just uncomment the entries below\n+###############################################################################\n+#*.sln       merge=binary\n+#*.csproj    merge=binary\n+#*.vbproj    merge=binary\n+#*.vcxproj   merge=binary\n+#*.vcproj    merge=binary\n+#*.dbproj    merge=binary\n+#*.fsproj    merge=binary\n+#*.lsproj    merge=binary\n+#*.wixproj   merge=binary\n+#*.modelproj merge=binary\n+#*.sqlproj   merge=binary\n+#*.wwaproj   merge=binary\n\\ No newline at end of file\ndiff --git a/csharp/.gitignore b/csharp/.gitignore\nnew file mode 100644\nindex 0000000000..e5b411f791\n--- /dev/null\n+++ b/csharp/.gitignore\n@@ -0,0 +1,264 @@\n+## Ignore Visual Studio temporary files, build results, and\n+## files generated by popular Visual Studio add-ons.\n+\n+# User-specific files\n+*.suo\n+*.user\n+*.userosscache\n+*.sln.docstates\n+\n+# User-specific files (MonoDevelop/Xamarin Studio)\n+*.userprefs\n+\n+# Build results\n+[Dd]ebug/\n+[Dd]ebugPublic/\n+[Rr]elease/\n+[Rr]eleases/\n+x64/\n+x86/\n+bld/\n+[Bb]in/\n+[Oo]bj/\n+[Ll]og/\n+\n+# Visual Studio 2015 cache/options directory\n+.vs/\n+# Uncomment if you have tasks that create the project's static files in wwwroot\n+#wwwroot/\n+\n+# MSTest test Results\n+[Tt]est[Rr]esult*/\n+[Bb]uild[Ll]og.*\n+\n+# NUNIT\n+*.VisualState.xml\n+TestResult.xml\n+\n+# Build Results of an ATL Project\n+[Dd]ebugPS/\n+[Rr]eleasePS/\n+dlldata.c\n+\n+# DNX\n+project.lock.json\n+project.fragment.lock.json\n+artifacts/\n+\n+*_i.c\n+*_p.c\n+*_i.h\n+*.ilk\n+*.meta\n+*.obj\n+*.pch\n+*.pdb\n+*.pgc\n+*.pgd\n+*.rsp\n+*.sbr\n+*.tlb\n+*.tli\n+*.tlh\n+*.tmp\n+*.tmp_proj\n+*.log\n+*.vspscc\n+*.vssscc\n+.builds\n+*.pidb\n+*.svclog\n+*.scc\n+\n+# Chutzpah Test files\n+_Chutzpah*\n+\n+# Visual C++ cache files\n+ipch/\n+*.aps\n+*.ncb\n+*.opendb\n+*.opensdf\n+*.sdf\n+*.cachefile\n+*.VC.db\n+*.VC.VC.opendb\n+\n+# Visual Studio profiler\n+*.psess\n+*.vsp\n+*.vspx\n+*.sap\n+\n+# TFS 2012 Local Workspace\n+$tf/\n+\n+# Guidance Automation Toolkit\n+*.gpState\n+\n+# ReSharper is a .NET coding add-in\n+_ReSharper*/\n+*.[Rr]e[Ss]harper\n+*.DotSettings.user\n+\n+# JustCode is a .NET coding add-in\n+.JustCode\n+\n+# TeamCity is a build add-in\n+_TeamCity*\n+\n+# DotCover is a Code Coverage Tool\n+*.dotCover\n+\n+# NCrunch\n+_NCrunch_*\n+.*crunch*.local.xml\n+nCrunchTemp_*\n+\n+# MightyMoose\n+*.mm.*\n+AutoTest.Net/\n+\n+# Web workbench (sass)\n+.sass-cache/\n+\n+# Installshield output folder\n+[Ee]xpress/\n+\n+# DocProject is a documentation generator add-in\n+DocProject/buildhelp/\n+DocProject/Help/*.HxT\n+DocProject/Help/*.HxC\n+DocProject/Help/*.hhc\n+DocProject/Help/*.hhk\n+DocProject/Help/*.hhp\n+DocProject/Help/Html2\n+DocProject/Help/html\n+\n+# Click-Once directory\n+publish/\n+\n+# Publish Web Output\n+*.[Pp]ublish.xml\n+*.azurePubxml\n+# TODO: Comment the next line if you want to checkin your web deploy settings\n+# but database connection strings (with potential passwords) will be unencrypted\n+#*.pubxml\n+*.publishproj\n+\n+# Microsoft Azure Web App publish settings. Comment the next line if you want to\n+# checkin your Azure Web App publish settings, but sensitive information contained\n+# in these scripts will be unencrypted\n+PublishScripts/\n+\n+# NuGet Packages\n+*.nupkg\n+# The packages folder can be ignored because of Package Restore\n+**/packages/*\n+# except build/, which is used as an MSBuild target.\n+!**/packages/build/\n+# Uncomment if necessary however generally it will be regenerated when needed\n+#!**/packages/repositories.config\n+# NuGet v3's project.json files produces more ignoreable files\n+*.nuget.props\n+*.nuget.targets\n+\n+# Microsoft Azure Build Output\n+csx/\n+*.build.csdef\n+\n+# Microsoft Azure Emulator\n+ecf/\n+rcf/\n+\n+# Windows Store app package directories and files\n+AppPackages/\n+BundleArtifacts/\n+Package.StoreAssociation.xml\n+_pkginfo.txt\n+\n+# Visual Studio cache files\n+# files ending in .cache can be ignored\n+*.[Cc]ache\n+# but keep track of directories ending in .cache\n+!*.[Cc]ache/\n+\n+# Others\n+ClientBin/\n+~$*\n+*~\n+*.dbmdl\n+*.dbproj.schemaview\n+*.jfm\n+*.pfx\n+*.publishsettings\n+node_modules/\n+orleans.codegen.cs\n+\n+# Since there are multiple workflows, uncomment next line to ignore bower_components\n+# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\n+#bower_components/\n+\n+# RIA/Silverlight projects\n+Generated_Code/\n+\n+# Backup & report files from converting an old project file\n+# to a newer Visual Studio version. Backup files are not needed,\n+# because we have git ;-)\n+_UpgradeReport_Files/\n+Backup*/\n+UpgradeLog*.XML\n+UpgradeLog*.htm\n+\n+# SQL Server files\n+*.mdf\n+*.ldf\n+\n+# Business Intelligence projects\n+*.rdl.data\n+*.bim.layout\n+*.bim_*.settings\n+\n+# Microsoft Fakes\n+FakesAssemblies/\n+\n+# GhostDoc plugin setting file\n+*.GhostDoc.xml\n+\n+# Node.js Tools for Visual Studio\n+.ntvs_analysis.dat\n+\n+# Visual Studio 6 build log\n+*.plg\n+\n+# Visual Studio 6 workspace options file\n+*.opt\n+\n+# Visual Studio LightSwitch build output\n+**/*.HTMLClient/GeneratedArtifacts\n+**/*.DesktopClient/GeneratedArtifacts\n+**/*.DesktopClient/ModelManifest.xml\n+**/*.Server/GeneratedArtifacts\n+**/*.Server/ModelManifest.xml\n+_Pvt_Extensions\n+\n+# Paket dependency manager\n+.paket/paket.exe\n+paket-files/\n+\n+# FAKE - F# Make\n+.fake/\n+\n+# JetBrains Rider\n+.idea/\n+*.sln.iml\n+\n+# CodeRush\n+.cr/\n+\n+# Python Tools for Visual Studio (PTVS)\n+__pycache__/\n+*.pyc\n+\n+# Project-specific\n+artifacts/\n\\ No newline at end of file\ndiff --git a/csharp/README.md b/csharp/README.md\nnew file mode 100644\nindex 0000000000..fc393c20c9\n--- /dev/null\n+++ b/csharp/README.md\n@@ -0,0 +1,150 @@\n+<!---\n+  Licensed to the Apache Software Foundation (ASF) under one\n+  or more contributor license agreements.  See the NOTICE file\n+  distributed with this work for additional information\n+  regarding copyright ownership.  The ASF licenses this file\n+  to you under the Apache License, Version 2.0 (the\n+  \"License\"); you may not use this file except in compliance\n+  with the License.  You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+  Unless required by applicable law or agreed to in writing,\n+  software distributed under the License is distributed on an\n+  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+  KIND, either express or implied.  See the License for the\n+  specific language governing permissions and limitations\n+  under the License.\n+-->\n+\n+# Apache Arrow\n+\n+An implementation of Arrow targeting .NET Standard.\n+\n+This implementation is under development and may not be suitable for use in production environments.\n+\n+# Implementation\n+\n+- Arrow 0.11 (specification)\n+- C# 7.2\n+- .NET Standard 1.3\n+- Asynchronous I/O\n+- Uses modern .NET runtime features such as **Span&lt;T&gt;**, **Memory&lt;T&gt;**, **MemoryManager&lt;T&gt;**, and **System.Buffers** primitives for memory allocation, memory storage, and fast serialization.\n+- Uses **Acyclic Visitor Pattern** for array types and arrays to facilitate serialization, record batch traversal, and format growth.\n+\n+# Known Issues\n+\n+- Can not read Arrow files containing dictionary batches, tensors, or tables.\n+- Can not easily modify allocation strategy without implementing a custom memory pool. All allocations are currently 64-byte aligned and padded to 8-bytes.\n+- Default memory allocation strategy uses an over-allocation strategy with pointer fixing, which results in significant memory overhead for small buffers. A buffer that requires a single byte for storage may be backed by an allocation of up to 64-bytes to satisfy alignment requirements.\n+- There are currently few builder APIs available for specific array types. Arrays must be built manually with an arrow buffer builder abstraction.\n+- FlatBuffer code generation is not included in the build process.\n+- Serialization implementation does not perform exhaustive validation checks during deserialization in every scenario.\n+- Throws exceptions with vague, inconsistent, or non-localized messages in many situations\n+- Throws exceptions that are non-specific to the Arrow implementation in some circumstances where it probably should (eg. does not throw ArrowException exceptions)\n+- Lack of code documentation\n+- Lack of usage examples\n+- Lack of comprehensive unit tests\n+- Lack of comprehensive benchmarks\n+\n+# Usage\n+\n+\tusing System.Diagnostics;\n+\tusing System.IO;\n+\tusing System.Threading.Tasks;\n+\tusing Apache.Arrow;\n+\tusing Apache.Arrow.Ipc;\n+\n+    public static async Task<RecordBatch> ReadArrowAsync(string filename)\n+    {\n+        using (var stream = File.OpenRead(\"test.arrow\"))\n+        using (var reader = new ArrowFileReader(stream))\n+        {\n+            var recordBatch = await reader.ReadNextRecordBatchAsync();\n+            Debug.WriteLine(\"Read record batch with {0} column(s)\", recordBatch.ColumnCount);\n+            return recordBatch;\n+        }\n+    }\n+\n+\n+# Status\n+\n+## Memory Management\n+\n+- Allocations are 64-byte aligned and padded to 8-bytes.\n+- Allocations are automatically garbage collected\n+\n+## Arrays\n+\n+### Primitive Types\n+\n+- Int8, Int16, Int32, Int64\n+- UInt8, UInt16, UInt32, UInt64\n+- Float, Double\n+- Binary (variable-length)\n+- String (utf-8)\n+- Null\n+\n+### Parametric Types\n+\n+- Timestamp\n+- Date32\n+- Date64\n+- Time32\n+- Time64\n+- Binary (fixed-length)\n+- List\n+\n+### Type Metadata\n+\n+- Data Types\n+- Fields\n+- Schema\n+\n+### Serialization\n+\n+- File\n+- Stream\n+\n+## Not Implemented\n+\n+- Serialization\n+    - Exhaustive validation\n+    - Dictionary Batch\n+        - Can not serialize or deserialize files or streams containing dictionary batches\n+    - Dictionary Encoding\n+\t- Schema Metadata\n+\t- Schema Field Metadata\n+- Types\n+    - Tensor\n+    - Table\n+- Arrays\n+    - Struct\n+    - Union\n+        - Dense\n+        - Sparse\n+    - Half-Float\n+    - Decimal\n+    - Dictionary\n+- Array Operations\n+\t- Equality / Comparison\n+\t- Casting\n+\t- Builders\n+- Compute\n+    - There is currently no API available for a compute / kernel abstraction.\n+\n+# Build\n+\n+    dotnet build\n+\n+# Docker Build\n+\n+Build from the Apache Arrow project root.\n+\n+    docker build -f csharp/build/docker/Dockerfile .\n+\n+# Testing\n+\n+\tdotnet test test/Apache.Arrow.Tests\n+\n+All build artifacts are placed in the **artifacts** folder in the project root.\ndiff --git a/csharp/build/Common.props b/csharp/build/Common.props\nnew file mode 100644\nindex 0000000000..9e7901d8a1\n--- /dev/null\n+++ b/csharp/build/Common.props\n@@ -0,0 +1,8 @@\n+<Project>\n+    <PropertyGroup>\n+        <BaseOutputPath>../../artifacts/$(AssemblyName)</BaseOutputPath>\n+    </PropertyGroup>\n+    <Target Name=\"Clean\">  \n+        <RemoveDir Directories=\"../../artifacts\" />  \n+    </Target>\n+</Project>\n\\ No newline at end of file\ndiff --git a/csharp/build/docker/Dockerfile b/csharp/build/docker/Dockerfile\nnew file mode 100644\nindex 0000000000..e6ad5741f3\n--- /dev/null\n+++ b/csharp/build/docker/Dockerfile\n@@ -0,0 +1,23 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#   http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing,\n+# software distributed under the License is distributed on an\n+# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+# KIND, either express or implied.  See the License for the\n+# specific language governing permissions and limitations\n+# under the License.\n+\n+FROM microsoft/dotnet/2.1-sdk\n+\n+ADD csharp /arrow/csharp\n+WORKDIR /arrow/csharp\n+\n+CMD dotnet build\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Apache.Arrow.csproj b/csharp/src/Apache.Arrow/Apache.Arrow.csproj\nnew file mode 100644\nindex 0000000000..adc21c9edc\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Apache.Arrow.csproj\n@@ -0,0 +1,50 @@\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+\n+  <Import Project=\"../../build/Common.props\" />\n+\n+  <PropertyGroup>\n+    <TargetFramework>netstandard1.3</TargetFramework>\n+    <Authors>Apache</Authors>\n+    <Product>Apache Arrow library</Product>\n+    <Copyright>2018 Apache Software Foundation</Copyright>\n+    <PackageProjectUrl>https://fzcorp.visualstudio.com/digital-products</PackageProjectUrl>\n+    <RepositoryUrl>https://fzcorp.visualstudio.com/digital-products/_git/fz-arrow</RepositoryUrl>\n+    <RepositoryType>git</RepositoryType>\n+    <PackageTags>apache arrow</PackageTags>\n+    <Company>Apache</Company>\n+    <Version>0.0.1</Version>\n+  </PropertyGroup>\n+\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|AnyCPU'\">\n+    <LangVersion>7.2</LangVersion>\n+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n+  </PropertyGroup>\n+\n+  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|AnyCPU'\">\n+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n+    <LangVersion>7.2</LangVersion>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <PackageReference Include=\"System.Buffers\" Version=\"4.5.0\" />\n+    <PackageReference Include=\"System.Memory\" Version=\"4.5.1\" />\n+    <PackageReference Include=\"System.Runtime.CompilerServices.Unsafe\" Version=\"4.5.1\" />\n+    <PackageReference Include=\"System.Text.Encoding\" Version=\"4.3.0\" />\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <Compile Update=\"Properties\\Resources.Designer.cs\">\n+      <DesignTime>True</DesignTime>\n+      <AutoGen>True</AutoGen>\n+      <DependentUpon>Resources.resx</DependentUpon>\n+    </Compile>\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <EmbeddedResource Update=\"Properties\\Resources.resx\">\n+      <Generator>ResXFileCodeGenerator</Generator>\n+      <LastGenOutput>Resources.Designer.cs</LastGenOutput>\n+    </EmbeddedResource>\n+  </ItemGroup>\n+\n+</Project>\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Array.cs b/csharp/src/Apache.Arrow/Arrays/Array.cs\nnew file mode 100644\nindex 0000000000..a9609f20f1\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Array.cs\n@@ -0,0 +1,64 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Apache.Arrow\n+{\n+    public abstract class Array : IArrowArray\n+    {\n+        public ArrayData Data { get; }\n+\n+        protected Array(ArrayData data)\n+        {\n+            Data = data ?? throw new ArgumentNullException(nameof(data));\n+        }\n+\n+        public int Length => Data.Length;\n+\n+        public int Offset => Data.Offset;\n+\n+        public int NullCount => Data.NullCount;\n+\n+        public Bitmap NullBitmap => Data.NullBitmap;\n+\n+        public ArrowBuffer NullBitmapBuffer => Data.Buffers[0];\n+\n+        public virtual void Accept(IArrowArrayVisitor visitor)\n+        {\n+            Accept(this, visitor);\n+        }\n+\n+        public bool IsValid(int index) =>\n+            NullBitmapBuffer == null || NullBitmap.IsSet(index);\n+\n+        public bool IsNull(int index) => !IsValid(index);\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        internal static void Accept<T>(T array, IArrowArrayVisitor visitor)\n+            where T : class, IArrowArray\n+        {\n+            if (visitor is IArrowArrayVisitor<T> v)\n+            {\n+                v.Visit(array);\n+            }\n+            else\n+            {\n+                visitor.Visit(array);\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Arrays/ArrayData.cs b/csharp/src/Apache.Arrow/Arrays/ArrayData.cs\nnew file mode 100644\nindex 0000000000..a8d745c66c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/ArrayData.cs\n@@ -0,0 +1,47 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow\n+{\n+    public class ArrayData\n+    {\n+        public readonly IArrowType DataType;\n+        public readonly int Length;\n+        public readonly int NullCount;\n+        public readonly int Offset;\n+        public readonly ArrowBuffer[] Buffers;\n+        public readonly ArrayData[] Children;\n+\n+        public ArrowBuffer NullBitmapBuffer => Buffers[0];\n+        public Bitmap NullBitmap => NullBitmapBuffer;\n+\n+        public ArrayData(\n+            IArrowType dataType,\n+            int length, int nullCount = 0, int offset = 0,\n+            IEnumerable<ArrowBuffer> buffers = null, IEnumerable<ArrayData> children = null)\n+        {\n+            DataType = dataType ?? NullType.Default;\n+            Length = length;\n+            NullCount = nullCount;\n+            Offset = offset;\n+            Buffers = buffers?.ToArray();\n+            Children = children?.ToArray();\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs b/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs\nnew file mode 100644\nindex 0000000000..542871cd3f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/ArrowArrayFactory.cs\n@@ -0,0 +1,87 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    public class ArrowArrayFactory\n+    {\n+        private class FactoryTypeVisitor :\n+            IArrowTypeVisitor<Int8Type>,\n+            IArrowTypeVisitor<Int16Type>,\n+            IArrowTypeVisitor<Int32Type>,\n+            IArrowTypeVisitor<Int64Type>,\n+            IArrowTypeVisitor<UInt8Type>,\n+            IArrowTypeVisitor<UInt16Type>,\n+            IArrowTypeVisitor<UInt32Type>,\n+            IArrowTypeVisitor<UInt64Type>,\n+            IArrowTypeVisitor<BooleanType>,\n+            IArrowTypeVisitor<FloatType>,\n+            IArrowTypeVisitor<DoubleType>,\n+            IArrowTypeVisitor<StructType>,\n+            IArrowTypeVisitor<UnionType>,\n+            IArrowTypeVisitor<ListType>,\n+            IArrowTypeVisitor<TimestampType>,\n+            IArrowTypeVisitor<StringType>,\n+            IArrowTypeVisitor<BinaryType>\n+        {\n+            private readonly ArrayData _data;\n+            private IArrowArray _array;\n+\n+            public FactoryTypeVisitor(ArrayData data)\n+            {\n+                _data = data;\n+            }\n+\n+            public IArrowArray CreateArray()\n+            {\n+                _data.DataType.Accept(this);\n+                return _array;\n+            }\n+\n+            public void Visit(Int8Type type) => _array = new Int8Array(_data);\n+            public void Visit(Int16Type type) => _array = new Int16Array(_data);\n+            public void Visit(Int32Type type) => _array = new Int32Array(_data);\n+            public void Visit(Int64Type type) => _array = new Int64Array(_data);\n+            public void Visit(UInt8Type type) => _array = new UInt8Array(_data);\n+            public void Visit(UInt16Type type) => _array = new UInt16Array(_data);\n+            public void Visit(UInt32Type type) => _array = new UInt32Array(_data);\n+            public void Visit(UInt64Type type) => _array = new UInt64Array(_data);\n+            public void Visit(BooleanType type) => _array = new BooleanArray(_data);\n+            public void Visit(FloatType type) => _array = new FloatArray(_data);\n+            public void Visit(DoubleType type) => _array = new DoubleArray(_data);\n+            public void Visit(StructType type) => _array = new StructArray(_data);\n+            public void Visit(UnionType type) => _array = new UnionArray(_data);\n+            public void Visit(ListType type) => _array = new ListArray(_data);\n+            public void Visit(TimestampType type) => _array = new TimestampArray(_data);\n+            public void Visit(BinaryType type) => _array = new BinaryArray(_data);\n+            public void Visit(StringType type) => _array = new StringArray(_data);\n+\n+            public void Visit(IArrowType type)\n+            {\n+                throw new NotImplementedException();\n+            }\n+        }\n+\n+        public static IArrowArray BuildArray(ArrayData data)\n+        {\n+            var visitor = new FactoryTypeVisitor(data);\n+            var array = visitor.CreateArray();\n+            return array;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/ArrowArrayVisitor.cs b/csharp/src/Apache.Arrow/Arrays/ArrowArrayVisitor.cs\nnew file mode 100644\nindex 0000000000..fc56b6601f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/ArrowArrayVisitor.cs\n@@ -0,0 +1,22 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow\n+{\n+    public abstract class ArrowArrayVisitor : IArrowArrayVisitor\n+    {\n+        public virtual void Visit(IArrowArray array) { }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/BinaryArray.cs b/csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\nnew file mode 100644\nindex 0000000000..cbe64dfc1b\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/BinaryArray.cs\n@@ -0,0 +1,78 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+using System.Runtime.CompilerServices;\n+\n+namespace Apache.Arrow\n+{\n+    public class BinaryArray: Array\n+    {\n+        public BinaryArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Binary);\n+            data.EnsureBufferCount(3);\n+        }\n+\n+        public BinaryArray(ArrowTypeId typeId, ArrayData data)\n+            : base (data)\n+        {\n+            data.EnsureDataType(typeId);\n+            data.EnsureBufferCount(3);\n+        }\n+\n+        public BinaryArray(IArrowType dataType, int length,\n+            ArrowBuffer valueOffsetsBuffer,\n+            ArrowBuffer dataBuffer,\n+            ArrowBuffer nullBitmapBuffer,\n+            int nullCount = 0, int offset = 0)\n+        : this(new ArrayData(dataType, length, nullCount, offset, \n+            new [] { nullBitmapBuffer, valueOffsetsBuffer, dataBuffer }))\n+        { }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public ArrowBuffer ValueOffsetsBuffer => Data.Buffers[1];\n+\n+        public ArrowBuffer ValueBuffer => Data.Buffers[2];\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        public int GetValueOffset(int index)\n+        {\n+            var offsets = ValueOffsetsBuffer.GetSpan<int>();\n+            return offsets[Offset + index];\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        public int GetValueLength(int index)\n+        {\n+            var offsets = ValueOffsetsBuffer.GetSpan<int>();\n+            var offset = Offset + index;\n+            return offsets[offset + 1] - offsets[offset];\n+        }\n+\n+        public ReadOnlySpan<byte> GetValue(int index)\n+        {\n+            var offset = GetValueOffset(index);\n+            var length = GetValueLength(index);\n+            var values = ValueBuffer.GetSpan<byte>();\n+\n+            return values.Slice(offset, length);\n+        }\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/BooleanArray.cs b/csharp/src/Apache.Arrow/Arrays/BooleanArray.cs\nnew file mode 100644\nindex 0000000000..f4197122e3\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/BooleanArray.cs\n@@ -0,0 +1,46 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class BooleanArray: PrimitiveArray<byte>\n+    {\n+        public BooleanArray(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(BooleanType.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public BooleanArray(ArrayData data) \n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Boolean);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public bool? GetBoolean(int index)\n+        {\n+            if (IsNull(index))\n+                return null;\n+\n+            var span = GetSpan();\n+            return BitUtility.GetBit(span, index);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Date32Array.cs b/csharp/src/Apache.Arrow/Arrays/Date32Array.cs\nnew file mode 100644\nindex 0000000000..a0ea7e2bf8\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Date32Array.cs\n@@ -0,0 +1,49 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    public class Date32Array: PrimitiveArray<int>\n+    {\n+        public Date32Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Date32Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Date32Array(ArrayData data) \n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Date32);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public DateTimeOffset? GetDate(int index)\n+        {\n+            var value = GetValue(index);\n+\n+            const long millisecondsPerDay = 86_400_000;\n+\n+            return value.HasValue\n+                ? DateTimeOffset.FromUnixTimeMilliseconds(value.Value * millisecondsPerDay)\n+                : default;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Date64Array.cs b/csharp/src/Apache.Arrow/Arrays/Date64Array.cs\nnew file mode 100644\nindex 0000000000..307cda0722\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Date64Array.cs\n@@ -0,0 +1,47 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    public class Date64Array: PrimitiveArray<long>\n+    {\n+        public Date64Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Date64Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Date64Array(ArrayData data) \n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Date64);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public DateTimeOffset? GetDate(int index)\n+        {\n+            var value = GetValue(index);\n+\n+            return value.HasValue\n+                ? DateTimeOffset.FromUnixTimeMilliseconds(value.Value)\n+                : default;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/DoubleArray.cs b/csharp/src/Apache.Arrow/Arrays/DoubleArray.cs\nnew file mode 100644\nindex 0000000000..0c50e5a906\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/DoubleArray.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class DoubleArray : PrimitiveArray<double>\n+    {\n+        public DoubleArray(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(DoubleType.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public DoubleArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Double);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/FloatArray.cs b/csharp/src/Apache.Arrow/Arrays/FloatArray.cs\nnew file mode 100644\nindex 0000000000..b4c9e607a8\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/FloatArray.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class FloatArray : PrimitiveArray<float>\n+    {\n+        public FloatArray(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(FloatType.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public FloatArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Float);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Int16Array.cs b/csharp/src/Apache.Arrow/Arrays/Int16Array.cs\nnew file mode 100644\nindex 0000000000..639c6d5c5e\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Int16Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class Int16Array : PrimitiveArray<short>\n+    {\n+        public Int16Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Int16Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Int16Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Int16);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Int32Array.cs b/csharp/src/Apache.Arrow/Arrays/Int32Array.cs\nnew file mode 100644\nindex 0000000000..8bd0048d64\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Int32Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class Int32Array : PrimitiveArray<int>\n+    {\n+        public Int32Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Int32Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Int32Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Int32);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Int64Array.cs b/csharp/src/Apache.Arrow/Arrays/Int64Array.cs\nnew file mode 100644\nindex 0000000000..d010a8dee3\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Int64Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class Int64Array : PrimitiveArray<long>\n+    {\n+        public Int64Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Int64Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Int64Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Int64);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/Int8Array.cs b/csharp/src/Apache.Arrow/Arrays/Int8Array.cs\nnew file mode 100644\nindex 0000000000..67e68bd097\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/Int8Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class Int8Array : PrimitiveArray<sbyte>\n+    {\n+        public Int8Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(Int8Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public Int8Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Int8);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/ListArray.cs b/csharp/src/Apache.Arrow/Arrays/ListArray.cs\nnew file mode 100644\nindex 0000000000..e3872bceb0\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/ListArray.cs\n@@ -0,0 +1,56 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class ListArray : Array\n+    {\n+        public IArrowArray Values { get; }\n+\n+        public ArrowBuffer ValueOffsetsBuffer => Data.Buffers[1];\n+\n+        public ListArray(IArrowType dataType, int length,\n+            ArrowBuffer valueOffsetsBuffer, IArrowArray values,\n+            ArrowBuffer nullBitmapBuffer, int nullCount = 0, int offset = 0)\n+            : this(new ArrayData(dataType, length, nullCount, offset,\n+                new[] {nullBitmapBuffer, valueOffsetsBuffer}, new[] {values.Data}))\n+        {\n+            Values = values;\n+        }\n+\n+        public ListArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureBufferCount(2);\n+            data.EnsureDataType(ArrowTypeId.List);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public int GetValueOffset(int index)\n+        {\n+            var span = ValueOffsetsBuffer.GetSpan<int>(Offset);\n+            return span[index];\n+        }\n+\n+        public int GetValueLength(int index)\n+        {\n+            var span = ValueOffsetsBuffer.GetSpan<int>(Offset);\n+            return span[index + 1] - span[index];\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/PrimitiveArray.cs b/csharp/src/Apache.Arrow/Arrays/PrimitiveArray.cs\nnew file mode 100644\nindex 0000000000..6dcb10333d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/PrimitiveArray.cs\n@@ -0,0 +1,70 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Runtime.CompilerServices;\n+using Apache.Arrow.Memory;\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public abstract class PrimitiveArray<T> : Array\n+        where T : struct\n+    {\n+        \n+    protected PrimitiveArray(ArrayData data)\n+        : base(data)\n+    {\n+        data.EnsureBufferCount(2);\n+    }\n+\n+    public ArrowBuffer ValueBuffer => Data.Buffers[1];\n+\n+    public Span<T> GetSpan() => ValueBuffer.GetSpan<T>().Slice(0, Length);\n+\n+    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+    public T? GetValue(int index)\n+    {\n+        var span = GetSpan();\n+        return IsValid(index) ? span[index] : (T?) null;\n+    }\n+\n+    public IList<T?> ToList(bool includeNulls = false)\n+    {\n+        var span = GetSpan();\n+        var list = new List<T?>(span.Length);\n+\n+        for (var i = 0; i < span.Length; i++)\n+        {\n+            var value = GetValue(i);\n+\n+            if (value.HasValue)\n+            {\n+                list.Add(value.Value);\n+            }\n+            else\n+            {\n+                if (includeNulls)\n+                {\n+                    list.Add(null);\n+                }\n+            }\n+        }\n+\n+        return list;\n+    }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/StringArray.cs b/csharp/src/Apache.Arrow/Arrays/StringArray.cs\nnew file mode 100644\nindex 0000000000..3c8f8c0599\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/StringArray.cs\n@@ -0,0 +1,51 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Runtime.InteropServices;\n+using System.Text;\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class StringArray: BinaryArray\n+    {\n+        public StringArray(ArrayData data) \n+            : base(ArrowTypeId.String, data) { }\n+\n+        public StringArray(int length,\n+            ArrowBuffer valueOffsetsBuffer,\n+            ArrowBuffer dataBuffer,\n+            ArrowBuffer nullBitmapBuffer,\n+            int nullCount = 0, int offset = 0)\n+            : this(new ArrayData(StringType.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueOffsetsBuffer, dataBuffer }))\n+        { }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public string GetString(int index, Encoding encoding = default)\n+        {\n+            encoding = encoding ?? Encoding.UTF8;\n+\n+            var value = GetValue(index);\n+\n+            unsafe\n+            {\n+                fixed (byte* data = &MemoryMarshal.GetReference(value))\n+                    return encoding.GetString(data, value.Length);\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/StructArray.cs b/csharp/src/Apache.Arrow/Arrays/StructArray.cs\nnew file mode 100644\nindex 0000000000..a9dc5bc202\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/StructArray.cs\n@@ -0,0 +1,48 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow\n+{\n+    public class StructArray : Array\n+    {\n+        private readonly List<Array> _fields;\n+\n+        public IEnumerable<Array> Fields => _fields;\n+\n+        public StructArray(\n+            IArrowType dataType, int length,\n+            IEnumerable<Array> children,\n+            ArrowBuffer nullBitmapBuffer, int nullCount = 0, int offset = 0)\n+        : this(new ArrayData(\n+            dataType, length, nullCount, offset, new[] { nullBitmapBuffer }, \n+            children.Select(child => child.Data)))\n+        { }\n+\n+        public StructArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Struct);\n+\n+            _fields = new List<Array>();\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/TimestampArray.cs b/csharp/src/Apache.Arrow/Arrays/TimestampArray.cs\nnew file mode 100644\nindex 0000000000..174f6500a1\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/TimestampArray.cs\n@@ -0,0 +1,67 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+using System.IO;\n+\n+namespace Apache.Arrow\n+{\n+    public class TimestampArray: PrimitiveArray<long>\n+    {\n+        public TimestampArray(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(TimestampType.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public TimestampArray(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Timestamp);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+        public DateTimeOffset? GetTimestamp(int index)\n+        {\n+            var span = GetSpan();\n+\n+            if (IsNull(index))\n+            {\n+                return null;\n+            }\n+\n+            var value = span[index];\n+            var type = Data.DataType as TimestampType;\n+\n+            switch (type.Unit)\n+            {\n+                case TimeUnit.Nanosecond:\n+                    return DateTimeOffset.FromUnixTimeMilliseconds(value / 1000000);\n+                case TimeUnit.Microsecond:\n+                    return DateTimeOffset.FromUnixTimeMilliseconds(value / 1000);\n+                case TimeUnit.Millisecond:\n+                    return DateTimeOffset.FromUnixTimeMilliseconds(value);\n+                case TimeUnit.Second:\n+                    return DateTimeOffset.FromUnixTimeSeconds(value);\n+                default:\n+                    throw new InvalidDataException(\n+                        string.Format(\"Unsupported timestamp unit <{0}>\", type.Unit));\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/UInt16Array.cs b/csharp/src/Apache.Arrow/Arrays/UInt16Array.cs\nnew file mode 100644\nindex 0000000000..8ffe3c166c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/UInt16Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class UInt16Array : PrimitiveArray<ushort>\n+    {\n+        public UInt16Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(UInt16Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public UInt16Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.UInt16);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+    }\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/UInt32Array.cs b/csharp/src/Apache.Arrow/Arrays/UInt32Array.cs\nnew file mode 100644\nindex 0000000000..0321ea59af\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/UInt32Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class UInt32Array : PrimitiveArray<uint>\n+    {\n+        public UInt32Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(UInt32Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public UInt32Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.UInt32);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/UInt64Array.cs b/csharp/src/Apache.Arrow/Arrays/UInt64Array.cs\nnew file mode 100644\nindex 0000000000..09b1e6d37a\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/UInt64Array.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class UInt64Array : PrimitiveArray<ulong>\n+    {\n+        public UInt64Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(UInt64Type.Default, length, nullCount, offset,\n+                new[] { nullBitmapBuffer, valueBuffer }))\n+        { }\n+\n+        public UInt64Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.UInt64);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/UInt8Array.cs b/csharp/src/Apache.Arrow/Arrays/UInt8Array.cs\nnew file mode 100644\nindex 0000000000..e4506b5c56\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/UInt8Array.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public class UInt8Array : PrimitiveArray<byte>\n+    {\n+        public UInt8Array(\n+            ArrowBuffer valueBuffer, ArrowBuffer nullBitmapBuffer,\n+            int length, int nullCount, int offset)\n+            : this(new ArrayData(UInt8Type.Default, length, nullCount, offset, \n+                new[] { nullBitmapBuffer, valueBuffer })) { }\n+\n+        public UInt8Array(ArrayData data)\n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.UInt8);\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Arrays/UnionArray.cs b/csharp/src/Apache.Arrow/Arrays/UnionArray.cs\nnew file mode 100644\nindex 0000000000..7ba7f9f5b8\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Arrays/UnionArray.cs\n@@ -0,0 +1,51 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    public class UnionArray: Array\n+    {\n+        public UnionType Type => Data.DataType as UnionType;\n+\n+        public UnionMode Mode => Type.Mode;\n+\n+        public ArrowBuffer TypeBuffer => Data.Buffers[1];\n+\n+        public ArrowBuffer ValueOffsetBuffer => Data.Buffers[2];\n+\n+        public ReadOnlySpan<byte> TypeIds => TypeBuffer.GetSpan<byte>();\n+\n+        public ReadOnlySpan<int> ValueOffsets => ValueOffsetBuffer.GetSpan<int>();\n+\n+        public UnionArray(ArrayData data) \n+            : base(data)\n+        {\n+            data.EnsureDataType(ArrowTypeId.Union);\n+            data.EnsureBufferCount(3);\n+        }\n+\n+        public IArrowArray GetChild(int index)\n+        {\n+            // TODO: Implement\n+            throw new NotImplementedException();\n+        }\n+\n+        public override void Accept(IArrowArrayVisitor visitor) => Accept(this, visitor);\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs b/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs\nnew file mode 100644\nindex 0000000000..a85fa2dc9d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/ArrowBuffer.Builder.cs\n@@ -0,0 +1,86 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Memory;\n+using System;\n+using System.Collections.Generic;\n+using System.Runtime.CompilerServices;\n+using System.Runtime.InteropServices;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class ArrowBuffer\n+    {\n+        /// <summary>\n+        /// Builds an Arrow buffer from primitive values.\n+        /// </summary>\n+        /// <typeparam name=\"T\">Primitive type</typeparam>\n+        public class Builder<T>\n+            where T : struct\n+        {\n+            private readonly int _size;\n+            private readonly MemoryPool _pool;\n+            private Memory<byte> _memory;\n+            private int _offset;\n+\n+            public Builder(int initialCapacity = 8, MemoryPool pool = default)\n+            {\n+                if (initialCapacity <= 0) initialCapacity = 1;\n+                if (pool == null) pool = DefaultMemoryPool.Instance.Value;\n+\n+                _size = Unsafe.SizeOf<T>();\n+                _pool = pool;\n+                _memory = _pool.Allocate(initialCapacity * _size);\n+            }\n+\n+            public Builder<T> Append(T value)\n+            {\n+                var span = GetSpan();\n+\n+                if (_offset + 1 >= span.Length)\n+                {\n+                    // TODO: Consider a specifiable growth strategy\n+\n+                    _memory = _pool.Reallocate(_memory, (_memory.Length * 3) / 2);\n+                }\n+\n+                span[_offset++] = value;\n+                return this;\n+            }\n+\n+            public Builder<T> Set(int index, T value)\n+            {\n+                var span = GetSpan();\n+                span[index] = value;\n+                return this;\n+            }\n+\n+            public Builder<T> Clear()\n+            {\n+                var span = GetSpan();\n+                span.Fill(default);\n+                return this;\n+            }\n+\n+            public ArrowBuffer Build()\n+            {\n+                return new ArrowBuffer(_memory, _offset);\n+            }\n+\n+            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+            private Span<T> GetSpan() => MemoryMarshal.Cast<byte, T>(_memory.Span);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/ArrowBuffer.cs b/csharp/src/Apache.Arrow/ArrowBuffer.cs\nnew file mode 100644\nindex 0000000000..ec2c3cbe8c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/ArrowBuffer.cs\n@@ -0,0 +1,128 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Memory;\n+using System;\n+using System.Buffers;\n+using System.IO;\n+using System.Runtime.InteropServices;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class ArrowBuffer: IEquatable<ArrowBuffer>\n+    {\n+        public ArrowBuffer(Memory<byte> data, int size)\n+        {\n+            Memory = data;\n+            Size = size;\n+        }\n+\n+        /// <summary>\n+        /// Allocates an Arrow buffer from a memory pool.\n+        /// </summary>\n+        /// <param name=\"size\">Size of buffer (in bytes) to allocate.</param>\n+        /// <param name=\"memoryPool\">Memory pool to use for allocation. If null, a default memory pool is used.</param>\n+        /// <returns></returns>\n+        public static ArrowBuffer Allocate(int size, MemoryPool memoryPool = null)\n+        {\n+            if (memoryPool == null)\n+                memoryPool = DefaultMemoryPool.Instance.Value;\n+\n+            var buffer = memoryPool.Allocate(size);\n+\n+            return new ArrowBuffer(buffer, size);\n+        }\n+\n+        /// <summary>\n+        /// Allocates an Arrow buffer the same length as the incoming data, then\n+        /// copies the specified data to the arrow buffer.\n+        /// </summary>\n+        /// <param name=\"data\">Data to copy into a new arrow buffer.</param>\n+        /// <param name=\"memoryPool\">Memory pool to use for allocation. If null, a default memory pool is used.</param>\n+        /// <returns></returns>\n+        public static ArrowBuffer FromMemory(Memory<byte> data, MemoryPool memoryPool = default)\n+        {\n+            var buffer = Allocate(data.Length, memoryPool);\n+            data.CopyTo(buffer.Memory);\n+            return buffer;\n+        }\n+\n+        public async Task CopyToAsync(Stream stream, CancellationToken cancellationToken = default)\n+        {\n+            const float chunkSize = 8192f;\n+\n+            // TODO: Is there a better copy mechanism to use here that does not involve allocating buffers and targets .NET Standard 1.3?\n+            // NOTE: Consider specialization for .NET Core 2.1\n+\n+            var length = Convert.ToInt32(chunkSize);\n+            var buffer = ArrayPool<byte>.Shared.Rent(length);\n+            var count = Convert.ToInt32(Math.Ceiling(Memory.Length / chunkSize));\n+            var offset = 0;\n+\n+            try\n+            {\n+                for (var i = 0; i < count; i++)\n+                {\n+                    var n = Math.Min(length, Memory.Length);\n+                    var slice = Memory.Slice(offset, n);\n+\n+                    slice.CopyTo(buffer);\n+\n+                    await stream.WriteAsync(buffer, 0, n, cancellationToken);\n+\n+                    offset += n;\n+                }\n+            }\n+            finally\n+            {\n+                if (buffer != null)\n+                {\n+                    ArrayPool<byte>.Shared.Return(buffer);\n+                }\n+            }\n+        }\n+\n+        public Memory<byte> Memory { get; }\n+\n+        public bool IsEmpty => Memory.IsEmpty;\n+\n+        public int Size { get; }\n+\n+        public int Capacity => Memory.Length;\n+\n+        public Span<T> GetSpan<T>(int offset)\n+            where T : struct =>\n+            MemoryMarshal.Cast<byte, T>(\n+                Memory.Span.Slice(offset));\n+\n+        public Span<T> GetSpan<T>(int offset, int length)\n+            where T : struct =>\n+            MemoryMarshal.Cast<byte, T>(\n+                Memory.Span.Slice(offset, length));\n+\n+        public Span<T> GetSpan<T>()\n+            where T: struct =>\n+            MemoryMarshal.Cast<byte, T>(Memory.Span);\n+\n+        public bool Equals(ArrowBuffer other)\n+        {\n+            var lhs = GetSpan<byte>();\n+            var rhs = other.GetSpan<byte>();\n+            return lhs.SequenceEqual(rhs);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/BitUtility.cs b/csharp/src/Apache.Arrow/BitUtility.cs\nnew file mode 100644\nindex 0000000000..ea5a556162\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/BitUtility.cs\n@@ -0,0 +1,122 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Diagnostics;\n+\n+namespace Apache.Arrow\n+{\n+    public static class BitUtility\n+    {\n+        private static readonly byte[] PopcountTable = new byte[]\n+        {\n+            0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n+            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+            1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n+            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+            2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n+            3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8,\n+        };\n+\n+        private static readonly byte[] BitMask = new byte[]\n+        {\n+            1, 2, 4, 8, 16, 32, 64, 128\n+        };\n+\n+        public static bool GetBit(byte data, int index) =>\n+            ((data >> index) & 1) != 0;\n+\n+        public static bool GetBit(ReadOnlySpan<byte> data, int index) =>\n+            (data[index / 8] & BitMask[index % 8]) != 0;\n+\n+        public static void ClearBit(Span<byte> data, int index)\n+        {\n+            data[index / 8] &= (byte) ~BitMask[index % 8];\n+        }\n+\n+        public static void SetBit(Span<byte> data, int index)\n+        {\n+            data[index / 8] |= BitMask[index % 8];\n+        }\n+\n+        /// <summary>\n+        /// Counts the number of set bits in a span of bytes starting\n+        /// at a specific bit offset.\n+        /// </summary>\n+        /// <param name=\"data\">Span to count bits</param>\n+        /// <param name=\"offset\">Bit offset to start counting from</param>\n+        /// <returns>Count of set (one) bits/returns>\n+        public static int CountBits(ReadOnlySpan<byte> data, int offset)\n+        {\n+            var start = (offset / 8);\n+            var startBit = offset % 8;\n+\n+            if (startBit < 0) return 0;\n+            if (startBit == 0) return CountBits(data);\n+\n+            var count = 0;\n+\n+            count += CountBits(data.Slice(start + 1));\n+\n+            for (var i = startBit; i < 8; i++)\n+            {\n+                if (GetBit(data.Slice(start, 1), i))\n+                    count++;\n+            }\n+\n+            return count;\n+        }\n+\n+        /// <summary>\n+        /// Counts the number of set bits in a span of bytes.\n+        /// </summary>\n+        /// <param name=\"data\">Span to count bits</param>\n+        /// <returns>Count of set (one) bits.</returns>\n+        public static int CountBits(ReadOnlySpan<byte> data)\n+        {\n+            var count = 0;\n+            foreach (var t in data)\n+                count += PopcountTable[t];\n+            return count;\n+        }\n+\n+        /// <summary>\n+        /// Rounds an integer to the nearest multiple of 64.\n+        /// </summary>\n+        /// <param name=\"n\">Integer to round.</param>\n+        /// <returns>Integer rounded to the nearest multiple of 64.</returns>\n+        public static int RoundUpToMultipleOf64(int n) =>\n+            RoundUpToMultiplePowerOfTwo(n, 64);\n+\n+        /// <summary>\n+        /// Rounds an integer up to the nearest multiple of factor, where\n+        /// factor must be a power of two.\n+        /// \n+        /// This function does not throw when the factor is not a power of two.\n+        /// </summary>\n+        /// <param name=\"n\">Integer to round up.</param>\n+        /// <param name=\"factor\">Power of two factor to round up to.</param>\n+        /// <returns>Integer rounded up to the nearest power of two.</returns>\n+        public static int RoundUpToMultiplePowerOfTwo(int n, int factor)\n+        {\n+            // Assert that factor is a power of two.\n+            Debug.Assert(factor > 0 && (factor & (factor - 1)) == 0);\n+            return (n + (factor - 1)) & ~(factor - 1);\n+        }\n+            \n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Bitmap.cs b/csharp/src/Apache.Arrow/Bitmap.cs\nnew file mode 100644\nindex 0000000000..257438b323\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Bitmap.cs\n@@ -0,0 +1,75 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Memory;\n+\n+namespace Apache.Arrow\n+{\n+    public struct Bitmap\n+    {\n+        public ArrowBuffer Buffer { get; }\n+\n+        public int Length => Buffer.Size;\n+\n+        public Bitmap(ArrowBuffer buffer)\n+        {\n+            Buffer = buffer;\n+        }\n+\n+        public static implicit operator Bitmap(ArrowBuffer buffer)\n+        {\n+            return new Bitmap(buffer);\n+        }\n+\n+        public static implicit operator ArrowBuffer(Bitmap bitmap)\n+        {\n+            return bitmap.Buffer;\n+        }\n+\n+        public static Bitmap Allocate(int bitCount, MemoryPool memoryPool = default)\n+        {\n+            var size = bitCount / 8 + (bitCount % 8 > 0 ? 1 : 0);\n+            var remainder = size % 64;\n+            var len = (remainder == 0) ? size : size + 64 - remainder;\n+            \n+            // Allocate buffer from memory pool and enable all bits\n+\n+            var buffer = ArrowBuffer.Allocate(len, memoryPool);\n+            var span = buffer.GetSpan<byte>();\n+\n+            span.Fill(0xff);\n+\n+            return new Bitmap(buffer);\n+        }\n+\n+        public void Clear(int index)\n+        {\n+            BitUtility.ClearBit(\n+                Buffer.GetSpan<byte>(), index);\n+        }\n+\n+        public void Set(int index)\n+        {\n+            BitUtility.SetBit(\n+                Buffer.GetSpan<byte>(), index);\n+        }\n+\n+        public bool IsSet(int index)\n+        {\n+            return BitUtility.GetBit(\n+                Buffer.GetSpan<byte>(), index);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Extensions/ArrayDataExtensions.cs b/csharp/src/Apache.Arrow/Extensions/ArrayDataExtensions.cs\nnew file mode 100644\nindex 0000000000..3cc4c139ec\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Extensions/ArrayDataExtensions.cs\n@@ -0,0 +1,53 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    internal static class ArrayDataExtensions\n+    {\n+        public static void EnsureBufferCount(this ArrayData data, int count)\n+        {\n+            if (data.Buffers.Length != count)\n+            {\n+                // TODO: Use localizable string resource\n+                throw new ArgumentException(\n+                    $\"Buffer count <{data.Buffers.Length}> must be at least <{count}>\",\n+                    nameof(data.Buffers.Length));\n+            }\n+        }\n+\n+        public static void EnsureDataType(this ArrayData data, params ArrowTypeId[] ids)\n+        {\n+            var valid = true;\n+\n+            foreach (var id in ids)\n+            {\n+                if (data.DataType.TypeId != id)\n+                    valid = false;\n+            }\n+\n+            if (!valid)\n+            {\n+                // TODO: Use localizable string resource\n+                throw new ArgumentException(\n+                    $\"Specified array type <{data.DataType.TypeId}> does not match expected type(s) <{string.Join(\",\", ids)}>\",\n+                    nameof(data.DataType.TypeId));\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Extensions/ArrayPoolExtensions.cs b/csharp/src/Apache.Arrow/Extensions/ArrayPoolExtensions.cs\nnew file mode 100644\nindex 0000000000..e65a3ef86f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Extensions/ArrayPoolExtensions.cs\n@@ -0,0 +1,63 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Runtime.CompilerServices;\n+using System.Threading.Tasks;\n+\n+namespace Apache.Arrow\n+{\n+    internal static class ArrayPoolExtensions\n+    {\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        public static void RentReturn(this ArrayPool<byte> pool, int length, Action<byte[]> action)\n+        {\n+            byte[] array = null;\n+\n+            try\n+            {\n+                array = pool.Rent(length);\n+                action(array);\n+            }\n+            finally\n+            {\n+                if (array != null)\n+                {\n+                    pool.Return(array);\n+                }\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        public static Task RentReturnAsync(this ArrayPool<byte> pool, int length, Func<byte[], Task> action)\n+        {\n+            byte[] array = null;\n+\n+            try\n+            {\n+                array = pool.Rent(length);\n+                return action(array);\n+            }\n+            finally\n+            {\n+                if (array != null)\n+                {\n+                    pool.Return(array);\n+                }\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Extensions/ArrowTypeExtensions.cs b/csharp/src/Apache.Arrow/Extensions/ArrowTypeExtensions.cs\nnew file mode 100644\nindex 0000000000..14e2b90a3c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Extensions/ArrowTypeExtensions.cs\n@@ -0,0 +1,42 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Collections.Generic;\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public static class ArrowTypeExtensions\n+    {\n+        private static readonly ISet<ArrowTypeId> IntegralTypes = \n+            new HashSet<ArrowTypeId>(new[]\n+            {\n+                ArrowTypeId.Int8, ArrowTypeId.Int16, ArrowTypeId.Int32, ArrowTypeId.Int64,\n+                ArrowTypeId.UInt8, ArrowTypeId.UInt16, ArrowTypeId.UInt32, ArrowTypeId.UInt64,\n+            });\n+\n+        private static readonly ISet<ArrowTypeId> FloatingPointTypes =\n+            new HashSet<ArrowTypeId>(new[]\n+            {\n+                ArrowTypeId.HalfFloat, ArrowTypeId.Float, ArrowTypeId.Double\n+            });\n+\n+        public static bool IsIntegral(this IArrowType type) \n+            => IntegralTypes.Contains(type.TypeId);\n+\n+        public static bool IsFloatingPoint(this IArrowType type)\n+            => FloatingPointTypes.Contains(type.TypeId);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Extensions/FlatbufExtensions.cs b/csharp/src/Apache.Arrow/Extensions/FlatbufExtensions.cs\nnew file mode 100644\nindex 0000000000..d2a70bca9e\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Extensions/FlatbufExtensions.cs\n@@ -0,0 +1,85 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+\n+namespace Apache.Arrow\n+{\n+    internal static class FlatbufExtensions\n+    {\n+        public static bool IsFixedPrimitive(this Flatbuf.Type t)\n+        {\n+            if (t == Flatbuf.Type.Utf8 || t == Flatbuf.Type.Binary)\n+                return false;\n+            return true;\n+        }\n+\n+        public static bool IsFixedPrimitive(this Types.IArrowType t)\n+        {\n+            return t.TypeId.IsFixedPrimitive();\n+        }\n+\n+        public static bool IsFixedPrimitive(this Types.ArrowTypeId t)\n+        {\n+            if (t == Types.ArrowTypeId.String || t == Types.ArrowTypeId.Binary)\n+                return false;\n+            return true;\n+        }\n+\n+        public static Types.IntervalUnit ToArrow(this Flatbuf.IntervalUnit unit)\n+        {\n+            switch (unit)\n+            {\n+                case Flatbuf.IntervalUnit.DAY_TIME:\n+                    return Types.IntervalUnit.DayTime;\n+                case Flatbuf.IntervalUnit.YEAR_MONTH:\n+                    return Types.IntervalUnit.YearMonth;\n+                default:\n+                    throw new ArgumentException($\"Unexpected Flatbuf IntervalUnit\", nameof(unit));\n+            }\n+        }\n+\n+        public static Types.DateUnit ToArrow(this Flatbuf.DateUnit unit)\n+        {\n+            switch (unit)\n+            {\n+                case Flatbuf.DateUnit.DAY:\n+                    return Types.DateUnit.Day;\n+                case Flatbuf.DateUnit.MILLISECOND:\n+                    return Types.DateUnit.Milliseconds;\n+                default:\n+                    throw new ArgumentException($\"Unexpected Flatbuf IntervalUnit\", nameof(unit));\n+            }\n+        }\n+\n+        public static Types.TimeUnit ToArrow(this Flatbuf.TimeUnit unit)\n+        {\n+            switch (unit)\n+            {\n+                case Flatbuf.TimeUnit.MICROSECOND:\n+                    return Types.TimeUnit.Microsecond;\n+                case Flatbuf.TimeUnit.MILLISECOND:\n+                    return Types.TimeUnit.Millisecond;\n+                case Flatbuf.TimeUnit.NANOSECOND:\n+                    return Types.TimeUnit.Nanosecond;\n+                case Flatbuf.TimeUnit.SECOND:\n+                    return Types.TimeUnit.Second;\n+                default:\n+                    throw new ArgumentException($\"Unexpected Flatbuf TimeUnit\", nameof(unit));\n+            }\n+        }\n+    }\n+}\n+\ndiff --git a/csharp/src/Apache.Arrow/Field.Builder.cs b/csharp/src/Apache.Arrow/Field.Builder.cs\nnew file mode 100644\nindex 0000000000..fede4ea73f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Field.Builder.cs\n@@ -0,0 +1,79 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class Field\n+    {\n+        public class Builder\n+        {\n+            private readonly Dictionary<string, string> _metadata;\n+            private string _name;\n+            private IArrowType _type;\n+            private bool _nullable;\n+\n+            public Builder()\n+            {\n+                _metadata = new Dictionary<string, string>();\n+                _name = string.Empty;\n+                _type = NullType.Default;\n+                _nullable = true;\n+            }\n+\n+            public Builder Name(string value)\n+            {\n+                if (string.IsNullOrWhiteSpace(value))\n+                {\n+                    throw new ArgumentNullException(nameof(value));\n+                }\n+\n+                _name = value;\n+                return this;\n+            }\n+\n+            public Builder DataType(IArrowType type)\n+            {\n+                _type = type ?? NullType.Default;\n+                return this;\n+            }\n+\n+            public Builder Nullable(bool value)\n+            {\n+                _nullable = value;\n+                return this;\n+            }\n+\n+            public Builder Metadata(string key, string value)\n+            {\n+                if (string.IsNullOrWhiteSpace(key))\n+                {\n+                    throw new ArgumentNullException(nameof(key));\n+                }\n+\n+                _metadata[key] = value;\n+                return this;\n+            }\n+\n+            public Field Build()\n+            {\n+                return new Field(_name, _type, _nullable, _metadata);\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Field.cs b/csharp/src/Apache.Arrow/Field.cs\nnew file mode 100644\nindex 0000000000..33aefb7030\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Field.cs\n@@ -0,0 +1,49 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using Apache.Arrow.Types;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class Field\n+    {\n+        public IArrowType DataType { get; }\n+\n+        public string Name { get; }\n+\n+        public bool IsNullable { get; }\n+\n+        public bool HasMetadata => Metadata?.Count > 0;\n+\n+        public IReadOnlyDictionary<string, string> Metadata { get; }\n+\n+        public Field(string name, IArrowType dataType, bool nullable,\n+            IEnumerable<KeyValuePair<string, string>> metadata = default)\n+        {\n+            if (string.IsNullOrWhiteSpace(name))\n+            {\n+                throw new ArgumentNullException(nameof(name));\n+            }\n+\n+            Name = name;\n+            DataType = dataType ?? NullType.Default;\n+            IsNullable = nullable;\n+            Metadata = metadata?.ToDictionary(kv => kv.Key, kv => kv.Value);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Block.cs b/csharp/src/Apache.Arrow/Flatbuf/Block.cs\nnew file mode 100644\nindex 0000000000..ec97fd19be\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Block.cs\n@@ -0,0 +1,37 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Block : IFlatbufferObject\n+{\n+  private Struct __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Block __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Index to the start of the RecordBlock (note this is past the Message header)\n+  public long Offset { get { return __p.bb.GetLong(__p.bb_pos + 0); } }\n+  /// Length of the metadata\n+  public int MetaDataLength { get { return __p.bb.GetInt(__p.bb_pos + 8); } }\n+  /// Length of the data (this is aligned so there can be a gap between this and\n+  /// the metatdata).\n+  public long BodyLength { get { return __p.bb.GetLong(__p.bb_pos + 16); } }\n+\n+  public static Offset<Block> CreateBlock(FlatBufferBuilder builder, long Offset, int MetaDataLength, long BodyLength) {\n+    builder.Prep(8, 24);\n+    builder.PutLong(BodyLength);\n+    builder.Pad(4);\n+    builder.PutInt(MetaDataLength);\n+    builder.PutLong(Offset);\n+    return new Offset<Block>(builder.Offset);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Buffer.cs b/csharp/src/Apache.Arrow/Flatbuf/Buffer.cs\nnew file mode 100644\nindex 0000000000..25506f8f57\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Buffer.cs\n@@ -0,0 +1,36 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// A Buffer represents a single contiguous memory segment\n+public struct Buffer : IFlatbufferObject\n+{\n+  private Struct __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Buffer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// The relative offset into the shared memory page where the bytes for this\n+  /// buffer starts\n+  public long Offset { get { return __p.bb.GetLong(__p.bb_pos + 0); } }\n+  /// The absolute length (in bytes) of the memory buffer. The memory is found\n+  /// from offset (inclusive) to offset + length (non-inclusive).\n+  public long Length { get { return __p.bb.GetLong(__p.bb_pos + 8); } }\n+\n+  public static Offset<Buffer> CreateBuffer(FlatBufferBuilder builder, long Offset, long Length) {\n+    builder.Prep(8, 16);\n+    builder.PutLong(Length);\n+    builder.PutLong(Offset);\n+    return new Offset<Buffer>(builder.Offset);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/DictionaryBatch.cs b/csharp/src/Apache.Arrow/Flatbuf/DictionaryBatch.cs\nnew file mode 100644\nindex 0000000000..e16bf15992\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/DictionaryBatch.cs\n@@ -0,0 +1,54 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// For sending dictionary encoding information. Any Field can be\n+/// dictionary-encoded, but in this case none of its children may be\n+/// dictionary-encoded.\n+/// There is one vector / column per dictionary, but that vector / column\n+/// may be spread across multiple dictionary batches by using the isDelta\n+/// flag\n+public struct DictionaryBatch : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static DictionaryBatch GetRootAsDictionaryBatch(ByteBuffer _bb) { return GetRootAsDictionaryBatch(_bb, new DictionaryBatch()); }\n+  public static DictionaryBatch GetRootAsDictionaryBatch(ByteBuffer _bb, DictionaryBatch obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public DictionaryBatch __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public long Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }\n+  public RecordBatch? Data { get { int o = __p.__offset(6); return o != 0 ? (RecordBatch?)(new RecordBatch()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }\n+  /// If isDelta is true the values in the dictionary are to be appended to a\n+  /// dictionary with the indicated id\n+  public bool IsDelta { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }\n+\n+  public static Offset<DictionaryBatch> CreateDictionaryBatch(FlatBufferBuilder builder,\n+      long id = 0,\n+      Offset<RecordBatch> dataOffset = default(Offset<RecordBatch>),\n+      bool isDelta = false) {\n+    builder.StartObject(3);\n+    DictionaryBatch.AddId(builder, id);\n+    DictionaryBatch.AddData(builder, dataOffset);\n+    DictionaryBatch.AddIsDelta(builder, isDelta);\n+    return DictionaryBatch.EndDictionaryBatch(builder);\n+  }\n+\n+  public static void StartDictionaryBatch(FlatBufferBuilder builder) { builder.StartObject(3); }\n+  public static void AddId(FlatBufferBuilder builder, long id) { builder.AddLong(0, id, 0); }\n+  public static void AddData(FlatBufferBuilder builder, Offset<RecordBatch> dataOffset) { builder.AddOffset(1, dataOffset.Value, 0); }\n+  public static void AddIsDelta(FlatBufferBuilder builder, bool isDelta) { builder.AddBool(2, isDelta, false); }\n+  public static Offset<DictionaryBatch> EndDictionaryBatch(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<DictionaryBatch>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/DictionaryEncoding.cs b/csharp/src/Apache.Arrow/Flatbuf/DictionaryEncoding.cs\nnew file mode 100644\nindex 0000000000..282caf304e\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/DictionaryEncoding.cs\n@@ -0,0 +1,57 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// Dictionary encoding metadata\n+public struct DictionaryEncoding : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static DictionaryEncoding GetRootAsDictionaryEncoding(ByteBuffer _bb) { return GetRootAsDictionaryEncoding(_bb, new DictionaryEncoding()); }\n+  public static DictionaryEncoding GetRootAsDictionaryEncoding(ByteBuffer _bb, DictionaryEncoding obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public DictionaryEncoding __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// The known dictionary id in the application where this data is used. In\n+  /// the file or streaming formats, the dictionary ids are found in the\n+  /// DictionaryBatch messages\n+  public long Id { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }\n+  /// The dictionary indices are constrained to be positive integers. If this\n+  /// field is null, the indices must be signed int32\n+  public Int? IndexType { get { int o = __p.__offset(6); return o != 0 ? (Int?)(new Int()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }\n+  /// By default, dictionaries are not ordered, or the order does not have\n+  /// semantic meaning. In some statistical, applications, dictionary-encoding\n+  /// is used to represent ordered categorical data, and we provide a way to\n+  /// preserve that metadata here\n+  public bool IsOrdered { get { int o = __p.__offset(8); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }\n+\n+  public static Offset<DictionaryEncoding> CreateDictionaryEncoding(FlatBufferBuilder builder,\n+      long id = 0,\n+      Offset<Int> indexTypeOffset = default(Offset<Int>),\n+      bool isOrdered = false) {\n+    builder.StartObject(3);\n+    DictionaryEncoding.AddId(builder, id);\n+    DictionaryEncoding.AddIndexType(builder, indexTypeOffset);\n+    DictionaryEncoding.AddIsOrdered(builder, isOrdered);\n+    return DictionaryEncoding.EndDictionaryEncoding(builder);\n+  }\n+\n+  public static void StartDictionaryEncoding(FlatBufferBuilder builder) { builder.StartObject(3); }\n+  public static void AddId(FlatBufferBuilder builder, long id) { builder.AddLong(0, id, 0); }\n+  public static void AddIndexType(FlatBufferBuilder builder, Offset<Int> indexTypeOffset) { builder.AddOffset(1, indexTypeOffset.Value, 0); }\n+  public static void AddIsOrdered(FlatBufferBuilder builder, bool isOrdered) { builder.AddBool(2, isOrdered, false); }\n+  public static Offset<DictionaryEncoding> EndDictionaryEncoding(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<DictionaryEncoding>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/DateUnit.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/DateUnit.cs\nnew file mode 100644\nindex 0000000000..66c0740204\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/DateUnit.cs\n@@ -0,0 +1,15 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum DateUnit : short\n+{\n+ DAY = 0,\n+ MILLISECOND = 1,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/Endianness.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/Endianness.cs\nnew file mode 100644\nindex 0000000000..0609f674c6\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/Endianness.cs\n@@ -0,0 +1,17 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+/// ----------------------------------------------------------------------\n+/// Endianness of the platform producing the data\n+public enum Endianness : short\n+{\n+ Little = 0,\n+ Big = 1,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/IntervalUnit.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/IntervalUnit.cs\nnew file mode 100644\nindex 0000000000..9134b70407\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/IntervalUnit.cs\n@@ -0,0 +1,15 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum IntervalUnit : short\n+{\n+ YEAR_MONTH = 0,\n+ DAY_TIME = 1,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/MessageHeader.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/MessageHeader.cs\nnew file mode 100644\nindex 0000000000..7334de6489\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/MessageHeader.cs\n@@ -0,0 +1,26 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+/// ----------------------------------------------------------------------\n+/// The root Message type\n+/// This union enables us to easily send different message types without\n+/// redundant storage, and in the future we can easily add new message types.\n+///\n+/// Arrow implementations do not need to implement all of the message types,\n+/// which may include experimental metadata types. For maximum compatibility,\n+/// it is best to send data using RecordBatch\n+public enum MessageHeader : byte\n+{\n+ NONE = 0,\n+ Schema = 1,\n+ DictionaryBatch = 2,\n+ RecordBatch = 3,\n+ Tensor = 4,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs\nnew file mode 100644\nindex 0000000000..3b97c2f623\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/MetadataVersion.cs\n@@ -0,0 +1,21 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum MetadataVersion : short\n+{\n+  /// 0.1.0\n+ V1 = 0,\n+  /// 0.2.0\n+ V2 = 1,\n+  /// 0.3.0 -> 0.7.1\n+ V3 = 2,\n+  /// >= 0.8.0\n+ V4 = 3,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/Precision.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/Precision.cs\nnew file mode 100644\nindex 0000000000..8c8552c405\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/Precision.cs\n@@ -0,0 +1,16 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum Precision : short\n+{\n+ HALF = 0,\n+ SINGLE = 1,\n+ DOUBLE = 2,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/TimeUnit.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/TimeUnit.cs\nnew file mode 100644\nindex 0000000000..8a96de0256\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/TimeUnit.cs\n@@ -0,0 +1,17 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum TimeUnit : short\n+{\n+ SECOND = 0,\n+ MILLISECOND = 1,\n+ MICROSECOND = 2,\n+ NANOSECOND = 3,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs\nnew file mode 100644\nindex 0000000000..dce9ac8dd0\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/Type.cs\n@@ -0,0 +1,34 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+/// ----------------------------------------------------------------------\n+/// Top-level Type value, enabling extensible type-specific metadata. We can\n+/// add new logical types to Type without breaking backwards compatibility\n+public enum Type : byte\n+{\n+ NONE = 0,\n+ Null = 1,\n+ Int = 2,\n+ FloatingPoint = 3,\n+ Binary = 4,\n+ Utf8 = 5,\n+ Bool = 6,\n+ Decimal = 7,\n+ Date = 8,\n+ Time = 9,\n+ Timestamp = 10,\n+ Interval = 11,\n+ List = 12,\n+ Struct_ = 13,\n+ Union = 14,\n+ FixedSizeBinary = 15,\n+ FixedSizeList = 16,\n+ Map = 17,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Enums/UnionMode.cs b/csharp/src/Apache.Arrow/Flatbuf/Enums/UnionMode.cs\nnew file mode 100644\nindex 0000000000..bb6ddd3627\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Enums/UnionMode.cs\n@@ -0,0 +1,15 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+public enum UnionMode : short\n+{\n+ Sparse = 0,\n+ Dense = 1,\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Field.cs b/csharp/src/Apache.Arrow/Flatbuf/Field.cs\nnew file mode 100644\nindex 0000000000..a75f2b563f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Field.cs\n@@ -0,0 +1,76 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// A field represents a named column in a record / row batch or child of a\n+/// nested type.\n+///\n+/// - children is only for nested Arrow arrays\n+/// - For primitive types, children will have length 0\n+/// - nullable should default to true in general\n+public struct Field : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Field GetRootAsField(ByteBuffer _bb) { return GetRootAsField(_bb, new Field()); }\n+  public static Field GetRootAsField(ByteBuffer _bb, Field obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Field __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public string Name { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }\n+  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(4); }\n+  public bool Nullable { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }\n+  public Type TypeType { get { int o = __p.__offset(8); return o != 0 ? (Type)__p.bb.Get(o + __p.bb_pos) : Flatbuf.Type.NONE; } }\n+  public TTable? Type<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(10); return o != 0 ? (TTable?)__p.__union<TTable>(o) : null; }\n+  public DictionaryEncoding? Dictionary { get { int o = __p.__offset(12); return o != 0 ? (DictionaryEncoding?)(new DictionaryEncoding()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }\n+  public Field? Children(int j) { int o = __p.__offset(14); return o != 0 ? (Field?)(new Field()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }\n+  public int ChildrenLength { get { int o = __p.__offset(14); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  public KeyValue? CustomMetadata(int j) { int o = __p.__offset(16); return o != 0 ? (KeyValue?)(new KeyValue()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }\n+  public int CustomMetadataLength { get { int o = __p.__offset(16); return o != 0 ? __p.__vector_len(o) : 0; } }\n+\n+  public static Offset<Field> CreateField(FlatBufferBuilder builder,\n+      StringOffset nameOffset = default(StringOffset),\n+      bool nullable = false,\n+      Type type_type = Flatbuf.Type.NONE,\n+      int typeOffset = 0,\n+      Offset<DictionaryEncoding> dictionaryOffset = default(Offset<DictionaryEncoding>),\n+      VectorOffset childrenOffset = default(VectorOffset),\n+      VectorOffset custom_metadataOffset = default(VectorOffset)) {\n+    builder.StartObject(7);\n+    Field.AddCustomMetadata(builder, custom_metadataOffset);\n+    Field.AddChildren(builder, childrenOffset);\n+    Field.AddDictionary(builder, dictionaryOffset);\n+    Field.AddType(builder, typeOffset);\n+    Field.AddName(builder, nameOffset);\n+    Field.AddTypeType(builder, type_type);\n+    Field.AddNullable(builder, nullable);\n+    return Field.EndField(builder);\n+  }\n+\n+  public static void StartField(FlatBufferBuilder builder) { builder.StartObject(7); }\n+  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(0, nameOffset.Value, 0); }\n+  public static void AddNullable(FlatBufferBuilder builder, bool nullable) { builder.AddBool(1, nullable, false); }\n+  public static void AddTypeType(FlatBufferBuilder builder, Type typeType) { builder.AddByte(2, (byte)typeType, 0); }\n+  public static void AddType(FlatBufferBuilder builder, int typeOffset) { builder.AddOffset(3, typeOffset, 0); }\n+  public static void AddDictionary(FlatBufferBuilder builder, Offset<DictionaryEncoding> dictionaryOffset) { builder.AddOffset(4, dictionaryOffset.Value, 0); }\n+  public static void AddChildren(FlatBufferBuilder builder, VectorOffset childrenOffset) { builder.AddOffset(5, childrenOffset.Value, 0); }\n+  public static VectorOffset CreateChildrenVector(FlatBufferBuilder builder, Offset<Field>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }\n+  public static void StartChildrenVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static void AddCustomMetadata(FlatBufferBuilder builder, VectorOffset customMetadataOffset) { builder.AddOffset(6, customMetadataOffset.Value, 0); }\n+  public static VectorOffset CreateCustomMetadataVector(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }\n+  public static void StartCustomMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static Offset<Field> EndField(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Field>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FieldNode.cs b/csharp/src/Apache.Arrow/Flatbuf/FieldNode.cs\nnew file mode 100644\nindex 0000000000..53b01b8f9a\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FieldNode.cs\n@@ -0,0 +1,44 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// Data structures for describing a table row batch (a collection of\n+/// equal-length Arrow arrays)\n+/// Metadata about a field at some level of a nested type tree (but not\n+/// its children).\n+///\n+/// For example, a List<Int16> with values [[1, 2, 3], null, [4], [5, 6], null]\n+/// would have {length: 5, null_count: 2} for its List node, and {length: 6,\n+/// null_count: 0} for its Int16 node, as separate FieldNode structs\n+public struct FieldNode : IFlatbufferObject\n+{\n+  private Struct __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public FieldNode __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// The number of value slots in the Arrow array at this level of a nested\n+  /// tree\n+  public long Length { get { return __p.bb.GetLong(__p.bb_pos + 0); } }\n+  /// The number of observed nulls. Fields with null_count == 0 may choose not\n+  /// to write their physical validity bitmap out as a materialized buffer,\n+  /// instead setting the length of the bitmap buffer to 0.\n+  public long NullCount { get { return __p.bb.GetLong(__p.bb_pos + 8); } }\n+\n+  public static Offset<FieldNode> CreateFieldNode(FlatBufferBuilder builder, long Length, long NullCount) {\n+    builder.Prep(8, 16);\n+    builder.PutLong(NullCount);\n+    builder.PutLong(Length);\n+    return new Offset<FieldNode>(builder.Offset);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FixedSizeBinary.cs b/csharp/src/Apache.Arrow/Flatbuf/FixedSizeBinary.cs\nnew file mode 100644\nindex 0000000000..a022af7e0c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FixedSizeBinary.cs\n@@ -0,0 +1,39 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct FixedSizeBinary : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static FixedSizeBinary GetRootAsFixedSizeBinary(ByteBuffer _bb) { return GetRootAsFixedSizeBinary(_bb, new FixedSizeBinary()); }\n+  public static FixedSizeBinary GetRootAsFixedSizeBinary(ByteBuffer _bb, FixedSizeBinary obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public FixedSizeBinary __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Number of bytes per value\n+  public int ByteWidth { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }\n+\n+  public static Offset<FixedSizeBinary> CreateFixedSizeBinary(FlatBufferBuilder builder,\n+      int byteWidth = 0) {\n+    builder.StartObject(1);\n+    FixedSizeBinary.AddByteWidth(builder, byteWidth);\n+    return FixedSizeBinary.EndFixedSizeBinary(builder);\n+  }\n+\n+  public static void StartFixedSizeBinary(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddByteWidth(FlatBufferBuilder builder, int byteWidth) { builder.AddInt(0, byteWidth, 0); }\n+  public static Offset<FixedSizeBinary> EndFixedSizeBinary(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<FixedSizeBinary>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FixedSizeList.cs b/csharp/src/Apache.Arrow/Flatbuf/FixedSizeList.cs\nnew file mode 100644\nindex 0000000000..12a23d980d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FixedSizeList.cs\n@@ -0,0 +1,39 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct FixedSizeList : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static FixedSizeList GetRootAsFixedSizeList(ByteBuffer _bb) { return GetRootAsFixedSizeList(_bb, new FixedSizeList()); }\n+  public static FixedSizeList GetRootAsFixedSizeList(ByteBuffer _bb, FixedSizeList obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public FixedSizeList __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Number of list items per value\n+  public int ListSize { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }\n+\n+  public static Offset<FixedSizeList> CreateFixedSizeList(FlatBufferBuilder builder,\n+      int listSize = 0) {\n+    builder.StartObject(1);\n+    FixedSizeList.AddListSize(builder, listSize);\n+    return FixedSizeList.EndFixedSizeList(builder);\n+  }\n+\n+  public static void StartFixedSizeList(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddListSize(FlatBufferBuilder builder, int listSize) { builder.AddInt(0, listSize, 0); }\n+  public static Offset<FixedSizeList> EndFixedSizeList(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<FixedSizeList>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBuffer.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBuffer.cs\nnew file mode 100644\nindex 0000000000..307a98fadc\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBuffer.cs\n@@ -0,0 +1,633 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+// There are 2 #defines that have an impact on performance of this ByteBuffer implementation\n+//\n+//      UNSAFE_BYTEBUFFER \n+//          This will use unsafe code to manipulate the underlying byte array. This\n+//          can yield a reasonable performance increase.\n+//\n+//      BYTEBUFFER_NO_BOUNDS_CHECK\n+//          This will disable the bounds check asserts to the byte array. This can\n+//          yield a small performance gain in normal code..\n+//\n+// Using UNSAFE_BYTEBUFFER and BYTEBUFFER_NO_BOUNDS_CHECK together can yield a\n+// performance gain of ~15% for some operations, however doing so is potentially \n+// dangerous. Do so at your own risk!\n+//\n+\n+using System;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Text;\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// Class to mimic Java's ByteBuffer which is used heavily in Flatbuffers.\n+    /// </summary>\n+    public class ByteBuffer\n+    {\n+        protected byte[] _buffer;\n+        private int _pos;  // Must track start of the buffer.\n+\n+        public int Length { get { return _buffer.Length; } }\n+\n+        public ByteBuffer(int size) : this(new byte[size]) { }\n+\n+        public ByteBuffer(byte[] buffer) : this(buffer, 0) { }\n+\n+        public ByteBuffer(byte[] buffer, int pos)\n+        {\n+            _buffer = buffer;\n+            _pos = pos;\n+        }\n+\n+        public int Position {\n+            get { return _pos; }\n+            set { _pos = value; }\n+        }\n+\n+        public void Reset()\n+        {\n+            _pos = 0;\n+        }\n+\n+        // Create a new ByteBuffer on the same underlying data.\n+        // The new ByteBuffer's position will be same as this buffer's.\n+        public ByteBuffer Duplicate()\n+        {\n+            return new ByteBuffer(_buffer, Position);\n+        }\n+\n+        // Increases the size of the ByteBuffer, and copies the old data towards\n+        // the end of the new buffer.\n+        public void GrowFront(int newSize)\n+        {\n+            if ((Length & 0xC0000000) != 0)\n+                throw new Exception(\n+                    \"ByteBuffer: cannot grow buffer beyond 2 gigabytes.\");\n+\n+            if (newSize < Length)\n+                throw new Exception(\"ByteBuffer: cannot truncate buffer.\");\n+\n+            byte[] newBuffer = new byte[newSize];\n+            Buffer.BlockCopy(_buffer, 0, newBuffer, newSize - Length,\n+                             Length);\n+            _buffer = newBuffer;\n+        }\n+\n+        public byte[] ToArray(int pos, int len)\n+        {\n+            return ToArray<byte>(pos, len);\n+        }\n+\n+        /// <summary>\n+        /// A lookup of type sizes. Used instead of Marshal.SizeOf() which has additional\n+        /// overhead, but also is compatible with generic functions for simplified code.\n+        /// </summary>\n+        private static Dictionary<Type, int> genericSizes = new Dictionary<Type, int>()\n+        {\n+            { typeof(bool),     sizeof(bool) },\n+            { typeof(float),    sizeof(float) },\n+            { typeof(double),   sizeof(double) },\n+            { typeof(sbyte),    sizeof(sbyte) },\n+            { typeof(byte),     sizeof(byte) },\n+            { typeof(short),    sizeof(short) },\n+            { typeof(ushort),   sizeof(ushort) },\n+            { typeof(int),      sizeof(int) },\n+            { typeof(uint),     sizeof(uint) },\n+            { typeof(ulong),    sizeof(ulong) },\n+            { typeof(long),     sizeof(long) },\n+        };\n+\n+        /// <summary>\n+        /// Get the wire-size (in bytes) of a type supported by flatbuffers.\n+        /// </summary>\n+        /// <param name=\"t\">The type to get the wire size of</param>\n+        /// <returns></returns>\n+        public static int SizeOf<T>()\n+        {\n+            return genericSizes[typeof(T)];\n+        }\n+\n+        /// <summary>\n+        /// Checks if the Type provided is supported as scalar value\n+        /// </summary>\n+        /// <typeparam name=\"T\">The Type to check</typeparam>\n+        /// <returns>True if the type is a scalar type that is supported, falsed otherwise</returns>\n+        public static bool IsSupportedType<T>()\n+        {\n+            return genericSizes.ContainsKey(typeof(T));\n+        }\n+\n+        /// <summary>\n+        /// Get the wire-size (in bytes) of an typed array\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of the array</typeparam>\n+        /// <param name=\"x\">The array to get the size of</param>\n+        /// <returns>The number of bytes the array takes on wire</returns>\n+        public static int ArraySize<T>(T[] x)\n+        {\n+            return SizeOf<T>() * x.Length;\n+        }\n+\n+        // Get a portion of the buffer casted into an array of type T, given\n+        // the buffer position and length.\n+        public T[] ToArray<T>(int pos, int len)\n+            where T: struct\n+        {\n+            AssertOffsetAndLength(pos, len);\n+            T[] arr = new T[len];\n+            Buffer.BlockCopy(_buffer, pos, arr, 0, ArraySize(arr));\n+            return arr;\n+        }\n+\n+        public byte[] ToSizedArray()\n+        {\n+            return ToArray<byte>(Position, Length - Position);\n+        }\n+\n+        public byte[] ToFullArray()\n+        {\n+            return ToArray<byte>(0, Length);\n+        }\n+\n+        public ArraySegment<byte> ToArraySegment(int pos, int len)\n+        {\n+            return new ArraySegment<byte>(_buffer, pos, len);\n+        }\n+\n+        public MemoryStream ToMemoryStream(int pos, int len)\n+        {\n+            return new MemoryStream(_buffer, pos, len);\n+        }\n+\n+#if !UNSAFE_BYTEBUFFER\n+        // Pre-allocated helper arrays for convertion.\n+        private float[] floathelper = new[] { 0.0f };\n+        private int[] inthelper = new[] { 0 };\n+        private double[] doublehelper = new[] { 0.0 };\n+        private ulong[] ulonghelper = new[] { 0UL };\n+#endif // !UNSAFE_BYTEBUFFER\n+\n+        // Helper functions for the unsafe version.\n+        static public ushort ReverseBytes(ushort input)\n+        {\n+            return (ushort)(((input & 0x00FFU) << 8) |\n+                            ((input & 0xFF00U) >> 8));\n+        }\n+        static public uint ReverseBytes(uint input)\n+        {\n+            return ((input & 0x000000FFU) << 24) |\n+                   ((input & 0x0000FF00U) <<  8) |\n+                   ((input & 0x00FF0000U) >>  8) |\n+                   ((input & 0xFF000000U) >> 24);\n+        }\n+        static public ulong ReverseBytes(ulong input)\n+        {\n+            return (((input & 0x00000000000000FFUL) << 56) |\n+                    ((input & 0x000000000000FF00UL) << 40) |\n+                    ((input & 0x0000000000FF0000UL) << 24) |\n+                    ((input & 0x00000000FF000000UL) <<  8) |\n+                    ((input & 0x000000FF00000000UL) >>  8) |\n+                    ((input & 0x0000FF0000000000UL) >> 24) |\n+                    ((input & 0x00FF000000000000UL) >> 40) |\n+                    ((input & 0xFF00000000000000UL) >> 56));\n+        }\n+\n+#if !UNSAFE_BYTEBUFFER\n+        // Helper functions for the safe (but slower) version.\n+        protected void WriteLittleEndian(int offset, int count, ulong data)\n+        {\n+            if (BitConverter.IsLittleEndian)\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    _buffer[offset + i] = (byte)(data >> i * 8);\n+                }\n+            }\n+            else\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                    _buffer[offset + count - 1 - i] = (byte)(data >> i * 8);\n+                }\n+            }\n+        }\n+\n+        protected ulong ReadLittleEndian(int offset, int count)\n+        {\n+            AssertOffsetAndLength(offset, count);\n+            ulong r = 0;\n+            if (BitConverter.IsLittleEndian)\n+            {\n+                for (int i = 0; i < count; i++)\n+                {\n+                  r |= (ulong)_buffer[offset + i] << i * 8;\n+                }\n+            }\n+            else\n+            {\n+              for (int i = 0; i < count; i++)\n+              {\n+                r |= (ulong)_buffer[offset + count - 1 - i] << i * 8;\n+              }\n+            }\n+            return r;\n+        }\n+#endif // !UNSAFE_BYTEBUFFER\n+\n+        private void AssertOffsetAndLength(int offset, int length)\n+        {\n+            #if !BYTEBUFFER_NO_BOUNDS_CHECK\n+            if (offset < 0 ||\n+                offset > _buffer.Length - length)\n+                throw new ArgumentOutOfRangeException();\n+            #endif\n+        }\n+\n+        public void PutSbyte(int offset, sbyte value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(sbyte));\n+            _buffer[offset] = (byte)value;\n+        }\n+\n+        public void PutByte(int offset, byte value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(byte));\n+            _buffer[offset] = value;\n+        }\n+\n+        public void PutByte(int offset, byte value, int count)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(byte) * count);\n+            for (var i = 0; i < count; ++i)\n+                _buffer[offset + i] = value;\n+        }\n+\n+        // this method exists in order to conform with Java ByteBuffer standards\n+        public void Put(int offset, byte value)\n+        {\n+            PutByte(offset, value);\n+        }\n+\n+        public void PutStringUTF8(int offset, string value)\n+        {\n+            AssertOffsetAndLength(offset, value.Length);\n+            Encoding.UTF8.GetBytes(value, 0, value.Length,\n+                _buffer, offset);\n+        }\n+\n+#if UNSAFE_BYTEBUFFER\n+        // Unsafe but more efficient versions of Put*.\n+        public void PutShort(int offset, short value)\n+        {\n+            PutUshort(offset, (ushort)value);\n+        }\n+\n+        public unsafe void PutUshort(int offset, ushort value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ushort));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                *(ushort*)(ptr + offset) = BitConverter.IsLittleEndian\n+                    ? value\n+                    : ReverseBytes(value);\n+            }\n+        }\n+\n+        public void PutInt(int offset, int value)\n+        {\n+            PutUint(offset, (uint)value);\n+        }\n+\n+        public unsafe void PutUint(int offset, uint value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(uint));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                *(uint*)(ptr + offset) = BitConverter.IsLittleEndian\n+                    ? value\n+                    : ReverseBytes(value);\n+            }\n+        }\n+\n+        public unsafe void PutLong(int offset, long value)\n+        {\n+            PutUlong(offset, (ulong)value);\n+        }\n+\n+        public unsafe void PutUlong(int offset, ulong value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ulong));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                *(ulong*)(ptr + offset) = BitConverter.IsLittleEndian\n+                    ? value\n+                    : ReverseBytes(value);\n+            }\n+        }\n+\n+        public unsafe void PutFloat(int offset, float value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(float));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                if (BitConverter.IsLittleEndian)\n+                {\n+                    *(float*)(ptr + offset) = value;\n+                }\n+                else\n+                {\n+                    *(uint*)(ptr + offset) = ReverseBytes(*(uint*)(&value));\n+                }\n+            }\n+        }\n+\n+        public unsafe void PutDouble(int offset, double value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(double));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                if (BitConverter.IsLittleEndian)\n+                {\n+                    *(double*)(ptr + offset) = value;\n+\n+                }\n+                else\n+                {\n+                    *(ulong*)(ptr + offset) = ReverseBytes(*(ulong*)(ptr + offset));\n+                }\n+            }\n+        }\n+#else // !UNSAFE_BYTEBUFFER\n+        // Slower versions of Put* for when unsafe code is not allowed.\n+        public void PutShort(int offset, short value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(short));\n+            WriteLittleEndian(offset, sizeof(short), (ulong)value);\n+        }\n+\n+        public void PutUshort(int offset, ushort value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ushort));\n+            WriteLittleEndian(offset, sizeof(ushort), (ulong)value);\n+        }\n+\n+        public void PutInt(int offset, int value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(int));\n+            WriteLittleEndian(offset, sizeof(int), (ulong)value);\n+        }\n+\n+        public void PutUint(int offset, uint value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(uint));\n+            WriteLittleEndian(offset, sizeof(uint), (ulong)value);\n+        }\n+\n+        public void PutLong(int offset, long value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(long));\n+            WriteLittleEndian(offset, sizeof(long), (ulong)value);\n+        }\n+\n+        public void PutUlong(int offset, ulong value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ulong));\n+            WriteLittleEndian(offset, sizeof(ulong), value);\n+        }\n+\n+        public void PutFloat(int offset, float value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(float));\n+            floathelper[0] = value;\n+            Buffer.BlockCopy(floathelper, 0, inthelper, 0, sizeof(float));\n+            WriteLittleEndian(offset, sizeof(float), (ulong)inthelper[0]);\n+        }\n+\n+        public void PutDouble(int offset, double value)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(double));\n+            doublehelper[0] = value;\n+            Buffer.BlockCopy(doublehelper, 0, ulonghelper, 0, sizeof(double));\n+            WriteLittleEndian(offset, sizeof(double), ulonghelper[0]);\n+        }\n+\n+        /// <summary>\n+        /// Copies an array of type T into this buffer, ending at the given\n+        /// offset into this buffer. The starting offset is calculated based on the length\n+        /// of the array and is the value returned.\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of the input data (must be a struct)</typeparam>\n+        /// <param name=\"offset\">The offset into this buffer where the copy will end</param>\n+        /// <param name=\"x\">The array to copy data from</param>\n+        /// <returns>The 'start' location of this buffer now, after the copy completed</returns>\n+        public int Put<T>(int offset, T[] x)\n+            where T : struct\n+        {\n+            if(x == null)\n+            {\n+                throw new ArgumentNullException(\"Cannot put a null array\");\n+            }\n+\n+            if(x.Length == 0)\n+            {\n+                throw new ArgumentException(\"Cannot put an empty array\");\n+            }\n+\n+            if(!IsSupportedType<T>())\n+            {\n+                throw new ArgumentException(\"Cannot put an array of type \"\n+                    + typeof(T) + \" into this buffer\");\n+            }\n+\n+            if (BitConverter.IsLittleEndian)\n+            {\n+                int numBytes = ByteBuffer.ArraySize(x);\n+                offset -= numBytes;\n+                AssertOffsetAndLength(offset, numBytes);\n+                // if we are LE, just do a block copy\n+                Buffer.BlockCopy(x, 0, _buffer, offset, numBytes);\n+            }\n+            else\n+            {\n+                throw new NotImplementedException(\"Big Endian Support not implemented yet \" +\n+                    \"for putting typed arrays\");\n+                // if we are BE, we have to swap each element by itself\n+                //for(int i = x.Length - 1; i >= 0; i--)\n+                //{\n+                //  todo: low priority, but need to genericize the Put<T>() functions\n+                //}\n+            }\n+            return offset;\n+        }\n+\n+\n+#endif // UNSAFE_BYTEBUFFER\n+\n+        public sbyte GetSbyte(int index)\n+        {\n+            AssertOffsetAndLength(index, sizeof(sbyte));\n+            return (sbyte)_buffer[index];\n+        }\n+\n+        public byte Get(int index)\n+        {\n+            AssertOffsetAndLength(index, sizeof(byte));\n+            return _buffer[index];\n+        }\n+\n+        public string GetStringUTF8(int startPos, int len)\n+        {\n+            return Encoding.UTF8.GetString(_buffer, startPos, len);\n+        }\n+\n+#if UNSAFE_BYTEBUFFER\n+        // Unsafe but more efficient versions of Get*.\n+        public short GetShort(int offset)\n+        {\n+            return (short)GetUshort(offset);\n+        }\n+\n+        public unsafe ushort GetUshort(int offset)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ushort));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                return BitConverter.IsLittleEndian\n+                    ? *(ushort*)(ptr + offset)\n+                    : ReverseBytes(*(ushort*)(ptr + offset));\n+            }\n+        }\n+\n+        public int GetInt(int offset)\n+        {\n+            return (int)GetUint(offset);\n+        }\n+\n+        public unsafe uint GetUint(int offset)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(uint));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                return BitConverter.IsLittleEndian\n+                    ? *(uint*)(ptr + offset)\n+                    : ReverseBytes(*(uint*)(ptr + offset));\n+            }\n+        }\n+\n+        public long GetLong(int offset)\n+        {\n+            return (long)GetUlong(offset);\n+        }\n+\n+        public unsafe ulong GetUlong(int offset)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(ulong));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                return BitConverter.IsLittleEndian\n+                    ? *(ulong*)(ptr + offset)\n+                    : ReverseBytes(*(ulong*)(ptr + offset));\n+            }\n+        }\n+\n+        public unsafe float GetFloat(int offset)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(float));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                if (BitConverter.IsLittleEndian)\n+                {\n+                    return *(float*)(ptr + offset);\n+                }\n+                else\n+                {\n+                    uint uvalue = ReverseBytes(*(uint*)(ptr + offset));\n+                    return *(float*)(&uvalue);\n+                }\n+            }\n+        }\n+\n+        public unsafe double GetDouble(int offset)\n+        {\n+            AssertOffsetAndLength(offset, sizeof(double));\n+            fixed (byte* ptr = _buffer)\n+            {\n+                if (BitConverter.IsLittleEndian)\n+                {\n+                    return *(double*)(ptr + offset);\n+                }\n+                else\n+                {\n+                    ulong uvalue = ReverseBytes(*(ulong*)(ptr + offset));\n+                    return *(double*)(&uvalue);\n+                }\n+            }\n+        }\n+#else // !UNSAFE_BYTEBUFFER\n+        // Slower versions of Get* for when unsafe code is not allowed.\n+        public short GetShort(int index)\n+        {\n+            return (short)ReadLittleEndian(index, sizeof(short));\n+        }\n+\n+        public ushort GetUshort(int index)\n+        {\n+            return (ushort)ReadLittleEndian(index, sizeof(ushort));\n+        }\n+\n+        public int GetInt(int index)\n+        {\n+            return (int)ReadLittleEndian(index, sizeof(int));\n+        }\n+\n+        public uint GetUint(int index)\n+        {\n+            return (uint)ReadLittleEndian(index, sizeof(uint));\n+        }\n+\n+        public long GetLong(int index)\n+        {\n+           return (long)ReadLittleEndian(index, sizeof(long));\n+        }\n+\n+        public ulong GetUlong(int index)\n+        {\n+            return ReadLittleEndian(index, sizeof(ulong));\n+        }\n+\n+        public float GetFloat(int index)\n+        {\n+            int i = (int)ReadLittleEndian(index, sizeof(float));\n+            inthelper[0] = i;\n+            Buffer.BlockCopy(inthelper, 0, floathelper, 0, sizeof(float));\n+            return floathelper[0];\n+        }\n+\n+        public double GetDouble(int index)\n+        {\n+            ulong i = ReadLittleEndian(index, sizeof(double));\n+            // There's Int64BitsToDouble but it uses unsafe code internally.\n+            ulonghelper[0] = i;\n+            Buffer.BlockCopy(ulonghelper, 0, doublehelper, 0, sizeof(double));\n+            return doublehelper[0];\n+        }\n+#endif // UNSAFE_BYTEBUFFER\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBufferUtil.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBufferUtil.cs\nnew file mode 100644\nindex 0000000000..66e8266843\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/ByteBufferUtil.cs\n@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2017 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+using System;\n+\n+namespace FlatBuffers\n+{\n+\t/// <summary>\n+\t/// Class that collects utility functions around `ByteBuffer`.\n+\t/// </summary>\n+\tpublic class ByteBufferUtil\n+\t{\n+\t\t// Extract the size prefix from a `ByteBuffer`.\n+\t\tpublic static int GetSizePrefix(ByteBuffer bb) {\n+\t\t\treturn bb.GetInt(bb.Position);\n+\t\t}\n+\n+\t\t// Create a duplicate of a size-prefixed `ByteBuffer` that has its position\n+\t\t// advanced just past the size prefix.\n+\t\tpublic static ByteBuffer RemoveSizePrefix(ByteBuffer bb) {\n+\t\t\tByteBuffer s = bb.Duplicate();\n+\t\t\ts.Position += FlatBufferConstants.SizePrefixLength;\n+\t\t\treturn s;\n+\t\t}\n+\t}\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferBuilder.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferBuilder.cs\nnew file mode 100644\nindex 0000000000..33bba969dd\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferBuilder.cs\n@@ -0,0 +1,744 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+using System;\n+using System.Text;\n+\n+/// @file\n+/// @addtogroup flatbuffers_csharp_api\n+/// @{\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// Responsible for building up and accessing a FlatBuffer formatted byte\n+    /// array (via ByteBuffer).\n+    /// </summary>\n+    public class FlatBufferBuilder\n+    {\n+        private int _space;\n+        private ByteBuffer _bb;\n+        private int _minAlign = 1;\n+\n+        // The vtable for the current table (if _vtableSize >= 0)\n+        private int[] _vtable = new int[16];\n+        // The size of the vtable. -1 indicates no vtable\n+        private int _vtableSize = -1;\n+        // Starting offset of the current struct/table.\n+        private int _objectStart;\n+        // List of offsets of all vtables.\n+        private int[] _vtables = new int[16];\n+        // Number of entries in `vtables` in use.\n+        private int _numVtables = 0;\n+        // For the current vector being built.\n+        private int _vectorNumElems = 0;\n+\n+        /// <summary>\n+        /// Create a FlatBufferBuilder with a given initial size.\n+        /// </summary>\n+        /// <param name=\"initialSize\">\n+        /// The initial size to use for the internal buffer.\n+        /// </param>\n+        public FlatBufferBuilder(int initialSize)\n+        {\n+            if (initialSize <= 0)\n+                throw new ArgumentOutOfRangeException(\"initialSize\",\n+                    initialSize, \"Must be greater than zero\");\n+            _space = initialSize;\n+            _bb = new ByteBuffer(initialSize);\n+        }\n+\n+        /// <summary>\n+        /// Reset the FlatBufferBuilder by purging all data that it holds.\n+        /// </summary>\n+        public void Clear()\n+        {\n+            _space = _bb.Length;\n+            _bb.Reset();\n+            _minAlign = 1;\n+            while (_vtableSize > 0) _vtable[--_vtableSize] = 0;\n+            _vtableSize = -1;\n+            _objectStart = 0;\n+            _numVtables = 0;\n+            _vectorNumElems = 0;\n+        }\n+\n+        /// <summary>\n+        /// Gets and sets a Boolean to disable the optimization when serializing\n+        /// default values to a Table.\n+        ///\n+        /// In order to save space, fields that are set to their default value\n+        /// don't get serialized into the buffer.\n+        /// </summary>\n+        public bool ForceDefaults { get; set; }\n+\n+        /// @cond FLATBUFFERS_INTERNAL\n+\n+        public int Offset { get { return _bb.Length - _space; } }\n+\n+        public void Pad(int size)\n+        {\n+             _bb.PutByte(_space -= size, 0, size);\n+        }\n+\n+        // Doubles the size of the ByteBuffer, and copies the old data towards\n+        // the end of the new buffer (since we build the buffer backwards).\n+        void GrowBuffer()\n+        {\n+            _bb.GrowFront(_bb.Length << 1);\n+        }\n+\n+        // Prepare to write an element of `size` after `additional_bytes`\n+        // have been written, e.g. if you write a string, you need to align\n+        // such the int length field is aligned to SIZEOF_INT, and the string\n+        // data follows it directly.\n+        // If all you need to do is align, `additional_bytes` will be 0.\n+        public void Prep(int size, int additionalBytes)\n+        {\n+            // Track the biggest thing we've ever aligned to.\n+            if (size > _minAlign)\n+                _minAlign = size;\n+            // Find the amount of alignment needed such that `size` is properly\n+            // aligned after `additional_bytes`\n+            var alignSize =\n+                ((~((int)_bb.Length - _space + additionalBytes)) + 1) &\n+                (size - 1);\n+            // Reallocate the buffer if needed.\n+            while (_space < alignSize + size + additionalBytes)\n+            {\n+                var oldBufSize = (int)_bb.Length;\n+                GrowBuffer();\n+                _space += (int)_bb.Length - oldBufSize;\n+\n+            }\n+            if (alignSize > 0)\n+                Pad(alignSize);\n+        }\n+\n+        public void PutBool(bool x)\n+        {\n+          _bb.PutByte(_space -= sizeof(byte), (byte)(x ? 1 : 0));\n+        }\n+\n+        public void PutSbyte(sbyte x)\n+        {\n+          _bb.PutSbyte(_space -= sizeof(sbyte), x);\n+        }\n+\n+        public void PutByte(byte x)\n+        {\n+            _bb.PutByte(_space -= sizeof(byte), x);\n+        }\n+\n+        public void PutShort(short x)\n+        {\n+            _bb.PutShort(_space -= sizeof(short), x);\n+        }\n+\n+        public void PutUshort(ushort x)\n+        {\n+          _bb.PutUshort(_space -= sizeof(ushort), x);\n+        }\n+\n+        public void PutInt(int x)\n+        {\n+            _bb.PutInt(_space -= sizeof(int), x);\n+        }\n+\n+        public void PutUint(uint x)\n+        {\n+          _bb.PutUint(_space -= sizeof(uint), x);\n+        }\n+\n+        public void PutLong(long x)\n+        {\n+            _bb.PutLong(_space -= sizeof(long), x);\n+        }\n+\n+        public void PutUlong(ulong x)\n+        {\n+          _bb.PutUlong(_space -= sizeof(ulong), x);\n+        }\n+\n+        public void PutFloat(float x)\n+        {\n+            _bb.PutFloat(_space -= sizeof(float), x);\n+        }\n+\n+        /// <summary>\n+        /// Puts an array of type T into this builder at the \n+        /// current offset\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of the input data </typeparam>\n+        /// <param name=\"x\">The array to copy data from</param>\n+        public void Put<T>(T[] x)\n+            where T : struct\n+        {\n+            _space = _bb.Put(_space, x);\n+        }\n+\n+        public void PutDouble(double x)\n+        {\n+            _bb.PutDouble(_space -= sizeof(double), x);\n+        }\n+        /// @endcond\n+\n+        /// <summary>\n+        /// Add a `bool` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `bool` to add to the buffer.</param>\n+        public void AddBool(bool x) { Prep(sizeof(byte), 0); PutBool(x); }\n+\n+        /// <summary>\n+        /// Add a `sbyte` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `sbyte` to add to the buffer.</param>\n+        public void AddSbyte(sbyte x) { Prep(sizeof(sbyte), 0); PutSbyte(x); }\n+\n+        /// <summary>\n+        /// Add a `byte` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `byte` to add to the buffer.</param>\n+        public void AddByte(byte x) { Prep(sizeof(byte), 0); PutByte(x); }\n+\n+        /// <summary>\n+        /// Add a `short` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `short` to add to the buffer.</param>\n+        public void AddShort(short x) { Prep(sizeof(short), 0); PutShort(x); }\n+\n+        /// <summary>\n+        /// Add an `ushort` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `ushort` to add to the buffer.</param>\n+        public void AddUshort(ushort x) { Prep(sizeof(ushort), 0); PutUshort(x); }\n+\n+        /// <summary>\n+        /// Add an `int` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `int` to add to the buffer.</param>\n+        public void AddInt(int x) { Prep(sizeof(int), 0); PutInt(x); }\n+\n+        /// <summary>\n+        /// Add an `uint` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `uint` to add to the buffer.</param>\n+        public void AddUint(uint x) { Prep(sizeof(uint), 0); PutUint(x); }\n+\n+        /// <summary>\n+        /// Add a `long` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `long` to add to the buffer.</param>\n+        public void AddLong(long x) { Prep(sizeof(long), 0); PutLong(x); }\n+\n+        /// <summary>\n+        /// Add an `ulong` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `ulong` to add to the buffer.</param>\n+        public void AddUlong(ulong x) { Prep(sizeof(ulong), 0); PutUlong(x); }\n+\n+        /// <summary>\n+        /// Add a `float` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `float` to add to the buffer.</param>\n+        public void AddFloat(float x) { Prep(sizeof(float), 0); PutFloat(x); }\n+\n+        /// <summary>\n+        /// Add an array of type T to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <typeparam name=\"T\">The type of the input data</typeparam>\n+        /// <param name=\"x\">The array to copy data from</param>\n+        public void Add<T>(T[] x)\n+            where T : struct\n+        {\n+            if (x == null)\n+            {\n+                throw new ArgumentNullException(\"Cannot add a null array\");\n+            }\n+\n+            if( x.Length == 0)\n+            {\n+                // don't do anything if the array is empty\n+                return;\n+            }\n+\n+            if(!ByteBuffer.IsSupportedType<T>())\n+            {\n+                throw new ArgumentException(\"Cannot add this Type array to the builder\");\n+            }\n+\n+            int size = ByteBuffer.SizeOf<T>();\n+            // Need to prep on size (for data alignment) and then we pass the\n+            // rest of the length (minus 1) as additional bytes\n+            Prep(size, size * (x.Length - 1));\n+            Put(x);\n+        }\n+\n+        /// <summary>\n+        /// Add a `double` to the buffer (aligns the data and grows if necessary).\n+        /// </summary>\n+        /// <param name=\"x\">The `double` to add to the buffer.</param>\n+        public void AddDouble(double x) { Prep(sizeof(double), 0);\n+                                          PutDouble(x); }\n+\n+        /// <summary>\n+        /// Adds an offset, relative to where it will be written.\n+        /// </summary>\n+        /// <param name=\"off\">The offset to add to the buffer.</param>\n+        public void AddOffset(int off)\n+        {\n+            Prep(sizeof(int), 0);  // Ensure alignment is already done.\n+            if (off > Offset)\n+                throw new ArgumentException();\n+\n+            off = Offset - off + sizeof(int);\n+            PutInt(off);\n+        }\n+\n+        /// @cond FLATBUFFERS_INTERNAL\n+        public void StartVector(int elemSize, int count, int alignment)\n+        {\n+            NotNested();\n+            _vectorNumElems = count;\n+            Prep(sizeof(int), elemSize * count);\n+            Prep(alignment, elemSize * count); // Just in case alignment > int.\n+        }\n+        /// @endcond\n+\n+        /// <summary>\n+        /// Writes data necessary to finish a vector construction.\n+        /// </summary>\n+        public VectorOffset EndVector()\n+        {\n+            PutInt(_vectorNumElems);\n+            return new VectorOffset(Offset);\n+        }\n+\n+        /// <summary>\n+        /// Creates a vector of tables.\n+        /// </summary>\n+        /// <param name=\"offsets\">Offsets of the tables.</param>\n+        public VectorOffset CreateVectorOfTables<T>(Offset<T>[] offsets) where T : struct\n+        {\n+            NotNested();\n+            StartVector(sizeof(int), offsets.Length, sizeof(int));\n+            for (int i = offsets.Length - 1; i >= 0; i--) AddOffset(offsets[i].Value);\n+            return EndVector();\n+        }\n+\n+        /// @cond FLATBUFFERS_INTENRAL\n+        public void Nested(int obj)\n+        {\n+            // Structs are always stored inline, so need to be created right\n+            // where they are used. You'll get this assert if you created it\n+            // elsewhere.\n+            if (obj != Offset)\n+                throw new Exception(\n+                    \"FlatBuffers: struct must be serialized inline.\");\n+        }\n+\n+        public void NotNested()\n+        {\n+            // You should not be creating any other objects or strings/vectors\n+            // while an object is being constructed\n+            if (_vtableSize >= 0)\n+                throw new Exception(\n+                    \"FlatBuffers: object serialization must not be nested.\");\n+        }\n+\n+        public void StartObject(int numfields)\n+        {\n+            if (numfields < 0)\n+                throw new ArgumentOutOfRangeException(\"Flatbuffers: invalid numfields\");\n+\n+            NotNested();\n+\n+            if (_vtable.Length < numfields)\n+                _vtable = new int[numfields];\n+\n+            _vtableSize = numfields;\n+            _objectStart = Offset;\n+        }\n+\n+\n+        // Set the current vtable at `voffset` to the current location in the\n+        // buffer.\n+        public void Slot(int voffset)\n+        {\n+            if (voffset >= _vtableSize)\n+                throw new IndexOutOfRangeException(\"Flatbuffers: invalid voffset\");\n+\n+            _vtable[voffset] = Offset;\n+        }\n+\n+        /// <summary>\n+        /// Adds a Boolean to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddBool(int o, bool x, bool d) { if (ForceDefaults || x != d) { AddBool(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a SByte to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddSbyte(int o, sbyte x, sbyte d) { if (ForceDefaults || x != d) { AddSbyte(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a Byte to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddByte(int o, byte x, byte d) { if (ForceDefaults || x != d) { AddByte(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a Int16 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddShort(int o, short x, int d) { if (ForceDefaults || x != d) { AddShort(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a UInt16 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddUshort(int o, ushort x, ushort d) { if (ForceDefaults || x != d) { AddUshort(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds an Int32 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddInt(int o, int x, int d) { if (ForceDefaults || x != d) { AddInt(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a UInt32 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddUint(int o, uint x, uint d) { if (ForceDefaults || x != d) { AddUint(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds an Int64 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddLong(int o, long x, long d) { if (ForceDefaults || x != d) { AddLong(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a UInt64 to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddUlong(int o, ulong x, ulong d) { if (ForceDefaults || x != d) { AddUlong(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a Single to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddFloat(int o, float x, double d) { if (ForceDefaults || x != d) { AddFloat(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a Double to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddDouble(int o, double x, double d) { if (ForceDefaults || x != d) { AddDouble(x); Slot(o); } }\n+\n+        /// <summary>\n+        /// Adds a buffer offset to the Table at index `o` in its vtable using the value `x` and default `d`\n+        /// </summary>\n+        /// <param name=\"o\">The index into the vtable</param>\n+        /// <param name=\"x\">The value to put into the buffer. If the value is equal to the default\n+        /// and <see cref=\"ForceDefaults\"/> is false, the value will be skipped.</param>\n+        /// <param name=\"d\">The default value to compare the value against</param>\n+        public void AddOffset(int o, int x, int d) { if (ForceDefaults || x != d) { AddOffset(x); Slot(o); } }\n+        /// @endcond\n+\n+        /// <summary>\n+        /// Encode the string `s` in the buffer using UTF-8.\n+        /// </summary>\n+        /// <param name=\"s\">The string to encode.</param>\n+        /// <returns>\n+        /// The offset in the buffer where the encoded string starts.\n+        /// </returns>\n+        public StringOffset CreateString(string s)\n+        {\n+            NotNested();\n+            AddByte(0);\n+            var utf8StringLen = Encoding.UTF8.GetByteCount(s);\n+            StartVector(1, utf8StringLen, 1);\n+            _bb.PutStringUTF8(_space -= utf8StringLen, s);\n+            return new StringOffset(EndVector().Value);\n+        }\n+\n+        /// @cond FLATBUFFERS_INTERNAL\n+        // Structs are stored inline, so nothing additional is being added.\n+        // `d` is always 0.\n+        public void AddStruct(int voffset, int x, int d)\n+        {\n+            if (x != d)\n+            {\n+                Nested(x);\n+                Slot(voffset);\n+            }\n+        }\n+\n+        public int EndObject()\n+        {\n+            if (_vtableSize < 0)\n+                throw new InvalidOperationException(\n+                  \"Flatbuffers: calling endObject without a startObject\");\n+\n+            AddInt((int)0);\n+            var vtableloc = Offset;\n+            // Write out the current vtable.\n+            int i = _vtableSize - 1;\n+            // Trim trailing zeroes.\n+            for (; i >= 0 && _vtable[i] == 0; i--) {}\n+            int trimmedSize = i + 1;\n+            for (; i >= 0 ; i--) {\n+                // Offset relative to the start of the table.\n+                short off = (short)(_vtable[i] != 0\n+                                        ? vtableloc - _vtable[i]\n+                                        : 0);\n+                AddShort(off);\n+\n+                // clear out written entry\n+                _vtable[i] = 0;\n+            }\n+\n+            const int standardFields = 2; // The fields below:\n+            AddShort((short)(vtableloc - _objectStart));\n+            AddShort((short)((trimmedSize + standardFields) *\n+                             sizeof(short)));\n+\n+            // Search for an existing vtable that matches the current one.\n+            int existingVtable = 0;\n+            for (i = 0; i < _numVtables; i++) {\n+                int vt1 = _bb.Length - _vtables[i];\n+                int vt2 = _space;\n+                short len = _bb.GetShort(vt1);\n+                if (len == _bb.GetShort(vt2)) {\n+                    for (int j = sizeof(short); j < len; j += sizeof(short)) {\n+                        if (_bb.GetShort(vt1 + j) != _bb.GetShort(vt2 + j)) {\n+                            goto endLoop;\n+                        }\n+                    }\n+                    existingVtable = _vtables[i];\n+                    break;\n+                }\n+\n+            endLoop: { }\n+            }\n+\n+            if (existingVtable != 0) {\n+                // Found a match:\n+                // Remove the current vtable.\n+                _space = _bb.Length - vtableloc;\n+                // Point table to existing vtable.\n+                _bb.PutInt(_space, existingVtable - vtableloc);\n+            } else {\n+                // No match:\n+                // Add the location of the current vtable to the list of\n+                // vtables.\n+                if (_numVtables == _vtables.Length)\n+                {\n+                    // Arrays.CopyOf(vtables num_vtables * 2);\n+                    var newvtables = new int[ _numVtables * 2];\n+                    Array.Copy(_vtables, newvtables, _vtables.Length);\n+\n+                    _vtables = newvtables;\n+                };\n+                _vtables[_numVtables++] = Offset;\n+                // Point table to current vtable.\n+                _bb.PutInt(_bb.Length - vtableloc, Offset - vtableloc);\n+            }\n+\n+            _vtableSize = -1;\n+            return vtableloc;\n+        }\n+\n+        // This checks a required field has been set in a given table that has\n+        // just been constructed.\n+        public void Required(int table, int field)\n+        {\n+          int table_start = _bb.Length - table;\n+          int vtable_start = table_start - _bb.GetInt(table_start);\n+          bool ok = _bb.GetShort(vtable_start + field) != 0;\n+          // If this fails, the caller will show what field needs to be set.\n+          if (!ok)\n+            throw new InvalidOperationException(\"FlatBuffers: field \" + field +\n+                                                \" must be set\");\n+        }\n+        /// @endcond\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `root_table`.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        /// <param name=\"sizePrefix\">\n+        /// Whether to prefix the size to the buffer.\n+        /// </param>\n+        protected void Finish(int rootTable, bool sizePrefix)\n+        {\n+            Prep(_minAlign, sizeof(int) + (sizePrefix ? sizeof(int) : 0));\n+            AddOffset(rootTable);\n+            if (sizePrefix) {\n+                AddInt(_bb.Length - _space);\n+            }\n+            _bb.Position = _space;\n+        }\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `root_table`.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        public void Finish(int rootTable)\n+        {\n+            Finish(rootTable, false);\n+        }\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `root_table`, with the size prefixed.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        public void FinishSizePrefixed(int rootTable)\n+        {\n+            Finish(rootTable, true);\n+        }\n+\n+        /// <summary>\n+        /// Get the ByteBuffer representing the FlatBuffer.\n+        /// </summary>\n+        /// <remarks>\n+        /// This is typically only called after you call `Finish()`.\n+        /// The actual data starts at the ByteBuffer's current position,\n+        /// not necessarily at `0`.\n+        /// </remarks>\n+        /// <returns>\n+        /// Returns the ByteBuffer for this FlatBuffer.\n+        /// </returns>\n+        public ByteBuffer DataBuffer { get { return _bb; } }\n+\n+        /// <summary>\n+        /// A utility function to copy and return the ByteBuffer data as a\n+        /// `byte[]`.\n+        /// </summary>\n+        /// <returns>\n+        /// A full copy of the FlatBuffer data.\n+        /// </returns>\n+        public byte[] SizedByteArray()\n+        {\n+            return _bb.ToSizedArray();\n+        }\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `rootTable`.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        /// <param name=\"fileIdentifier\">\n+        /// A FlatBuffer file identifier to be added to the buffer before\n+        /// `root_table`.\n+        /// </param>\n+        /// <param name=\"sizePrefix\">\n+        /// Whether to prefix the size to the buffer.\n+        /// </param>\n+        protected void Finish(int rootTable, string fileIdentifier, bool sizePrefix)\n+        {\n+            Prep(_minAlign, sizeof(int) + (sizePrefix ? sizeof(int) : 0) +\n+                            FlatBufferConstants.FileIdentifierLength);\n+            if (fileIdentifier.Length !=\n+                FlatBufferConstants.FileIdentifierLength)\n+                throw new ArgumentException(\n+                    \"FlatBuffers: file identifier must be length \" +\n+                    FlatBufferConstants.FileIdentifierLength,\n+                    \"fileIdentifier\");\n+            for (int i = FlatBufferConstants.FileIdentifierLength - 1; i >= 0;\n+                 i--)\n+            {\n+               AddByte((byte)fileIdentifier[i]);\n+            }\n+            Finish(rootTable, sizePrefix);\n+        }\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `rootTable`.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        /// <param name=\"fileIdentifier\">\n+        /// A FlatBuffer file identifier to be added to the buffer before\n+        /// `root_table`.\n+        /// </param>\n+        public void Finish(int rootTable, string fileIdentifier)\n+        {\n+            Finish(rootTable, fileIdentifier, false);\n+        }\n+\n+        /// <summary>\n+        /// Finalize a buffer, pointing to the given `rootTable`, with the size prefixed.\n+        /// </summary>\n+        /// <param name=\"rootTable\">\n+        /// An offset to be added to the buffer.\n+        /// </param>\n+        /// <param name=\"fileIdentifier\">\n+        /// A FlatBuffer file identifier to be added to the buffer before\n+        /// `root_table`.\n+        /// </param>\n+        public void FinishSizePrefixed(int rootTable, string fileIdentifier)\n+        {\n+            Finish(rootTable, fileIdentifier, true);\n+        }\n+    }\n+}\n+\n+/// @}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferConstants.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferConstants.cs\nnew file mode 100644\nindex 0000000000..e30f3f3944\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/FlatBufferConstants.cs\n@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+using System.Text;\n+\n+namespace FlatBuffers\n+{\n+    public static class FlatBufferConstants\n+    {\n+        public const int FileIdentifierLength = 4;\n+        public const int SizePrefixLength = 4;\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/IFlatbufferObject.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/IFlatbufferObject.cs\nnew file mode 100644\nindex 0000000000..6a15aba6e5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/IFlatbufferObject.cs\n@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// This is the base for both structs and tables.\n+    /// </summary>\n+    public interface IFlatbufferObject\n+    {\n+        void __init(int _i, ByteBuffer _bb);\n+\n+        ByteBuffer ByteBuffer { get; }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Offset.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Offset.cs\nnew file mode 100644\nindex 0000000000..2b17cec85d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Offset.cs\n@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// Offset class for typesafe assignments.\n+    /// </summary>\n+    public struct Offset<T> where T : struct\n+    {\n+        public int Value;\n+        public Offset(int value)\n+        {\n+            Value = value;\n+        }\n+    }\n+\n+    public struct StringOffset\n+    {\n+        public int Value;\n+        public StringOffset(int value)\n+        {\n+            Value = value;\n+        }\n+    }\n+\n+    public struct VectorOffset\n+    {\n+        public int Value;\n+        public VectorOffset(int value)\n+        {\n+            Value = value;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Struct.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Struct.cs\nnew file mode 100644\nindex 0000000000..61da32f77b\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Struct.cs\n@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// All structs in the generated code derive from this class, and add their own accessors.\n+    /// </summary>\n+    public struct Struct\n+    {\n+        public int bb_pos;\n+        public ByteBuffer bb;\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Table.cs b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Table.cs\nnew file mode 100644\nindex 0000000000..07db5f4231\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/FlatBuffers/Table.cs\n@@ -0,0 +1,177 @@\n+/*\n+ * Copyright 2014 Google Inc. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+using System;\n+using System.Text;\n+\n+namespace FlatBuffers\n+{\n+    /// <summary>\n+    /// All tables in the generated code derive from this struct, and add their own accessors.\n+    /// </summary>\n+    public struct Table\n+    {\n+        public int bb_pos;\n+        public ByteBuffer bb;\n+\n+        public ByteBuffer ByteBuffer { get { return bb; } }\n+\n+        // Look up a field in the vtable, return an offset into the object, or 0 if the field is not\n+        // present.\n+        public int __offset(int vtableOffset)\n+        {\n+            int vtable = bb_pos - bb.GetInt(bb_pos);\n+            return vtableOffset < bb.GetShort(vtable) ? (int)bb.GetShort(vtable + vtableOffset) : 0;\n+        }\n+\n+        public static int __offset(int vtableOffset, int offset, ByteBuffer bb)\n+        {\n+            int vtable = bb.Length - offset;\n+            return (int)bb.GetShort(vtable + vtableOffset - bb.GetInt(vtable)) + vtable;\n+        }\n+\n+        // Retrieve the relative offset stored at \"offset\"\n+        public int __indirect(int offset)\n+        {\n+            return offset + bb.GetInt(offset);\n+        }\n+\n+        public static int __indirect(int offset, ByteBuffer bb)\n+        {\n+            return offset + bb.GetInt(offset);\n+        }\n+\n+        // Create a .NET String from UTF-8 data stored inside the flatbuffer.\n+        public string __string(int offset)\n+        {\n+            offset += bb.GetInt(offset);\n+            var len = bb.GetInt(offset);\n+            var startPos = offset + sizeof(int);\n+            return bb.GetStringUTF8(startPos, len);\n+        }\n+\n+        // Get the length of a vector whose offset is stored at \"offset\" in this object.\n+        public int __vector_len(int offset)\n+        {\n+            offset += bb_pos;\n+            offset += bb.GetInt(offset);\n+            return bb.GetInt(offset);\n+        }\n+\n+        // Get the start of data of a vector whose offset is stored at \"offset\" in this object.\n+        public int __vector(int offset)\n+        {\n+            offset += bb_pos;\n+            return offset + bb.GetInt(offset) + sizeof(int);  // data starts after the length\n+        }\n+\n+        // Get the data of a vector whoses offset is stored at \"offset\" in this object as an\n+        // ArraySegment&lt;byte&gt;. If the vector is not present in the ByteBuffer,\n+        // then a null value will be returned.\n+        public ArraySegment<byte>? __vector_as_arraysegment(int offset)\n+        {\n+            var o = this.__offset(offset);\n+            if (0 == o)\n+            {\n+                return null;\n+            }\n+\n+            var pos = this.__vector(o);\n+            var len = this.__vector_len(o);\n+            return bb.ToArraySegment(pos, len);\n+        }\n+\n+        // Get the data of a vector whoses offset is stored at \"offset\" in this object as an\n+        // T[]. If the vector is not present in the ByteBuffer, then a null value will be\n+        // returned.\n+        public T[] __vector_as_array<T>(int offset)\n+            where T : struct\n+        {\n+            if(!BitConverter.IsLittleEndian)\n+            {\n+                throw new NotSupportedException(\"Getting typed arrays on a Big Endian \" +\n+                    \"system is not support\");\n+            }\n+\n+            var o = this.__offset(offset);\n+            if (0 == o)\n+            {\n+                return null;\n+            }\n+\n+            var pos = this.__vector(o);\n+            var len = this.__vector_len(o);\n+            return bb.ToArray<T>(pos, len);\n+        }\n+\n+        // Initialize any Table-derived type to point to the union at the given offset.\n+        public T __union<T>(int offset) where T : struct, IFlatbufferObject\n+        {\n+            offset += bb_pos;\n+            T t = new T();\n+            t.__init(offset + bb.GetInt(offset), bb);\n+            return t;\n+        }\n+\n+        public static bool __has_identifier(ByteBuffer bb, string ident)\n+        {\n+            if (ident.Length != FlatBufferConstants.FileIdentifierLength)\n+                throw new ArgumentException(\"FlatBuffers: file identifier must be length \" + FlatBufferConstants.FileIdentifierLength, \"ident\");\n+\n+            for (var i = 0; i < FlatBufferConstants.FileIdentifierLength; i++)\n+            {\n+                if (ident[i] != (char)bb.Get(bb.Position + sizeof(int) + i)) return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        // Compare strings in the ByteBuffer.\n+        public static int CompareStrings(int offset_1, int offset_2, ByteBuffer bb)\n+        {\n+            offset_1 += bb.GetInt(offset_1);\n+            offset_2 += bb.GetInt(offset_2);\n+            var len_1 = bb.GetInt(offset_1);\n+            var len_2 = bb.GetInt(offset_2);\n+            var startPos_1 = offset_1 + sizeof(int);\n+            var startPos_2 = offset_2 + sizeof(int);\n+            var len = Math.Min(len_1, len_2);\n+            for(int i = 0; i < len; i++) {\n+                byte b1 = bb.Get(i + startPos_1);\n+                byte b2 = bb.Get(i + startPos_2);\n+                if (b1 != b2)\n+                    return b1 - b2;\n+            }\n+            return len_1 - len_2;\n+        }\n+\n+        // Compare string from the ByteBuffer with the string object\n+        public static int CompareStrings(int offset_1, byte[] key, ByteBuffer bb)\n+        {\n+            offset_1 += bb.GetInt(offset_1);\n+            var len_1 = bb.GetInt(offset_1);\n+            var len_2 = key.Length;\n+            var startPos_1 = offset_1 + sizeof(int);\n+            var len = Math.Min(len_1, len_2);\n+            for (int i = 0; i < len; i++) {\n+                byte b = bb.Get(i + startPos_1);\n+                if (b != key[i])\n+                    return b - key[i];\n+            }\n+            return len_1 - len_2;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Footer.cs b/csharp/src/Apache.Arrow/Flatbuf/Footer.cs\nnew file mode 100644\nindex 0000000000..f45790a1ca\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Footer.cs\n@@ -0,0 +1,59 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// Arrow File metadata\n+///\n+public struct Footer : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Footer GetRootAsFooter(ByteBuffer _bb) { return GetRootAsFooter(_bb, new Footer()); }\n+  public static Footer GetRootAsFooter(ByteBuffer _bb, Footer obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Footer __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public MetadataVersion Version { get { int o = __p.__offset(4); return o != 0 ? (MetadataVersion)__p.bb.GetShort(o + __p.bb_pos) : MetadataVersion.V1; } }\n+  public Schema? Schema { get { int o = __p.__offset(6); return o != 0 ? (Schema?)(new Schema()).__assign(__p.__indirect(o + __p.bb_pos), __p.bb) : null; } }\n+  public Block? Dictionaries(int j) { int o = __p.__offset(8); return o != 0 ? (Block?)(new Block()).__assign(__p.__vector(o) + j * 24, __p.bb) : null; }\n+  public int DictionariesLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  public Block? RecordBatches(int j) { int o = __p.__offset(10); return o != 0 ? (Block?)(new Block()).__assign(__p.__vector(o) + j * 24, __p.bb) : null; }\n+  public int RecordBatchesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }\n+\n+  public static Offset<Footer> CreateFooter(FlatBufferBuilder builder,\n+      MetadataVersion version = MetadataVersion.V1,\n+      Offset<Schema> schemaOffset = default(Offset<Schema>),\n+      VectorOffset dictionariesOffset = default(VectorOffset),\n+      VectorOffset recordBatchesOffset = default(VectorOffset)) {\n+    builder.StartObject(4);\n+    Footer.AddRecordBatches(builder, recordBatchesOffset);\n+    Footer.AddDictionaries(builder, dictionariesOffset);\n+    Footer.AddSchema(builder, schemaOffset);\n+    Footer.AddVersion(builder, version);\n+    return Footer.EndFooter(builder);\n+  }\n+\n+  public static void StartFooter(FlatBufferBuilder builder) { builder.StartObject(4); }\n+  public static void AddVersion(FlatBufferBuilder builder, MetadataVersion version) { builder.AddShort(0, (short)version, 0); }\n+  public static void AddSchema(FlatBufferBuilder builder, Offset<Schema> schemaOffset) { builder.AddOffset(1, schemaOffset.Value, 0); }\n+  public static void AddDictionaries(FlatBufferBuilder builder, VectorOffset dictionariesOffset) { builder.AddOffset(2, dictionariesOffset.Value, 0); }\n+  public static void StartDictionariesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(24, numElems, 8); }\n+  public static void AddRecordBatches(FlatBufferBuilder builder, VectorOffset recordBatchesOffset) { builder.AddOffset(3, recordBatchesOffset.Value, 0); }\n+  public static void StartRecordBatchesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(24, numElems, 8); }\n+  public static Offset<Footer> EndFooter(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Footer>(o);\n+  }\n+  public static void FinishFooterBuffer(FlatBufferBuilder builder, Offset<Footer> offset) { builder.Finish(offset.Value); }\n+  public static void FinishSizePrefixedFooterBuffer(FlatBufferBuilder builder, Offset<Footer> offset) { builder.FinishSizePrefixed(offset.Value); }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/KeyValue.cs b/csharp/src/Apache.Arrow/Flatbuf/KeyValue.cs\nnew file mode 100644\nindex 0000000000..f5a062a6ec\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/KeyValue.cs\n@@ -0,0 +1,47 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// user defined key value pairs to add custom metadata to arrow\n+/// key namespacing is the responsibility of the user\n+public struct KeyValue : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static KeyValue GetRootAsKeyValue(ByteBuffer _bb) { return GetRootAsKeyValue(_bb, new KeyValue()); }\n+  public static KeyValue GetRootAsKeyValue(ByteBuffer _bb, KeyValue obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public KeyValue __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public string Key { get { int o = __p.__offset(4); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }\n+  public ArraySegment<byte>? GetKeyBytes() { return __p.__vector_as_arraysegment(4); }\n+  public string Value { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }\n+  public ArraySegment<byte>? GetValueBytes() { return __p.__vector_as_arraysegment(6); }\n+\n+  public static Offset<KeyValue> CreateKeyValue(FlatBufferBuilder builder,\n+      StringOffset keyOffset = default(StringOffset),\n+      StringOffset valueOffset = default(StringOffset)) {\n+    builder.StartObject(2);\n+    KeyValue.AddValue(builder, valueOffset);\n+    KeyValue.AddKey(builder, keyOffset);\n+    return KeyValue.EndKeyValue(builder);\n+  }\n+\n+  public static void StartKeyValue(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddKey(FlatBufferBuilder builder, StringOffset keyOffset) { builder.AddOffset(0, keyOffset.Value, 0); }\n+  public static void AddValue(FlatBufferBuilder builder, StringOffset valueOffset) { builder.AddOffset(1, valueOffset.Value, 0); }\n+  public static Offset<KeyValue> EndKeyValue(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<KeyValue>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Map.cs b/csharp/src/Apache.Arrow/Flatbuf/Map.cs\nnew file mode 100644\nindex 0000000000..a47ff4bc6c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Map.cs\n@@ -0,0 +1,63 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// A Map is a logical nested type that is represented as\n+///\n+/// List<entry: Struct<key: K, value: V>>\n+///\n+/// In this layout, the keys and values are each respectively contiguous. We do\n+/// not constrain the key and value types, so the application is responsible\n+/// for ensuring that the keys are hashable and unique. Whether the keys are sorted\n+/// may be set in the metadata for this field\n+///\n+/// In a Field with Map type, the Field has a child Struct field, which then\n+/// has two children: key type and the second the value type. The names of the\n+/// child fields may be respectively \"entry\", \"key\", and \"value\", but this is\n+/// not enforced\n+///\n+/// Map\n+///   - child[0] entry: Struct\n+///     - child[0] key: K\n+///     - child[1] value: V\n+///\n+/// Neither the \"entry\" field nor the \"key\" field may be nullable.\n+///\n+/// The metadata is structured so that Arrow systems without special handling\n+/// for Map can make Map an alias for List. The \"layout\" attribute for the Map\n+/// field must have the same contents as a List.\n+public struct Map : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Map GetRootAsMap(ByteBuffer _bb) { return GetRootAsMap(_bb, new Map()); }\n+  public static Map GetRootAsMap(ByteBuffer _bb, Map obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Map __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Set to true if the keys within each value are sorted\n+  public bool KeysSorted { get { int o = __p.__offset(4); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }\n+\n+  public static Offset<Map> CreateMap(FlatBufferBuilder builder,\n+      bool keysSorted = false) {\n+    builder.StartObject(1);\n+    Map.AddKeysSorted(builder, keysSorted);\n+    return Map.EndMap(builder);\n+  }\n+\n+  public static void StartMap(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddKeysSorted(FlatBufferBuilder builder, bool keysSorted) { builder.AddBool(0, keysSorted, false); }\n+  public static Offset<Map> EndMap(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Map>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Message.cs b/csharp/src/Apache.Arrow/Flatbuf/Message.cs\nnew file mode 100644\nindex 0000000000..71422fe6be\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Message.cs\n@@ -0,0 +1,52 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Message : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Message GetRootAsMessage(ByteBuffer _bb) { return GetRootAsMessage(_bb, new Message()); }\n+  public static Message GetRootAsMessage(ByteBuffer _bb, Message obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Message __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public MetadataVersion Version { get { int o = __p.__offset(4); return o != 0 ? (MetadataVersion)__p.bb.GetShort(o + __p.bb_pos) : MetadataVersion.V1; } }\n+  public MessageHeader HeaderType { get { int o = __p.__offset(6); return o != 0 ? (MessageHeader)__p.bb.Get(o + __p.bb_pos) : MessageHeader.NONE; } }\n+  public TTable? Header<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(8); return o != 0 ? (TTable?)__p.__union<TTable>(o) : null; }\n+  public long BodyLength { get { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }\n+\n+  public static Offset<Message> CreateMessage(FlatBufferBuilder builder,\n+      MetadataVersion version = MetadataVersion.V1,\n+      MessageHeader header_type = MessageHeader.NONE,\n+      int headerOffset = 0,\n+      long bodyLength = 0) {\n+    builder.StartObject(4);\n+    Message.AddBodyLength(builder, bodyLength);\n+    Message.AddHeader(builder, headerOffset);\n+    Message.AddVersion(builder, version);\n+    Message.AddHeaderType(builder, header_type);\n+    return Message.EndMessage(builder);\n+  }\n+\n+  public static void StartMessage(FlatBufferBuilder builder) { builder.StartObject(4); }\n+  public static void AddVersion(FlatBufferBuilder builder, MetadataVersion version) { builder.AddShort(0, (short)version, 0); }\n+  public static void AddHeaderType(FlatBufferBuilder builder, MessageHeader headerType) { builder.AddByte(1, (byte)headerType, 0); }\n+  public static void AddHeader(FlatBufferBuilder builder, int headerOffset) { builder.AddOffset(2, headerOffset, 0); }\n+  public static void AddBodyLength(FlatBufferBuilder builder, long bodyLength) { builder.AddLong(3, bodyLength, 0); }\n+  public static Offset<Message> EndMessage(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Message>(o);\n+  }\n+  public static void FinishMessageBuffer(FlatBufferBuilder builder, Offset<Message> offset) { builder.Finish(offset.Value); }\n+  public static void FinishSizePrefixedMessageBuffer(FlatBufferBuilder builder, Offset<Message> offset) { builder.FinishSizePrefixed(offset.Value); }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs b/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs\nnew file mode 100644\nindex 0000000000..322175c88f\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/RecordBatch.cs\n@@ -0,0 +1,62 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// A data header describing the shared memory layout of a \"record\" or \"row\"\n+/// batch. Some systems call this a \"row batch\" internally and others a \"record\n+/// batch\".\n+public struct RecordBatch : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static RecordBatch GetRootAsRecordBatch(ByteBuffer _bb) { return GetRootAsRecordBatch(_bb, new RecordBatch()); }\n+  public static RecordBatch GetRootAsRecordBatch(ByteBuffer _bb, RecordBatch obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public RecordBatch __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// number of records / rows. The arrays in the batch should all have this\n+  /// length\n+  public long Length { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }\n+  /// Nodes correspond to the pre-ordered flattened logical schema\n+  public FieldNode? Nodes(int j) { int o = __p.__offset(6); return o != 0 ? (FieldNode?)(new FieldNode()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }\n+  public int NodesLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  /// Buffers correspond to the pre-ordered flattened buffer tree\n+  ///\n+  /// The number of buffers appended to this list depends on the schema. For\n+  /// example, most primitive arrays will have 2 buffers, 1 for the validity\n+  /// bitmap and 1 for the values. For struct arrays, there will only be a\n+  /// single buffer for the validity (nulls) bitmap\n+  public Buffer? Buffers(int j) { int o = __p.__offset(8); return o != 0 ? (Buffer?)(new Buffer()).__assign(__p.__vector(o) + j * 16, __p.bb) : null; }\n+  public int BuffersLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }\n+\n+  public static Offset<RecordBatch> CreateRecordBatch(FlatBufferBuilder builder,\n+      long length = 0,\n+      VectorOffset nodesOffset = default(VectorOffset),\n+      VectorOffset buffersOffset = default(VectorOffset)) {\n+    builder.StartObject(3);\n+    RecordBatch.AddLength(builder, length);\n+    RecordBatch.AddBuffers(builder, buffersOffset);\n+    RecordBatch.AddNodes(builder, nodesOffset);\n+    return RecordBatch.EndRecordBatch(builder);\n+  }\n+\n+  public static void StartRecordBatch(FlatBufferBuilder builder) { builder.StartObject(3); }\n+  public static void AddLength(FlatBufferBuilder builder, long length) { builder.AddLong(0, length, 0); }\n+  public static void AddNodes(FlatBufferBuilder builder, VectorOffset nodesOffset) { builder.AddOffset(1, nodesOffset.Value, 0); }\n+  public static void StartNodesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 8); }\n+  public static void AddBuffers(FlatBufferBuilder builder, VectorOffset buffersOffset) { builder.AddOffset(2, buffersOffset.Value, 0); }\n+  public static void StartBuffersVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(16, numElems, 8); }\n+  public static Offset<RecordBatch> EndRecordBatch(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<RecordBatch>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Schema.cs b/csharp/src/Apache.Arrow/Flatbuf/Schema.cs\nnew file mode 100644\nindex 0000000000..94bbf18b19\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Schema.cs\n@@ -0,0 +1,59 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// ----------------------------------------------------------------------\n+/// A Schema describes the columns in a row batch\n+public struct Schema : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Schema GetRootAsSchema(ByteBuffer _bb) { return GetRootAsSchema(_bb, new Schema()); }\n+  public static Schema GetRootAsSchema(ByteBuffer _bb, Schema obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Schema __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// endianness of the buffer\n+  /// it is Little Endian by default\n+  /// if endianness doesn't match the underlying system then the vectors need to be converted\n+  public Endianness Endianness { get { int o = __p.__offset(4); return o != 0 ? (Endianness)__p.bb.GetShort(o + __p.bb_pos) : Endianness.Little; } }\n+  public Field? Fields(int j) { int o = __p.__offset(6); return o != 0 ? (Field?)(new Field()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }\n+  public int FieldsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  public KeyValue? CustomMetadata(int j) { int o = __p.__offset(8); return o != 0 ? (KeyValue?)(new KeyValue()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }\n+  public int CustomMetadataLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }\n+\n+  public static Offset<Schema> CreateSchema(FlatBufferBuilder builder,\n+      Endianness endianness = Endianness.Little,\n+      VectorOffset fieldsOffset = default(VectorOffset),\n+      VectorOffset custom_metadataOffset = default(VectorOffset)) {\n+    builder.StartObject(3);\n+    Schema.AddCustomMetadata(builder, custom_metadataOffset);\n+    Schema.AddFields(builder, fieldsOffset);\n+    Schema.AddEndianness(builder, endianness);\n+    return Schema.EndSchema(builder);\n+  }\n+\n+  public static void StartSchema(FlatBufferBuilder builder) { builder.StartObject(3); }\n+  public static void AddEndianness(FlatBufferBuilder builder, Endianness endianness) { builder.AddShort(0, (short)endianness, 0); }\n+  public static void AddFields(FlatBufferBuilder builder, VectorOffset fieldsOffset) { builder.AddOffset(1, fieldsOffset.Value, 0); }\n+  public static VectorOffset CreateFieldsVector(FlatBufferBuilder builder, Offset<Field>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }\n+  public static void StartFieldsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static void AddCustomMetadata(FlatBufferBuilder builder, VectorOffset customMetadataOffset) { builder.AddOffset(2, customMetadataOffset.Value, 0); }\n+  public static VectorOffset CreateCustomMetadataVector(FlatBufferBuilder builder, Offset<KeyValue>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }\n+  public static void StartCustomMetadataVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static Offset<Schema> EndSchema(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Schema>(o);\n+  }\n+  public static void FinishSchemaBuffer(FlatBufferBuilder builder, Offset<Schema> offset) { builder.Finish(offset.Value); }\n+  public static void FinishSizePrefixedSchemaBuffer(FlatBufferBuilder builder, Offset<Schema> offset) { builder.FinishSizePrefixed(offset.Value); }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Tensor.cs b/csharp/src/Apache.Arrow/Flatbuf/Tensor.cs\nnew file mode 100644\nindex 0000000000..f1d7285892\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Tensor.cs\n@@ -0,0 +1,53 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Tensor : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Tensor GetRootAsTensor(ByteBuffer _bb) { return GetRootAsTensor(_bb, new Tensor()); }\n+  public static Tensor GetRootAsTensor(ByteBuffer _bb, Tensor obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Tensor __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public Type TypeType { get { int o = __p.__offset(4); return o != 0 ? (Type)__p.bb.Get(o + __p.bb_pos) : Flatbuf.Type.NONE; } }\n+  /// The type of data contained in a value cell. Currently only fixed-width\n+  /// value types are supported, no strings or nested types\n+  public TTable? Type<TTable>() where TTable : struct, IFlatbufferObject { int o = __p.__offset(6); return o != 0 ? (TTable?)__p.__union<TTable>(o) : null; }\n+  /// The dimensions of the tensor, optionally named\n+  public TensorDim? Shape(int j) { int o = __p.__offset(8); return o != 0 ? (TensorDim?)(new TensorDim()).__assign(__p.__indirect(__p.__vector(o) + j * 4), __p.bb) : null; }\n+  public int ShapeLength { get { int o = __p.__offset(8); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  /// Non-negative byte offsets to advance one value cell along each dimension\n+  public long Strides(int j) { int o = __p.__offset(10); return o != 0 ? __p.bb.GetLong(__p.__vector(o) + j * 8) : (long)0; }\n+  public int StridesLength { get { int o = __p.__offset(10); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  public ArraySegment<byte>? GetStridesBytes() { return __p.__vector_as_arraysegment(10); }\n+  /// The location and size of the tensor's data\n+  public Buffer? Data { get { int o = __p.__offset(12); return o != 0 ? (Buffer?)(new Buffer()).__assign(o + __p.bb_pos, __p.bb) : null; } }\n+\n+  public static void StartTensor(FlatBufferBuilder builder) { builder.StartObject(5); }\n+  public static void AddTypeType(FlatBufferBuilder builder, Type typeType) { builder.AddByte(0, (byte)typeType, 0); }\n+  public static void AddType(FlatBufferBuilder builder, int typeOffset) { builder.AddOffset(1, typeOffset, 0); }\n+  public static void AddShape(FlatBufferBuilder builder, VectorOffset shapeOffset) { builder.AddOffset(2, shapeOffset.Value, 0); }\n+  public static VectorOffset CreateShapeVector(FlatBufferBuilder builder, Offset<TensorDim>[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddOffset(data[i].Value); return builder.EndVector(); }\n+  public static void StartShapeVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static void AddStrides(FlatBufferBuilder builder, VectorOffset stridesOffset) { builder.AddOffset(3, stridesOffset.Value, 0); }\n+  public static VectorOffset CreateStridesVector(FlatBufferBuilder builder, long[] data) { builder.StartVector(8, data.Length, 8); for (int i = data.Length - 1; i >= 0; i--) builder.AddLong(data[i]); return builder.EndVector(); }\n+  public static void StartStridesVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(8, numElems, 8); }\n+  public static void AddData(FlatBufferBuilder builder, Offset<Buffer> dataOffset) { builder.AddStruct(4, dataOffset.Value, 0); }\n+  public static Offset<Tensor> EndTensor(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Tensor>(o);\n+  }\n+  public static void FinishTensorBuffer(FlatBufferBuilder builder, Offset<Tensor> offset) { builder.Finish(offset.Value); }\n+  public static void FinishSizePrefixedTensorBuffer(FlatBufferBuilder builder, Offset<Tensor> offset) { builder.FinishSizePrefixed(offset.Value); }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/TensorDim.cs b/csharp/src/Apache.Arrow/Flatbuf/TensorDim.cs\nnew file mode 100644\nindex 0000000000..ee8e94e083\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/TensorDim.cs\n@@ -0,0 +1,46 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// Shape data for a single axis in a tensor\n+public struct TensorDim : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static TensorDim GetRootAsTensorDim(ByteBuffer _bb) { return GetRootAsTensorDim(_bb, new TensorDim()); }\n+  public static TensorDim GetRootAsTensorDim(ByteBuffer _bb, TensorDim obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public TensorDim __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Length of dimension\n+  public long Size { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetLong(o + __p.bb_pos) : (long)0; } }\n+  /// Name of the dimension, optional\n+  public string Name { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }\n+  public ArraySegment<byte>? GetNameBytes() { return __p.__vector_as_arraysegment(6); }\n+\n+  public static Offset<TensorDim> CreateTensorDim(FlatBufferBuilder builder,\n+      long size = 0,\n+      StringOffset nameOffset = default(StringOffset)) {\n+    builder.StartObject(2);\n+    TensorDim.AddSize(builder, size);\n+    TensorDim.AddName(builder, nameOffset);\n+    return TensorDim.EndTensorDim(builder);\n+  }\n+\n+  public static void StartTensorDim(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddSize(FlatBufferBuilder builder, long size) { builder.AddLong(0, size, 0); }\n+  public static void AddName(FlatBufferBuilder builder, StringOffset nameOffset) { builder.AddOffset(1, nameOffset.Value, 0); }\n+  public static Offset<TensorDim> EndTensorDim(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<TensorDim>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Binary.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Binary.cs\nnew file mode 100644\nindex 0000000000..119c00f203\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Binary.cs\n@@ -0,0 +1,29 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Binary : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Binary GetRootAsBinary(ByteBuffer _bb) { return GetRootAsBinary(_bb, new Binary()); }\n+  public static Binary GetRootAsBinary(ByteBuffer _bb, Binary obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Binary __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartBinary(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<Binary> EndBinary(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Binary>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Bool.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Bool.cs\nnew file mode 100644\nindex 0000000000..4f90845bd4\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Bool.cs\n@@ -0,0 +1,29 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Bool : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Bool GetRootAsBool(ByteBuffer _bb) { return GetRootAsBool(_bb, new Bool()); }\n+  public static Bool GetRootAsBool(ByteBuffer _bb, Bool obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Bool __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartBool(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<Bool> EndBool(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Bool>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Date.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Date.cs\nnew file mode 100644\nindex 0000000000..0074a4d398\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Date.cs\n@@ -0,0 +1,44 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// Date is either a 32-bit or 64-bit type representing elapsed time since UNIX\n+/// epoch (1970-01-01), stored in either of two units:\n+///\n+/// * Milliseconds (64 bits) indicating UNIX time elapsed since the epoch (no\n+///   leap seconds), where the values are evenly divisible by 86400000\n+/// * Days (32 bits) since the UNIX epoch\n+public struct Date : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Date GetRootAsDate(ByteBuffer _bb) { return GetRootAsDate(_bb, new Date()); }\n+  public static Date GetRootAsDate(ByteBuffer _bb, Date obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Date __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public DateUnit Unit { get { int o = __p.__offset(4); return o != 0 ? (DateUnit)__p.bb.GetShort(o + __p.bb_pos) : DateUnit.MILLISECOND; } }\n+\n+  public static Offset<Date> CreateDate(FlatBufferBuilder builder,\n+      DateUnit unit = DateUnit.MILLISECOND) {\n+    builder.StartObject(1);\n+    Date.AddUnit(builder, unit);\n+    return Date.EndDate(builder);\n+  }\n+\n+  public static void StartDate(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddUnit(FlatBufferBuilder builder, DateUnit unit) { builder.AddShort(0, (short)unit, 1); }\n+  public static Offset<Date> EndDate(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Date>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs\nnew file mode 100644\nindex 0000000000..c10a63d672\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Decimal.cs\n@@ -0,0 +1,44 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Decimal : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Decimal GetRootAsDecimal(ByteBuffer _bb) { return GetRootAsDecimal(_bb, new Decimal()); }\n+  public static Decimal GetRootAsDecimal(ByteBuffer _bb, Decimal obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Decimal __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  /// Total number of decimal digits\n+  public int Precision { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }\n+  /// Number of digits after the decimal point \".\"\n+  public int Scale { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }\n+\n+  public static Offset<Decimal> CreateDecimal(FlatBufferBuilder builder,\n+      int precision = 0,\n+      int scale = 0) {\n+    builder.StartObject(2);\n+    Decimal.AddScale(builder, scale);\n+    Decimal.AddPrecision(builder, precision);\n+    return Decimal.EndDecimal(builder);\n+  }\n+\n+  public static void StartDecimal(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddPrecision(FlatBufferBuilder builder, int precision) { builder.AddInt(0, precision, 0); }\n+  public static void AddScale(FlatBufferBuilder builder, int scale) { builder.AddInt(1, scale, 0); }\n+  public static Offset<Decimal> EndDecimal(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Decimal>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/FloatingPoint.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/FloatingPoint.cs\nnew file mode 100644\nindex 0000000000..6959042759\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/FloatingPoint.cs\n@@ -0,0 +1,38 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct FloatingPoint : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static FloatingPoint GetRootAsFloatingPoint(ByteBuffer _bb) { return GetRootAsFloatingPoint(_bb, new FloatingPoint()); }\n+  public static FloatingPoint GetRootAsFloatingPoint(ByteBuffer _bb, FloatingPoint obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public FloatingPoint __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public Precision Precision { get { int o = __p.__offset(4); return o != 0 ? (Precision)__p.bb.GetShort(o + __p.bb_pos) : Precision.HALF; } }\n+\n+  public static Offset<FloatingPoint> CreateFloatingPoint(FlatBufferBuilder builder,\n+      Precision precision = Precision.HALF) {\n+    builder.StartObject(1);\n+    FloatingPoint.AddPrecision(builder, precision);\n+    return FloatingPoint.EndFloatingPoint(builder);\n+  }\n+\n+  public static void StartFloatingPoint(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddPrecision(FlatBufferBuilder builder, Precision precision) { builder.AddShort(0, (short)precision, 0); }\n+  public static Offset<FloatingPoint> EndFloatingPoint(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<FloatingPoint>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Int.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Int.cs\nnew file mode 100644\nindex 0000000000..13608a5c51\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Int.cs\n@@ -0,0 +1,42 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Int : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Int GetRootAsInt(ByteBuffer _bb) { return GetRootAsInt(_bb, new Int()); }\n+  public static Int GetRootAsInt(ByteBuffer _bb, Int obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Int __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public int BitWidth { get { int o = __p.__offset(4); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)0; } }\n+  public bool IsSigned { get { int o = __p.__offset(6); return o != 0 ? 0!=__p.bb.Get(o + __p.bb_pos) : (bool)false; } }\n+\n+  public static Offset<Int> CreateInt(FlatBufferBuilder builder,\n+      int bitWidth = 0,\n+      bool is_signed = false) {\n+    builder.StartObject(2);\n+    Int.AddBitWidth(builder, bitWidth);\n+    Int.AddIsSigned(builder, is_signed);\n+    return Int.EndInt(builder);\n+  }\n+\n+  public static void StartInt(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddBitWidth(FlatBufferBuilder builder, int bitWidth) { builder.AddInt(0, bitWidth, 0); }\n+  public static void AddIsSigned(FlatBufferBuilder builder, bool isSigned) { builder.AddBool(1, isSigned, false); }\n+  public static Offset<Int> EndInt(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Int>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Interval.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Interval.cs\nnew file mode 100644\nindex 0000000000..4e6191dabe\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Interval.cs\n@@ -0,0 +1,38 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct Interval : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Interval GetRootAsInterval(ByteBuffer _bb) { return GetRootAsInterval(_bb, new Interval()); }\n+  public static Interval GetRootAsInterval(ByteBuffer _bb, Interval obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Interval __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public IntervalUnit Unit { get { int o = __p.__offset(4); return o != 0 ? (IntervalUnit)__p.bb.GetShort(o + __p.bb_pos) : IntervalUnit.YEAR_MONTH; } }\n+\n+  public static Offset<Interval> CreateInterval(FlatBufferBuilder builder,\n+      IntervalUnit unit = IntervalUnit.YEAR_MONTH) {\n+    builder.StartObject(1);\n+    Interval.AddUnit(builder, unit);\n+    return Interval.EndInterval(builder);\n+  }\n+\n+  public static void StartInterval(FlatBufferBuilder builder) { builder.StartObject(1); }\n+  public static void AddUnit(FlatBufferBuilder builder, IntervalUnit unit) { builder.AddShort(0, (short)unit, 0); }\n+  public static Offset<Interval> EndInterval(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Interval>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/List.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/List.cs\nnew file mode 100644\nindex 0000000000..3051cd8a85\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/List.cs\n@@ -0,0 +1,29 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+public struct List : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static List GetRootAsList(ByteBuffer _bb) { return GetRootAsList(_bb, new List()); }\n+  public static List GetRootAsList(ByteBuffer _bb, List obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public List __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartList(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<List> EndList(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<List>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Null.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Null.cs\nnew file mode 100644\nindex 0000000000..3a0fdfc16b\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Null.cs\n@@ -0,0 +1,30 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// These are stored in the flatbuffer in the Type union below\n+public struct Null : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Null GetRootAsNull(ByteBuffer _bb) { return GetRootAsNull(_bb, new Null()); }\n+  public static Null GetRootAsNull(ByteBuffer _bb, Null obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Null __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartNull(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<Null> EndNull(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Null>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Struct_.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Struct_.cs\nnew file mode 100644\nindex 0000000000..f1d7aa27dc\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Struct_.cs\n@@ -0,0 +1,32 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// A Struct_ in the flatbuffer metadata is the same as an Arrow Struct\n+/// (according to the physical memory layout). We used Struct_ here as\n+/// Struct is a reserved word in Flatbuffers\n+public struct Struct_ : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Struct_ GetRootAsStruct_(ByteBuffer _bb) { return GetRootAsStruct_(_bb, new Struct_()); }\n+  public static Struct_ GetRootAsStruct_(ByteBuffer _bb, Struct_ obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Struct_ __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartStruct_(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<Struct_> EndStruct_(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Struct_>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Time.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Time.cs\nnew file mode 100644\nindex 0000000000..5d1d3947da\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Time.cs\n@@ -0,0 +1,45 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// Time type. The physical storage type depends on the unit\n+/// - SECOND and MILLISECOND: 32 bits\n+/// - MICROSECOND and NANOSECOND: 64 bits\n+public struct Time : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Time GetRootAsTime(ByteBuffer _bb) { return GetRootAsTime(_bb, new Time()); }\n+  public static Time GetRootAsTime(ByteBuffer _bb, Time obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Time __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public TimeUnit Unit { get { int o = __p.__offset(4); return o != 0 ? (TimeUnit)__p.bb.GetShort(o + __p.bb_pos) : TimeUnit.MILLISECOND; } }\n+  public int BitWidth { get { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(o + __p.bb_pos) : (int)32; } }\n+\n+  public static Offset<Time> CreateTime(FlatBufferBuilder builder,\n+      TimeUnit unit = TimeUnit.MILLISECOND,\n+      int bitWidth = 32) {\n+    builder.StartObject(2);\n+    Time.AddBitWidth(builder, bitWidth);\n+    Time.AddUnit(builder, unit);\n+    return Time.EndTime(builder);\n+  }\n+\n+  public static void StartTime(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddUnit(FlatBufferBuilder builder, TimeUnit unit) { builder.AddShort(0, (short)unit, 1); }\n+  public static void AddBitWidth(FlatBufferBuilder builder, int bitWidth) { builder.AddInt(1, bitWidth, 32); }\n+  public static Offset<Time> EndTime(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Time>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Timestamp.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Timestamp.cs\nnew file mode 100644\nindex 0000000000..576b076dd2\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Timestamp.cs\n@@ -0,0 +1,69 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// Time elapsed from the Unix epoch, 00:00:00.000 on 1 January 1970, excluding\n+/// leap seconds, as a 64-bit integer. Note that UNIX time does not include\n+/// leap seconds.\n+///\n+/// The Timestamp metadata supports both \"time zone naive\" and \"time zone\n+/// aware\" timestamps. Read about the timezone attribute for more detail\n+public struct Timestamp : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Timestamp GetRootAsTimestamp(ByteBuffer _bb) { return GetRootAsTimestamp(_bb, new Timestamp()); }\n+  public static Timestamp GetRootAsTimestamp(ByteBuffer _bb, Timestamp obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Timestamp __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public TimeUnit Unit { get { int o = __p.__offset(4); return o != 0 ? (TimeUnit)__p.bb.GetShort(o + __p.bb_pos) : TimeUnit.SECOND; } }\n+  /// The time zone is a string indicating the name of a time zone, one of:\n+  ///\n+  /// * As used in the Olson time zone database (the \"tz database\" or\n+  ///   \"tzdata\"), such as \"America/New_York\"\n+  /// * An absolute time zone offset of the form +XX:XX or -XX:XX, such as +07:30\n+  ///\n+  /// Whether a timezone string is present indicates different semantics about\n+  /// the data:\n+  ///\n+  /// * If the time zone is null or equal to an empty string, the data is \"time\n+  ///   zone naive\" and shall be displayed *as is* to the user, not localized\n+  ///   to the locale of the user. This data can be though of as UTC but\n+  ///   without having \"UTC\" as the time zone, it is not considered to be\n+  ///   localized to any time zone\n+  ///\n+  /// * If the time zone is set to a valid value, values can be displayed as\n+  ///   \"localized\" to that time zone, even though the underlying 64-bit\n+  ///   integers are identical to the same data stored in UTC. Converting\n+  ///   between time zones is a metadata-only operation and does not change the\n+  ///   underlying values\n+  public string Timezone { get { int o = __p.__offset(6); return o != 0 ? __p.__string(o + __p.bb_pos) : null; } }\n+  public ArraySegment<byte>? GetTimezoneBytes() { return __p.__vector_as_arraysegment(6); }\n+\n+  public static Offset<Timestamp> CreateTimestamp(FlatBufferBuilder builder,\n+      TimeUnit unit = TimeUnit.SECOND,\n+      StringOffset timezoneOffset = default(StringOffset)) {\n+    builder.StartObject(2);\n+    Timestamp.AddTimezone(builder, timezoneOffset);\n+    Timestamp.AddUnit(builder, unit);\n+    return Timestamp.EndTimestamp(builder);\n+  }\n+\n+  public static void StartTimestamp(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddUnit(FlatBufferBuilder builder, TimeUnit unit) { builder.AddShort(0, (short)unit, 0); }\n+  public static void AddTimezone(FlatBufferBuilder builder, StringOffset timezoneOffset) { builder.AddOffset(1, timezoneOffset.Value, 0); }\n+  public static Offset<Timestamp> EndTimestamp(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Timestamp>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Union.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Union.cs\nnew file mode 100644\nindex 0000000000..b3ca36e984\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Union.cs\n@@ -0,0 +1,50 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// A union is a complex type with children in Field\n+/// By default ids in the type vector refer to the offsets in the children\n+/// optionally typeIds provides an indirection between the child offset and the type id\n+/// for each child typeIds[offset] is the id used in the type vector\n+public struct Union : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Union GetRootAsUnion(ByteBuffer _bb) { return GetRootAsUnion(_bb, new Union()); }\n+  public static Union GetRootAsUnion(ByteBuffer _bb, Union obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Union __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+  public UnionMode Mode { get { int o = __p.__offset(4); return o != 0 ? (UnionMode)__p.bb.GetShort(o + __p.bb_pos) : UnionMode.Sparse; } }\n+  public int TypeIds(int j) { int o = __p.__offset(6); return o != 0 ? __p.bb.GetInt(__p.__vector(o) + j * 4) : (int)0; }\n+  public int TypeIdsLength { get { int o = __p.__offset(6); return o != 0 ? __p.__vector_len(o) : 0; } }\n+  public ArraySegment<byte>? GetTypeIdsBytes() { return __p.__vector_as_arraysegment(6); }\n+\n+  public static Offset<Union> CreateUnion(FlatBufferBuilder builder,\n+      UnionMode mode = UnionMode.Sparse,\n+      VectorOffset typeIdsOffset = default(VectorOffset)) {\n+    builder.StartObject(2);\n+    Union.AddTypeIds(builder, typeIdsOffset);\n+    Union.AddMode(builder, mode);\n+    return Union.EndUnion(builder);\n+  }\n+\n+  public static void StartUnion(FlatBufferBuilder builder) { builder.StartObject(2); }\n+  public static void AddMode(FlatBufferBuilder builder, UnionMode mode) { builder.AddShort(0, (short)mode, 0); }\n+  public static void AddTypeIds(FlatBufferBuilder builder, VectorOffset typeIdsOffset) { builder.AddOffset(1, typeIdsOffset.Value, 0); }\n+  public static VectorOffset CreateTypeIdsVector(FlatBufferBuilder builder, int[] data) { builder.StartVector(4, data.Length, 4); for (int i = data.Length - 1; i >= 0; i--) builder.AddInt(data[i]); return builder.EndVector(); }\n+  public static void StartTypeIdsVector(FlatBufferBuilder builder, int numElems) { builder.StartVector(4, numElems, 4); }\n+  public static Offset<Union> EndUnion(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Union>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Flatbuf/Types/Utf8.cs b/csharp/src/Apache.Arrow/Flatbuf/Types/Utf8.cs\nnew file mode 100644\nindex 0000000000..c3ebb70b79\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Flatbuf/Types/Utf8.cs\n@@ -0,0 +1,30 @@\n+// <auto-generated>\n+//  automatically generated by the FlatBuffers compiler, do not modify\n+// </auto-generated>\n+\n+namespace Apache.Arrow.Flatbuf\n+{\n+\n+using global::System;\n+using global::FlatBuffers;\n+\n+/// Unicode with UTF-8 encoding\n+public struct Utf8 : IFlatbufferObject\n+{\n+  private Table __p;\n+  public ByteBuffer ByteBuffer { get { return __p.bb; } }\n+  public static Utf8 GetRootAsUtf8(ByteBuffer _bb) { return GetRootAsUtf8(_bb, new Utf8()); }\n+  public static Utf8 GetRootAsUtf8(ByteBuffer _bb, Utf8 obj) { return (obj.__assign(_bb.GetInt(_bb.Position) + _bb.Position, _bb)); }\n+  public void __init(int _i, ByteBuffer _bb) { __p.bb_pos = _i; __p.bb = _bb; }\n+  public Utf8 __assign(int _i, ByteBuffer _bb) { __init(_i, _bb); return this; }\n+\n+\n+  public static void StartUtf8(FlatBufferBuilder builder) { builder.StartObject(0); }\n+  public static Offset<Utf8> EndUtf8(FlatBufferBuilder builder) {\n+    int o = builder.EndObject();\n+    return new Offset<Utf8>(o);\n+  }\n+};\n+\n+\n+}\ndiff --git a/csharp/src/Apache.Arrow/Interfaces/IArrowArray.cs b/csharp/src/Apache.Arrow/Interfaces/IArrowArray.cs\nnew file mode 100644\nindex 0000000000..6a8f035982\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Interfaces/IArrowArray.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow\n+{\n+    public interface IArrowArray\n+    {\n+        bool IsNull(int index);\n+\n+        bool IsValid(int index);\n+\n+        int Length { get; }\n+\n+        int Offset { get; }\n+\n+        int NullCount { get; }\n+\n+        ArrayData Data { get; }\n+\n+        void Accept(IArrowArrayVisitor visitor);\n+\n+        //IArrowArray Slice(int offset);\n+\n+        //IArrowArray Slice(int offset, int length);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Interfaces/IArrowArrayVisitor.cs b/csharp/src/Apache.Arrow/Interfaces/IArrowArrayVisitor.cs\nnew file mode 100644\nindex 0000000000..c93bbb4837\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Interfaces/IArrowArrayVisitor.cs\n@@ -0,0 +1,30 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow\n+{\n+    // NOTE: Acyclic Visitor Pattern\n+\n+    public interface IArrowArrayVisitor\n+    {\n+        void Visit(IArrowArray array);\n+    }\n+\n+    public interface IArrowArrayVisitor<T>: IArrowArrayVisitor\n+        where T: IArrowArray\n+    {\n+        void Visit(T array);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowFileConstants.cs b/csharp/src/Apache.Arrow/Ipc/ArrowFileConstants.cs\nnew file mode 100644\nindex 0000000000..6b308d6939\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowFileConstants.cs\n@@ -0,0 +1,24 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Text;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    internal static class ArrowFileConstants\n+    {\n+        public static readonly byte[] Magic = Encoding.UTF8.GetBytes(\"ARROW1\");\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowFileReader.cs b/csharp/src/Apache.Arrow/Ipc/ArrowFileReader.cs\nnew file mode 100644\nindex 0000000000..c47eab5884\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowFileReader.cs\n@@ -0,0 +1,216 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Buffers.Binary;\n+using System.IO;\n+using System.Threading.Tasks;\n+using FlatBuffers;\n+using System.Threading;\n+using System.Linq;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    public class ArrowFileReader : ArrowStreamReader\n+    {\n+\n+        public bool IsFileValid { get; protected set; }\n+\n+        /// <summary>\n+        /// When using GetNextRecordBatch this value \n+        /// is to remember what index is next\n+        /// </summary>\n+        private int _recordBatchIndex;\n+\n+        /// <summary>\n+        /// Notes what byte position where the footer data is in the stream\n+        /// </summary>\n+        private int _footerStartPostion;\n+\n+        private ArrowFooter _footer;\n+\n+        public async Task<int> RecordBatchCountAsync()\n+        {\n+            if (!HasReadSchema)\n+            {\n+                await ReadSchemaAsync();\n+            }\n+\n+            return _footer.RecordBatchCount;\n+        }\n+\n+        public ArrowFileReader(Stream stream) : base(stream)\n+        {\n+            if (!stream.CanSeek)\n+            {\n+                throw new ArgumentException(\"Stream must be seekable.\", nameof(stream));\n+            }\n+\n+            if (!stream.CanRead)\n+            {\n+                throw new ArgumentException(\"Stream must be readable.\");\n+            }\n+\n+            IsFileValid = false;\n+        }\n+\n+        public static ArrowFileReader FromFile(string filename)\n+        {\n+            var stream = new FileStream(filename, FileMode.Open);\n+            return new ArrowFileReader(stream);\n+        }\n+\n+        protected override async Task<Schema> ReadSchemaAsync()\n+        {\n+            if (HasReadSchema)\n+            {\n+                return Schema;\n+            }\n+\n+            await ValidateFileAsync();\n+\n+            var bytesRead = 0;\n+            var footerLength = 0;\n+\n+            await Buffers.RentReturnAsync(4, async (buffer) =>\n+            {\n+                BaseStream.Position = BaseStream.Length - ArrowFileConstants.Magic.Length - 4;\n+\n+                bytesRead = await BaseStream.ReadAsync(buffer, 0, 4);\n+                footerLength = BinaryPrimitives.ReadInt32LittleEndian(buffer);\n+\n+                if (bytesRead != 4) throw new InvalidDataException(\n+                    $\"Failed to read footer length. Read <{bytesRead}>, expected 4.\");\n+\n+                if (footerLength <= 0) throw new InvalidDataException(\n+                    $\"Footer length has invalid size <{footerLength}>\");\n+            });\n+\n+            await Buffers.RentReturnAsync(footerLength, async (buffer) =>\n+            {\n+                _footerStartPostion = (int)BaseStream.Length - footerLength - ArrowFileConstants.Magic.Length - 4;\n+\n+                BaseStream.Position = _footerStartPostion;\n+\n+                bytesRead = await BaseStream.ReadAsync(buffer, 0, footerLength);\n+\n+                if (bytesRead != footerLength)\n+                {\n+                    throw new InvalidDataException(\n+                        $\"Failed to read footer. Read <{bytesRead}> bytes, expected <{footerLength}>.\");\n+                }\n+\n+                // Deserialize the footer from the footer flatbuffer\n+\n+                _footer = new ArrowFooter(Flatbuf.Footer.GetRootAsFooter(new ByteBuffer(buffer)));\n+\n+                Schema = _footer.Schema;\n+            });\n+\n+            return Schema;\n+        }\n+\n+        public async Task<RecordBatch> ReadRecordBatchAsync(int index, CancellationToken cancellationToken = default)\n+        {\n+            await ReadSchemaAsync();\n+\n+            if (index >= _footer.RecordBatchCount)\n+            {\n+                throw new ArgumentOutOfRangeException(nameof(index));\n+            }\n+\n+            var block = _footer.GetRecordBatchBlock(index);\n+\n+            BaseStream.Position = block.Offset;\n+\n+            return await ReadRecordBatchAsync(cancellationToken);\n+        }\n+\n+        public override async Task<RecordBatch> ReadNextRecordBatchAsync(CancellationToken cancellationToken = default)\n+        {\n+            await ReadSchemaAsync();\n+\n+            if (_recordBatchIndex >= _footer.RecordBatchCount)\n+            {\n+                return null;\n+            }\n+\n+            var result = await ReadRecordBatchAsync(_recordBatchIndex, cancellationToken);\n+            _recordBatchIndex++;\n+\n+            return result;\n+        }\n+\n+        /// <summary>\n+        /// Check if file format is valid. If it's valid don't run the validation again.\n+        /// </summary>\n+        private async Task ValidateFileAsync()\n+        {\n+            if (IsFileValid)\n+            {\n+                return;\n+            }\n+\n+            await ValidateMagicAsync();\n+\n+            IsFileValid = true;\n+        }\n+\n+        private async Task ValidateMagicAsync()\n+        {\n+            var startingPosition = BaseStream.Position;\n+            var magicLength = ArrowFileConstants.Magic.Length;\n+\n+            try\n+            {\n+                await Buffers.RentReturnAsync(magicLength, async (buffer) =>\n+                {\n+                    // Seek to the beginning of the stream\n+\n+                    BaseStream.Position = 0;\n+\n+                    // Read beginning of stream\n+\n+                    await BaseStream.ReadAsync(buffer, 0, magicLength);\n+\n+                    if (!ArrowFileConstants.Magic.SequenceEqual(buffer.Take(magicLength)))\n+                    {\n+                        throw new InvalidDataException(\n+                            $\"Invalid magic at offset <{BaseStream.Position}>\");\n+                    }\n+\n+                    // Move stream position to magic-length bytes away from the end of the stream\n+\n+                    BaseStream.Position = BaseStream.Length - magicLength;\n+\n+                    // Read the end of the stream\n+\n+                    await BaseStream.ReadAsync(buffer, 0, magicLength);\n+\n+                    if (!ArrowFileConstants.Magic.SequenceEqual(buffer.Take(magicLength)))\n+                    {\n+                        throw new InvalidDataException(\n+                            $\"Invalid magic at offset <{BaseStream.Position}>\");\n+                    }\n+                });\n+            }\n+            finally\n+            {\n+                BaseStream.Position = startingPosition;\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowFileWriter.cs b/csharp/src/Apache.Arrow/Ipc/ArrowFileWriter.cs\nnew file mode 100644\nindex 0000000000..dac7b5bee2\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowFileWriter.cs\n@@ -0,0 +1,167 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers.Binary;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    public class ArrowFileWriter: ArrowStreamWriter\n+    { \n+        private bool HasWrittenHeader { get; set; }\n+        private bool HasWrittenFooter { get; set; }\n+\n+        private List<Block> RecordBatchBlocks { get; }\n+\n+        public ArrowFileWriter(Stream stream, Schema schema)\n+            : base(stream, schema)\n+        {\n+            if (!stream.CanWrite)\n+            {\n+                throw new ArgumentException(\"stream must be writable\", nameof(stream));\n+            }\n+\n+            if (!stream.CanSeek)\n+            {\n+                throw new ArgumentException(\"stream must be seekable\", nameof(stream));\n+            }\n+\n+            HasWrittenHeader = false;\n+            HasWrittenFooter = false;\n+\n+            RecordBatchBlocks = new List<Block>();\n+        }\n+\n+        public override async Task WriteRecordBatchAsync(RecordBatch recordBatch, CancellationToken cancellationToken = default)\n+        {\n+            // TODO: Compare record batch schema\n+\n+            if (!HasWrittenHeader)\n+            {\n+                await WriteHeaderAsync(cancellationToken);\n+                HasWrittenHeader = true;\n+            }\n+\n+            cancellationToken.ThrowIfCancellationRequested();\n+\n+            var block = await WriteRecordBatchInternalAsync(recordBatch, cancellationToken);\n+\n+            RecordBatchBlocks.Add(block);\n+        }\n+\n+        public async Task CloseAsync(CancellationToken cancellationToken = default)\n+        {\n+            if (!HasWrittenFooter)\n+            {\n+                await WriteFooterAsync(Schema, cancellationToken);\n+                HasWrittenFooter = true;\n+            }\n+\n+            await BaseStream.FlushAsync(cancellationToken);\n+        }\n+\n+        public override void Dispose()\n+        {\n+            try\n+            {\n+                CloseAsync().GetAwaiter().GetResult();\n+            }\n+            catch(Exception ex)\n+            {\n+                // NOTE: Dispose shouldn't throw.\n+                Debug.WriteLine(ex);\n+            }\n+        }\n+\n+        private async Task WriteHeaderAsync(CancellationToken cancellationToken)\n+        {\n+            cancellationToken.ThrowIfCancellationRequested();\n+\n+            // Write magic number and empty padding up to the 8-byte boundary\n+\n+            await WriteMagicAsync();\n+            await WritePaddingAsync(CalculatePadding(ArrowFileConstants.Magic.Length));\n+        }\n+\n+        private async Task WriteFooterAsync(Schema schema, CancellationToken cancellationToken)\n+        {\n+            Builder.Clear();\n+\n+            var offset = BaseStream.Position;\n+\n+            // Serialize the schema\n+\n+            var schemaOffset = SerializeSchema(schema);\n+\n+            // Serialize all record batches\n+\n+            Flatbuf.Footer.StartRecordBatchesVector(Builder, RecordBatchBlocks.Count);\n+\n+            foreach (var recordBatch in RecordBatchBlocks)\n+            {\n+                Flatbuf.Block.CreateBlock(\n+                    Builder, recordBatch.Offset, recordBatch.MetadataLength, recordBatch.Length);\n+            }\n+\n+            var recordBatchesVectorOffset = Builder.EndVector();\n+\n+            // Serialize all dictionaries\n+            // NOTE: Currently unsupported.\n+\n+            Flatbuf.Footer.StartDictionariesVector(Builder, 0);\n+\n+            var dictionaryBatchesOffset = Builder.EndVector();\n+\n+            // Serialize and write the footer flatbuffer\n+\n+            var footerOffset = Flatbuf.Footer.CreateFooter(Builder, CurrentMetadataVersion,\n+                schemaOffset, dictionaryBatchesOffset, recordBatchesVectorOffset);\n+\n+            Builder.Finish(footerOffset.Value);\n+\n+            cancellationToken.ThrowIfCancellationRequested();\n+\n+            await WriteFlatBufferAsync(cancellationToken);\n+\n+            // Write footer length\n+\n+            cancellationToken.ThrowIfCancellationRequested();\n+\n+            Buffers.RentReturn(4, (buffer) =>\n+            {\n+                BinaryPrimitives.WriteInt32LittleEndian(buffer,\n+                    Convert.ToInt32(BaseStream.Position - offset));\n+            });\n+\n+            // Write magic\n+\n+            cancellationToken.ThrowIfCancellationRequested();\n+\n+            await WriteMagicAsync();\n+        }\n+\n+        private Task WriteMagicAsync()\n+        {\n+            return BaseStream.WriteAsync(\n+                ArrowFileConstants.Magic, 0, ArrowFileConstants.Magic.Length);\n+        }\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowFooter.cs b/csharp/src/Apache.Arrow/Ipc/ArrowFooter.cs\nnew file mode 100644\nindex 0000000000..f59063be5d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowFooter.cs\n@@ -0,0 +1,77 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    internal class ArrowFooter\n+    {\n+        public Schema Schema { get; }\n+        private readonly List<Block> _dictionaries;\n+        private readonly List<Block> _recordBatches;\n+\n+        public IEnumerable<Block> Dictionaries => _dictionaries;\n+        public IEnumerable<Block> RecordBatches => _recordBatches;\n+\n+        public Block GetRecordBatchBlock(int i) => _recordBatches[i];\n+\n+        public Block GetDictionaryBlock(int i) => _dictionaries[i];\n+\n+        public int RecordBatchCount => _recordBatches.Count;\n+        public int DictionaryCount => _dictionaries.Count;\n+\n+        public ArrowFooter(Schema schema, IEnumerable<Block> dictionaries, IEnumerable<Block> recordBatches)\n+        {\n+            Schema = schema;\n+\n+            _dictionaries = dictionaries.ToList();\n+            _recordBatches = recordBatches.ToList();\n+        }\n+\n+        public ArrowFooter(Flatbuf.Footer footer)\n+            : this(Ipc.MessageSerializer.GetSchema(footer.Schema.GetValueOrDefault()), GetDictionaries(footer),\n+                GetRecordBatches(footer))\n+        { }\n+\n+        private static IEnumerable<Block> GetDictionaries(Flatbuf.Footer footer)\n+        {\n+            for (var i = 0; i < footer.DictionariesLength; i++)\n+            {\n+                var block = footer.Dictionaries(i);\n+\n+                if (block.HasValue)\n+                {\n+                    yield return new Block(block.Value);\n+                }\n+            }\n+        }\n+\n+        private static IEnumerable<Block> GetRecordBatches(Flatbuf.Footer footer)\n+        {\n+            for (var i = 0; i < footer.RecordBatchesLength; i++)\n+            {\n+                var block = footer.RecordBatches(i);\n+\n+                if (block.HasValue)\n+                {\n+                    yield return new Block(block.Value);\n+                }\n+            }\n+        }\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowStreamReader.cs b/csharp/src/Apache.Arrow/Ipc/ArrowStreamReader.cs\nnew file mode 100644\nindex 0000000000..18e254c805\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowStreamReader.cs\n@@ -0,0 +1,292 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Collections.Generic;\n+using System.Diagnostics;\n+using System.IO;\n+using System.Linq;\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    public class ArrowStreamReader : IArrowReader, IDisposable\n+    {\n+        public Schema Schema { get; protected set; }\n+        public Stream BaseStream { get; }\n+\n+        protected ArrayPool<byte> Buffers { get; }\n+\n+        public ArrowStreamReader(Stream stream)\n+        {\n+            BaseStream = stream ?? throw new ArgumentNullException(nameof(stream));\n+            Buffers = ArrayPool<byte>.Create();\n+            Schema = null;\n+        }\n+\n+        protected bool HasReadSchema => Schema != null;\n+\n+        public virtual async Task<RecordBatch> ReadNextRecordBatchAsync(CancellationToken cancellationToken = default)\n+        {\n+            // TODO: Loop until a record batch is read.\n+            cancellationToken.ThrowIfCancellationRequested();\n+            return await ReadRecordBatchAsync(cancellationToken);\n+        }\n+\n+        protected async Task<RecordBatch> ReadRecordBatchAsync(CancellationToken cancellationToken = default)\n+        {\n+            await ReadSchemaAsync();\n+\n+            var bytesRead = 0;\n+\n+            byte[] lengthBuffer = null;\n+            byte[] messageBuff = null;\n+            byte[] bodyBuff = null;\n+\n+            try\n+            {\n+                // Get Length of record batch for message header.\n+\n+                lengthBuffer = Buffers.Rent(4);\n+                bytesRead += await BaseStream.ReadAsync(lengthBuffer, 0, 4, cancellationToken);\n+                var messageLength = BitConverter.ToInt32(lengthBuffer, 0);\n+\n+                messageBuff = Buffers.Rent(messageLength);\n+                bytesRead += await BaseStream.ReadAsync(messageBuff, 0, messageLength, cancellationToken);\n+                var message = Flatbuf.Message.GetRootAsMessage(new FlatBuffers.ByteBuffer(messageBuff));\n+\n+                bodyBuff = Buffers.Rent((int)message.BodyLength);\n+                var bodybb = new FlatBuffers.ByteBuffer(bodyBuff);\n+                bytesRead += await BaseStream.ReadAsync(bodyBuff, 0, (int)message.BodyLength, cancellationToken);\n+\n+                switch (message.HeaderType)\n+                {\n+                    case Flatbuf.MessageHeader.Schema:\n+                        // TODO: Read schema and verify equality?\n+                        break;\n+                    case Flatbuf.MessageHeader.DictionaryBatch:\n+                        // TODO: not supported currently\n+                        Debug.WriteLine(\"Dictionaries are not yet supported.\");\n+                        break;\n+                    case Flatbuf.MessageHeader.RecordBatch:\n+                        var rb = message.Header<Flatbuf.RecordBatch>().Value;\n+                        var arrays = BuildArrays(Schema, bodybb, rb);\n+                        return new RecordBatch(Schema, arrays, (int)rb.Length);\n+                    default:\n+                        // NOTE: Skip unsupported message type\n+                        Debug.WriteLine($\"Skipping unsupported message type '{message.HeaderType}'\");\n+                        break;\n+                }\n+            }\n+            finally\n+            {\n+                if (lengthBuffer != null)\n+                {\n+                    Buffers.Return(lengthBuffer);\n+                }\n+\n+                if (messageBuff != null)\n+                {\n+                    Buffers.Return(messageBuff);\n+                }\n+\n+                if (bodyBuff != null)\n+                {\n+                    Buffers.Return(bodyBuff);\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        protected virtual async Task<Schema> ReadSchemaAsync()\n+        {\n+            if (HasReadSchema)\n+            {\n+                return Schema;\n+            }\n+\n+            byte[] buff = null;\n+\n+            try\n+            {\n+                // Figure out length of schema\n+\n+                buff = Buffers.Rent(4);\n+                await BaseStream.ReadAsync(buff, 0, 4);\n+                var schemaMessageLength = BitConverter.ToInt32(buff, 0);\n+                Buffers.Return(buff);\n+\n+                // Allocate byte array for schema flat buffer\n+\n+                buff = Buffers.Rent(schemaMessageLength);\n+                var schemabb = new FlatBuffers.ByteBuffer(buff);\n+\n+                // Read in schema\n+\n+                await BaseStream.ReadAsync(buff, 0, schemaMessageLength);\n+                Schema = MessageSerializer.GetSchema(ReadMessage<Flatbuf.Schema>(schemabb));\n+\n+                return Schema;\n+            }\n+            finally\n+            {\n+                if (buff != null)\n+                {\n+                    Buffers.Return(buff);\n+                }\n+            }\n+        }\n+\n+        public void Dispose()\n+        {\n+            BaseStream.Dispose();\n+        }\n+\n+        #region Static Helper Functions\n+\n+        protected static IEnumerable<IArrowArray> BuildArrays(Schema schema,\n+            FlatBuffers.ByteBuffer messageBuffer,\n+            Flatbuf.RecordBatch recordBatchMessage)\n+        {\n+            var arrays = new List<ArrayData>();\n+            var bufferIndex = 0;\n+\n+            for (var n = 0; n < recordBatchMessage.NodesLength; n++)\n+            {\n+                var field = schema.GetFieldByIndex(n);\n+                var fieldNode = recordBatchMessage.Nodes(n).GetValueOrDefault();\n+\n+                if (field.DataType.IsFixedPrimitive())\n+                    arrays.Add(LoadPrimitiveField(field, fieldNode, recordBatchMessage, messageBuffer, ref bufferIndex));\n+                else\n+                    arrays.Add(LoadVariableField(field, fieldNode, recordBatchMessage, messageBuffer, ref bufferIndex));\n+            }\n+\n+            return arrays.Select(ArrowArrayFactory.BuildArray);\n+        }\n+\n+        protected static T ReadMessage<T>(FlatBuffers.ByteBuffer bb) where T : struct, FlatBuffers.IFlatbufferObject\n+        {\n+            var returnType = typeof(T);\n+            var msg = Flatbuf.Message.GetRootAsMessage(bb);\n+\n+            if (MatchEnum(msg.HeaderType, returnType))\n+            {\n+                return msg.Header<T>().Value;\n+            }\n+            else\n+            {\n+                throw new Exception($\"Requested type '{returnType.Name}' \" +\n+                                    $\"did not match type found at offset => '{msg.HeaderType}'\");\n+            }\n+        }\n+\n+        private static bool MatchEnum(Flatbuf.MessageHeader messageHeader, Type flatBuffType)\n+        {\n+            switch (messageHeader)\n+            {\n+                case Flatbuf.MessageHeader.RecordBatch:\n+                    return flatBuffType == typeof(Flatbuf.RecordBatch);\n+                case Flatbuf.MessageHeader.DictionaryBatch:\n+                    return flatBuffType == typeof(Flatbuf.DictionaryBatch);\n+                case Flatbuf.MessageHeader.Schema:\n+                    return flatBuffType == typeof(Flatbuf.Schema);\n+                case Flatbuf.MessageHeader.Tensor:\n+                    return flatBuffType == typeof(Flatbuf.Tensor);\n+                case Flatbuf.MessageHeader.NONE:\n+                    throw new ArgumentException(\"MessageHeader NONE has no matching flatbuf types\", nameof(messageHeader));\n+                default:\n+                    throw new ArgumentException($\"Unexpected MessageHeader value\", nameof(messageHeader));\n+            }\n+        }\n+\n+        private static ArrowBuffer BuildArrowBuffer(FlatBuffers.ByteBuffer bodyData, Flatbuf.Buffer buffer)\n+        {\n+            if (buffer.Length <= 0)\n+            {\n+                return null;\n+            }\n+\n+            var segment = bodyData.ToArraySegment((int)buffer.Offset, (int)buffer.Length);\n+            return ArrowBuffer.FromMemory(segment);\n+        }\n+\n+        private static ArrayData LoadPrimitiveField(Field field,\n+                                  Flatbuf.FieldNode fieldNode,\n+                                  Flatbuf.RecordBatch recordBatch,\n+                                  FlatBuffers.ByteBuffer bodyData,\n+                                  ref int bufferIndex)\n+        {\n+            var nullBitmapBuffer = recordBatch.Buffers(bufferIndex++).GetValueOrDefault();\n+            var valueBuffer = recordBatch.Buffers(bufferIndex++).GetValueOrDefault();\n+\n+            ArrowBuffer nullArrowBuffer = BuildArrowBuffer(bodyData, nullBitmapBuffer);\n+            ArrowBuffer valueArrowBuffer = BuildArrowBuffer(bodyData, valueBuffer);\n+            \n+            var fieldLength = (int)fieldNode.Length;\n+            var fieldNullCount = (int)fieldNode.NullCount;\n+\n+            if (fieldLength < 0)\n+            {\n+                throw new InvalidDataException(\"Field length must be >= 0\"); // TODO:Localize exception message\n+            }\n+\n+            if (fieldNullCount < 0)\n+            {\n+                throw new InvalidDataException(\"Null count length must be >= 0\"); // TODO:Localize exception message\n+            }\n+\n+            var arrowBuff = new[] { nullArrowBuffer, valueArrowBuffer };\n+\n+            return new ArrayData(field.DataType, fieldLength, fieldNullCount, 0, arrowBuff);\n+        }\n+\n+        private static ArrayData LoadVariableField(Field field,\n+                                  Flatbuf.FieldNode fieldNode,\n+                          Flatbuf.RecordBatch recordBatch,\n+                          FlatBuffers.ByteBuffer bodyData,\n+                          ref int bufferIndex)\n+        {\n+            var nullBitmapBuffer = recordBatch.Buffers(bufferIndex++).GetValueOrDefault();\n+            var offsetBuffer = recordBatch.Buffers(bufferIndex++).GetValueOrDefault();\n+            var valueBuffer = recordBatch.Buffers(bufferIndex++).GetValueOrDefault();\n+\n+            ArrowBuffer nullArrowBuffer = BuildArrowBuffer(bodyData, nullBitmapBuffer);\n+            ArrowBuffer offsetArrowBuffer = BuildArrowBuffer(bodyData, offsetBuffer);\n+            ArrowBuffer valueArrowBuffer = BuildArrowBuffer(bodyData, valueBuffer);\n+\n+            var fieldLength = (int)fieldNode.Length;\n+            var fieldNullCount = (int)fieldNode.NullCount;\n+\n+            if (fieldLength < 0)\n+            {\n+                throw new InvalidDataException(\"Field length must be >= 0\"); // TODO: Localize exception message\n+            }\n+\n+            if (fieldNullCount < 0)\n+            { \n+                throw new InvalidDataException(\"Null count length must be >= 0\"); //TODO: Localize exception message\n+            }\n+\n+            var arrowBuff = new[] { nullArrowBuffer, offsetArrowBuffer, valueArrowBuffer };\n+\n+            return new ArrayData(field.DataType, fieldLength, fieldNullCount, 0, arrowBuff);\n+        }\n+        #endregion\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs b/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs\nnew file mode 100644\nindex 0000000000..980a42dbf5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowStreamWriter.cs\n@@ -0,0 +1,365 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Buffers.Binary;\n+using System.Collections.Generic;\n+using System.IO;\n+using System.Threading;\n+using System.Threading.Tasks;\n+using FlatBuffers;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    public class ArrowStreamWriter : IDisposable\n+    {\n+        internal class ArrowRecordBatchFlatBufferBuilder :\n+            IArrowArrayVisitor<Int8Array>,\n+            IArrowArrayVisitor<Int16Array>,\n+            IArrowArrayVisitor<Int32Array>,\n+            IArrowArrayVisitor<Int64Array>,\n+            IArrowArrayVisitor<UInt8Array>,\n+            IArrowArrayVisitor<UInt16Array>,\n+            IArrowArrayVisitor<UInt32Array>,\n+            IArrowArrayVisitor<UInt64Array>,\n+            IArrowArrayVisitor<FloatArray>,\n+            IArrowArrayVisitor<DoubleArray>,\n+            IArrowArrayVisitor<BooleanArray>,\n+            IArrowArrayVisitor<TimestampArray>,\n+            IArrowArrayVisitor<Date32Array>,\n+            IArrowArrayVisitor<Date64Array>,\n+            IArrowArrayVisitor<ListArray>,\n+            IArrowArrayVisitor<StringArray>,\n+            IArrowArrayVisitor<BinaryArray>\n+        {\n+            public struct Buffer\n+            {\n+                public readonly ArrowBuffer DataBuffer;\n+                public readonly int Offset;\n+                public readonly int Length;\n+\n+                public Buffer(ArrowBuffer buffer, int offset, int length)\n+                {\n+                    DataBuffer = buffer;\n+                    Offset = offset;\n+                    Length = length;\n+                }\n+            }\n+\n+            private readonly List<Buffer> _buffers;\n+            private int _offset;\n+\n+            public IReadOnlyList<Buffer> Buffers => _buffers;\n+\n+            public int TotalLength => _offset;\n+\n+            public ArrowRecordBatchFlatBufferBuilder()\n+            {\n+                _buffers = new List<Buffer>();\n+                _offset = 0;\n+            }\n+\n+            public void Visit(Int8Array array) => CreateBuffers(array);\n+            public void Visit(Int16Array array) => CreateBuffers(array);\n+            public void Visit(Int32Array array) => CreateBuffers(array);\n+            public void Visit(Int64Array array) => CreateBuffers(array);\n+            public void Visit(UInt8Array array) => CreateBuffers(array);\n+            public void Visit(UInt16Array array) => CreateBuffers(array);\n+            public void Visit(UInt32Array array) => CreateBuffers(array);\n+            public void Visit(UInt64Array array) => CreateBuffers(array);\n+            public void Visit(FloatArray array) => CreateBuffers(array);\n+            public void Visit(DoubleArray array) => CreateBuffers(array);\n+            public void Visit(TimestampArray array) => CreateBuffers(array);\n+            public void Visit(BooleanArray array) => CreateBuffers(array);\n+            public void Visit(Date32Array array) => CreateBuffers(array);\n+            public void Visit(Date64Array array) => CreateBuffers(array);\n+\n+            public void Visit(ListArray array)\n+            {\n+                _buffers.Add(CreateBuffer(array.NullBitmapBuffer));\n+                _buffers.Add(CreateBuffer(array.ValueOffsetsBuffer));\n+\n+                array.Values.Accept(this);\n+            }\n+\n+            public void Visit(StringArray array) => Visit(array as BinaryArray);\n+\n+            public void Visit(BinaryArray array)\n+            {\n+                _buffers.Add(CreateBuffer(array.NullBitmapBuffer));\n+                _buffers.Add(CreateBuffer(array.ValueOffsetsBuffer));\n+                _buffers.Add(CreateBuffer(array.ValueBuffer));\n+            }\n+\n+            private void CreateBuffers<T>(PrimitiveArray<T> array)\n+                where T: struct\n+            {\n+                _buffers.Add(CreateBuffer(array.NullBitmapBuffer));\n+                _buffers.Add(CreateBuffer(array.ValueBuffer));\n+            }\n+\n+            private Buffer CreateBuffer(ArrowBuffer buffer)\n+            {\n+                if (buffer == null)\n+                {\n+                    return new Buffer(null, _offset, 0);\n+                }\n+\n+                var offset = _offset;\n+\n+                _offset += buffer.Capacity;\n+\n+                return new Buffer(buffer, offset, buffer.Capacity);\n+            }\n+\n+            public void Visit(IArrowArray array)\n+            {\n+                throw new NotImplementedException();\n+            }\n+        }\n+\n+        protected struct Block\n+        {\n+            public readonly int Offset;\n+            public readonly int Length;\n+            public readonly int MetadataLength;\n+\n+            public Block(int offset, int length, int metadataLength)\n+            {\n+                Offset = offset;\n+                Length = length;\n+                MetadataLength = metadataLength;\n+            }\n+        }\n+\n+        protected Stream BaseStream { get; }\n+\n+        protected ArrayPool<byte> Buffers { get; }\n+\n+        protected FlatBufferBuilder Builder { get; }\n+\n+        protected bool HasWrittenSchema { get; set; }\n+\n+        protected Schema Schema { get; }\n+\n+        protected const Flatbuf.MetadataVersion CurrentMetadataVersion = Flatbuf.MetadataVersion.V4;\n+\n+        private static readonly byte[] Padding = new byte[64];\n+\n+        private readonly ArrowTypeFlatbufferBuilder _fieldTypeBuilder;\n+\n+        public ArrowStreamWriter(Stream baseStream, Schema schema)\n+        {\n+            BaseStream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));\n+            Schema = schema ?? throw new ArgumentNullException(nameof(schema));\n+\n+            Buffers = ArrayPool<byte>.Create();\n+            Builder = new FlatBufferBuilder(1024);\n+            HasWrittenSchema = false;\n+\n+            _fieldTypeBuilder = new ArrowTypeFlatbufferBuilder(Builder);\n+        }\n+\n+        protected virtual async Task<Block> WriteRecordBatchInternalAsync(RecordBatch recordBatch,\n+            CancellationToken cancellationToken = default)\n+        {\n+            if (!HasWrittenSchema)\n+            {\n+                await WriteSchemaAsync(Schema, cancellationToken);\n+                HasWrittenSchema = true;\n+            }\n+\n+            var recordBatchBuilder = new ArrowRecordBatchFlatBufferBuilder();\n+\n+            Builder.Clear();\n+\n+            // Serialize field nodes\n+\n+            var fieldCount = Schema.Fields.Count;\n+            var fieldNodeOffsets = new Offset<Flatbuf.FieldNode>[fieldCount];\n+\n+            Flatbuf.RecordBatch.StartNodesVector(Builder, fieldCount);\n+\n+            for (var i = 0; i < fieldCount; i++)\n+            {\n+                var fieldArray = recordBatch.Column(i);\n+                fieldNodeOffsets[i] =\n+                    Flatbuf.FieldNode.CreateFieldNode(Builder, fieldArray.Length, fieldArray.NullCount);\n+            }\n+\n+            var fieldNodesVectorOffset = Builder.EndVector();\n+\n+            // Serialize buffers\n+\n+            for (var i = 0; i < fieldCount; i++)\n+            {\n+                var fieldArray = recordBatch.Column(i);\n+                fieldArray.Accept(recordBatchBuilder);\n+            }\n+\n+            var buffers = recordBatchBuilder.Buffers;\n+            var bufferOffsets = new Offset<Flatbuf.Buffer>[buffers.Count];\n+\n+            Flatbuf.RecordBatch.StartBuffersVector(Builder, buffers.Count);\n+\n+            for (var i = buffers.Count - 1; i >= 0; i--)\n+            {\n+                bufferOffsets[i] = Flatbuf.Buffer.CreateBuffer(Builder,\n+                    buffers[i].Offset, buffers[i].Length);\n+            }\n+\n+            var buffersVectorOffset = Builder.EndVector();\n+\n+            // Serialize record batch\n+\n+            var recordBatchOffset = Flatbuf.RecordBatch.CreateRecordBatch(Builder, recordBatch.Length,\n+                fieldNodesVectorOffset,\n+                buffersVectorOffset);\n+\n+            var metadataOffset = BaseStream.Position;\n+\n+            await WriteMessageAsync(Flatbuf.MessageHeader.RecordBatch,\n+                recordBatchOffset, recordBatchBuilder.TotalLength,\n+                cancellationToken);\n+\n+            var metadataLength = BaseStream.Position - metadataOffset;\n+\n+            // Write buffer data\n+\n+            var lengthOffset = BaseStream.Position;\n+\n+            for (var i = 0; i < buffers.Count; i++)\n+            {\n+                if (buffers[i].DataBuffer == null)\n+                    continue;\n+\n+                await buffers[i].DataBuffer.CopyToAsync(BaseStream, cancellationToken);\n+            }\n+\n+            // Write padding so the record batch message body length is a multiple of 8 bytes\n+\n+            var bodyLength = Convert.ToInt32(BaseStream.Position - lengthOffset);\n+            var bodyPaddingLength = CalculatePadding(bodyLength);\n+\n+            await WritePaddingAsync(bodyPaddingLength);\n+\n+            return new Block(\n+                offset: Convert.ToInt32(metadataOffset), \n+                length: bodyLength + bodyPaddingLength, \n+                metadataLength: Convert.ToInt32(metadataLength));\n+        }\n+\n+        public virtual Task WriteRecordBatchAsync(RecordBatch recordBatch, CancellationToken cancellationToken = default)\n+        {\n+            return WriteRecordBatchInternalAsync(recordBatch, cancellationToken);\n+        }\n+\n+        protected Offset<Flatbuf.Schema> SerializeSchema(Schema schema)\n+        {\n+            // TODO: Serialize schema metadata\n+\n+            // Build fields\n+\n+            var fieldOffsets = new Offset<Flatbuf.Field>[schema.Fields.Count];\n+            var fieldChildren = new List<Offset<Flatbuf.Field>>();\n+\n+            for (var i = 0; i < fieldOffsets.Length; i++)\n+            {\n+                var field = schema.GetFieldByIndex(i);\n+                var fieldNameOffset = Builder.CreateString(field.Name);\n+                var fieldType = _fieldTypeBuilder.BuildFieldType(field);\n+\n+                var fieldChildrenOffsets = Builder.CreateVectorOfTables(fieldChildren.ToArray());\n+\n+                fieldOffsets[i] = Flatbuf.Field.CreateField(Builder,\n+                    fieldNameOffset, field.IsNullable, fieldType.Type, fieldType.Offset,\n+                    default, fieldChildrenOffsets, default);\n+            }\n+\n+            var fieldsVectorOffset = Flatbuf.Schema.CreateFieldsVector(Builder, fieldOffsets);\n+\n+            // Build schema\n+\n+            var endianness = BitConverter.IsLittleEndian ? Flatbuf.Endianness.Little : Flatbuf.Endianness.Big;\n+\n+            return Flatbuf.Schema.CreateSchema(\n+                Builder, endianness, fieldsVectorOffset);\n+        }\n+\n+\n+        protected async Task<Offset<Flatbuf.Schema>> WriteSchemaAsync(Schema schema, CancellationToken cancellationToken)\n+        {\n+            Builder.Clear();\n+\n+            // Build schema\n+\n+            var schemaOffset = SerializeSchema(schema);\n+\n+            // Build message\n+\n+            await WriteMessageAsync(Flatbuf.MessageHeader.Schema, schemaOffset, 0, cancellationToken);\n+\n+            return schemaOffset;\n+        }\n+\n+        protected async Task WriteMessageAsync<T>(\n+            Flatbuf.MessageHeader headerType, Offset<T> headerOffset, int bodyLength,\n+            CancellationToken cancellationToken)\n+            where T: struct\n+        {\n+            var messageOffset = Flatbuf.Message.CreateMessage(\n+                Builder, CurrentMetadataVersion, headerType, headerOffset.Value, \n+                bodyLength);\n+\n+            Builder.Finish(messageOffset.Value);\n+\n+            var messageData = Builder.DataBuffer.ToArraySegment(Builder.DataBuffer.Position, Builder.Offset);\n+            var messagePaddingLength = CalculatePadding(messageData.Count);\n+\n+            await Buffers.RentReturnAsync(4, (buffer) =>\n+            {\n+                var metadataSize = messageData.Count + messagePaddingLength;\n+                BinaryPrimitives.WriteInt32LittleEndian(buffer, metadataSize);\n+                return BaseStream.WriteAsync(buffer, 0, 4, cancellationToken);\n+            });\n+\n+            await BaseStream.WriteAsync(messageData.Array, messageData.Offset, messageData.Count, cancellationToken);\n+            await WritePaddingAsync(messagePaddingLength);\n+        }\n+\n+        protected async Task WriteFlatBufferAsync(CancellationToken cancellationToken = default)\n+        {\n+            var segment = Builder.DataBuffer.ToArraySegment(Builder.DataBuffer.Position, Builder.Offset);\n+\n+            await BaseStream.WriteAsync(segment.Array, segment.Offset, segment.Count, cancellationToken);\n+        }\n+\n+        protected int CalculatePadding(int offset, int alignment = 8) =>\n+            BitUtility.RoundUpToMultiplePowerOfTwo(offset, alignment) - offset;\n+\n+        protected Task WritePaddingAsync(int length)\n+        {\n+            if (length <= 0) return Task.CompletedTask;\n+\n+            return BaseStream.WriteAsync(Padding, 0, Math.Min(Padding.Length, length));\n+        }\n+\n+        public virtual void Dispose()\n+        {\n+            BaseStream.Dispose();\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs b/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs\nnew file mode 100644\nindex 0000000000..fe4598a35a\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/ArrowTypeFlatbufferBuilder.cs\n@@ -0,0 +1,222 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using Apache.Arrow.Flatbuf;\n+using Apache.Arrow.Types;\n+using FlatBuffers;\n+using DateUnit = Apache.Arrow.Flatbuf.DateUnit;\n+using TimeUnit = Apache.Arrow.Types.TimeUnit;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    internal class ArrowTypeFlatbufferBuilder\n+    {\n+        public struct FieldType\n+        {\n+            public readonly Flatbuf.Type Type;\n+            public readonly int Offset;\n+\n+            public static FieldType Build<T>(Flatbuf.Type type, Offset<T> offset)\n+                where T: struct =>\n+                new FieldType(type, offset.Value);\n+\n+            public FieldType(Flatbuf.Type type, int offset)\n+            {\n+                Type = type;\n+                Offset = offset;\n+            }\n+        }\n+\n+        class TypeVisitor : \n+            IArrowTypeVisitor<Int8Type>,\n+            IArrowTypeVisitor<Int16Type>,\n+            IArrowTypeVisitor<Int32Type>,\n+            IArrowTypeVisitor<Int64Type>,\n+            IArrowTypeVisitor<UInt8Type>,\n+            IArrowTypeVisitor<UInt16Type>,\n+            IArrowTypeVisitor<UInt32Type>,\n+            IArrowTypeVisitor<UInt64Type>,\n+            IArrowTypeVisitor<FloatType>,\n+            IArrowTypeVisitor<DoubleType>,\n+            IArrowTypeVisitor<StringType>,\n+            IArrowTypeVisitor<Date32Type>,\n+            IArrowTypeVisitor<Date64Type>,\n+            IArrowTypeVisitor<Time32Type>,\n+            IArrowTypeVisitor<Time64Type>,\n+            IArrowTypeVisitor<BinaryType>,\n+            IArrowTypeVisitor<TimestampType>,\n+            IArrowTypeVisitor<ListType>,\n+            IArrowTypeVisitor<UnionType>\n+        {\n+            private FlatBufferBuilder Builder { get; }\n+\n+            public FieldType Result { get; private set; }\n+\n+            public TypeVisitor(FlatBufferBuilder builder)\n+            {\n+                Builder = builder;\n+            }\n+\n+            public void Visit(Int8Type type) => CreateIntType(type);\n+            public void Visit(Int16Type type) => CreateIntType(type);\n+            public void Visit(Int32Type type) => CreateIntType(type);\n+            public void Visit(Int64Type type) => CreateIntType(type);\n+            public void Visit(UInt8Type type) => CreateIntType(type);\n+            public void Visit(UInt16Type type) => CreateIntType(type);\n+            public void Visit(UInt32Type type) => CreateIntType(type);\n+            public void Visit(UInt64Type type) => CreateIntType(type);\n+\n+            public void Visit(BooleanType type)\n+            {\n+                Flatbuf.Bool.StartBool(Builder);\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Bool,\n+                    Flatbuf.Bool.EndBool(Builder));\n+            }\n+\n+            public void Visit(BinaryType type)\n+            {\n+                Flatbuf.Binary.StartBinary(Builder);\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Binary,\n+                    Flatbuf.Binary.EndBinary(Builder));\n+            }\n+\n+            public void Visit(ListType type)\n+            {\n+                throw new NotImplementedException();\n+            }\n+\n+            public void Visit(UnionType type)\n+            {\n+                throw new NotImplementedException();\n+            }\n+\n+            public void Visit(StringType type)\n+            {\n+                Flatbuf.Utf8.StartUtf8(Builder);\n+                var offset = Flatbuf.Utf8.EndUtf8(Builder);\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Utf8, offset);\n+            }\n+\n+            public void Visit(TimestampType type)\n+            {  \n+                StringOffset timezoneStringOffset = default;\n+\n+                if (string.IsNullOrWhiteSpace(type.Timezone))\n+                    timezoneStringOffset = Builder.CreateString(type.Timezone);\n+\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Timestamp, \n+                    Flatbuf.Timestamp.CreateTimestamp(Builder, ToFlatBuffer(type.Unit), timezoneStringOffset));\n+            }\n+\n+            public void Visit(Date32Type type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Date,\n+                    Flatbuf.Date.CreateDate(Builder, DateUnit.DAY));\n+            }\n+\n+            public void Visit(Date64Type type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Date,\n+                    Flatbuf.Date.CreateDate(Builder));\n+            }\n+\n+            public void Visit(Time32Type type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Time,\n+                    Flatbuf.Time.CreateTime(Builder, ToFlatBuffer(type.Unit)));\n+            }\n+\n+            public void Visit(FloatType type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.FloatingPoint,\n+                    Flatbuf.FloatingPoint.CreateFloatingPoint(Builder, Precision.SINGLE));\n+            }\n+\n+            public void Visit(DoubleType type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.FloatingPoint,\n+                    Flatbuf.FloatingPoint.CreateFloatingPoint(Builder, Precision.DOUBLE));\n+            }\n+\n+            public void Visit(Time64Type type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Time,\n+                    Flatbuf.Time.CreateTime(Builder, ToFlatBuffer(type.Unit), 64));\n+            }\n+\n+            private void CreateIntType(NumberType type)\n+            {\n+                Result = FieldType.Build(\n+                    Flatbuf.Type.Int,\n+                    Flatbuf.Int.CreateInt(Builder, type.BitWidth, type.IsSigned));\n+            }\n+\n+            public void Visit(IArrowType type)\n+            {\n+                throw new NotImplementedException();\n+            }\n+        }\n+\n+        private readonly TypeVisitor _visitor;\n+\n+        public ArrowTypeFlatbufferBuilder(FlatBufferBuilder builder)\n+        {\n+            _visitor = new TypeVisitor(builder);\n+        }\n+\n+        public FieldType BuildFieldType(Field field)\n+        {\n+            field.DataType.Accept(_visitor);\n+            return _visitor.Result;\n+        }\n+\n+        private static Flatbuf.TimeUnit ToFlatBuffer(TimeUnit unit)\n+        {\n+            Flatbuf.TimeUnit result;\n+\n+            switch (unit)\n+            {\n+                case TimeUnit.Microsecond:\n+                    result = Flatbuf.TimeUnit.MICROSECOND;\n+                    break;\n+                case TimeUnit.Millisecond:\n+                    result = Flatbuf.TimeUnit.MILLISECOND;\n+                    break;\n+                case TimeUnit.Nanosecond:\n+                    result = Flatbuf.TimeUnit.NANOSECOND;\n+                    break;\n+                case TimeUnit.Second:\n+                    result = Flatbuf.TimeUnit.SECOND;\n+                    break;\n+                default:\n+                    throw new ArgumentException(nameof(unit),\n+                        $\"unsupported timestamp unit <{unit}>\");\n+            }\n+\n+            return result;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/Block.cs b/csharp/src/Apache.Arrow/Ipc/Block.cs\nnew file mode 100644\nindex 0000000000..f12e7e5fea\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/Block.cs\n@@ -0,0 +1,40 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    internal class Block\n+    {\n+        public long Offset { get; }\n+        public int MetaDataLength { get; }\n+        public long BodyLength { get; }\n+\n+        public Block(long offset, int metadataLength, long bodyLength)\n+        {\n+            Offset = offset;\n+            MetaDataLength = metadataLength;\n+            BodyLength = bodyLength;\n+        }\n+\n+        public Block(Flatbuf.Block block)\n+        {\n+            Offset = Convert.ToInt32(block.Offset);\n+            MetaDataLength = Convert.ToInt32(block.MetaDataLength);\n+            BodyLength = Convert.ToInt32(block.BodyLength);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/IArrowReader.cs b/csharp/src/Apache.Arrow/Ipc/IArrowReader.cs\nnew file mode 100644\nindex 0000000000..1230613029\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/IArrowReader.cs\n@@ -0,0 +1,26 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Threading;\n+using System.Threading.Tasks;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    public interface IArrowReader\n+    {\n+        Task<RecordBatch> ReadNextRecordBatchAsync(\n+            CancellationToken cancellationToken = default);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs b/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs\nnew file mode 100644\nindex 0000000000..7478e00e13\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Ipc/MessageSerializer.cs\n@@ -0,0 +1,132 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.IO;\n+\n+namespace Apache.Arrow.Ipc\n+{\n+    internal class MessageSerializer\n+    {\n+\n+        public static Types.NumberType GetNumberType(int bitWidth, bool signed)\n+        {\n+            if (signed)\n+            {\n+                if (bitWidth == 8)\n+                    return Types.Int8Type.Default;\n+                if (bitWidth == 16)\n+                    return Types.Int16Type.Default;\n+                if (bitWidth == 32)\n+                    return Types.Int32Type.Default;\n+                if (bitWidth == 64)\n+                    return Types.Int64Type.Default;\n+            }\n+            else\n+            {\n+                if (bitWidth == 8)\n+                    return Types.UInt8Type.Default;\n+                if (bitWidth == 16)\n+                    return Types.UInt16Type.Default;\n+                if (bitWidth == 32)\n+                    return Types.UInt32Type.Default;\n+                if (bitWidth == 64)\n+                    return Types.UInt64Type.Default;\n+            }\n+            throw new Exception($\"Unexpected bit width of {bitWidth} for \" +\n+                                $\"{(signed ? \"signed \" : \"unsigned\")} integer.\");\n+        }\n+\n+        internal static Schema GetSchema(Flatbuf.Schema schema)\n+        {\n+            var schemaBuilder = new Schema.Builder();\n+\n+            for (var i = 0; i < schema.FieldsLength; i++)\n+            {\n+                var field = schema.Fields(i).GetValueOrDefault();\n+\n+                schemaBuilder.Field(\n+                    new Field(field.Name, GetFieldArrowType(field), field.Nullable));\n+            }\n+\n+            return schemaBuilder.Build();\n+        }\n+\n+\n+        private static Types.IArrowType GetFieldArrowType(Flatbuf.Field field)\n+        {\n+            switch (field.TypeType)\n+            {\n+                case Flatbuf.Type.Int:\n+                    var intMetaData = field.Type<Flatbuf.Int>().Value;\n+                    return MessageSerializer.GetNumberType(intMetaData.BitWidth, intMetaData.IsSigned);\n+                case Flatbuf.Type.FloatingPoint:\n+                    var floatingPointTypeMetadta = field.Type<Flatbuf.FloatingPoint>().Value;\n+                    switch (floatingPointTypeMetadta.Precision)\n+                    {\n+                        case Flatbuf.Precision.SINGLE:\n+                            return Types.FloatType.Default;\n+                        case Flatbuf.Precision.DOUBLE:\n+                            return Types.DoubleType.Default;\n+                        case Flatbuf.Precision.HALF:\n+                            return Types.HalfFloatType.Default;\n+                        default:\n+                            throw new InvalidDataException(\"Unsupported floating point precision\");\n+                    }\n+                case Flatbuf.Type.Bool:\n+                    return new Types.BooleanType();\n+                case Flatbuf.Type.Decimal:\n+                    var decMeta = field.Type<Flatbuf.Decimal>().Value;\n+                    return new Types.DecimalType(decMeta.Precision, decMeta.Scale);\n+                case Flatbuf.Type.Date:\n+                    var dateMeta = field.Type<Flatbuf.Date>().Value;\n+                    switch (dateMeta.Unit)\n+                    {\n+                        case Flatbuf.DateUnit.DAY:\n+                            return Types.Date32Type.Default;\n+                        case Flatbuf.DateUnit.MILLISECOND:\n+                            return Types.Date64Type.Default;\n+                        default:\n+                            throw new InvalidDataException(\"Unsupported date unit\");\n+                    }\n+                case Flatbuf.Type.Time:\n+                    var timeMeta = field.Type<Flatbuf.Time>().Value;\n+                    switch (timeMeta.BitWidth)\n+                    {\n+                        case 32:\n+                            return new Types.Time32Type(timeMeta.Unit.ToArrow());\n+                        case 64:\n+                            return new Types.Time64Type(timeMeta.Unit.ToArrow());\n+                        default:\n+                            throw new InvalidDataException(\"Unsupported time bit width\");\n+                    }\n+                case Flatbuf.Type.Timestamp:\n+                    var timestampTypeMetadata = field.Type<Flatbuf.Timestamp>().Value;\n+                    var unit = timestampTypeMetadata.Unit.ToArrow();\n+                    var timezone = timestampTypeMetadata.Timezone;\n+                    return new Types.TimestampType(unit, timezone);\n+                case Flatbuf.Type.Interval:\n+                    var intervalMetadata = field.Type<Flatbuf.Interval>().Value;\n+                    return new Types.IntervalType(intervalMetadata.Unit.ToArrow());\n+                case Flatbuf.Type.Utf8:\n+                    return new Types.StringType();\n+                case Flatbuf.Type.Binary:\n+                    return Types.BinaryType.Default;\n+                default:\n+                    throw new InvalidDataException($\"Arrow primitive '{field.TypeType}' is unsupported.\");\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Memory/DefaultMemoryPool.cs b/csharp/src/Apache.Arrow/Memory/DefaultMemoryPool.cs\nnew file mode 100644\nindex 0000000000..bf65979184\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Memory/DefaultMemoryPool.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Runtime.InteropServices;\n+\n+namespace Apache.Arrow.Memory\n+{\n+    public class DefaultMemoryPool\n+    {\n+        public const int DefaultAlignment = 64;\n+        public const int DefaultPadding = 8;\n+\n+        public static readonly Lazy<MemoryPool> Instance = new Lazy<MemoryPool>(BuildDefault, true);\n+\n+        private static MemoryPool BuildDefault()\n+        {\n+            // TODO: Replace the default memory pool instance with a platform-specific implementation\n+            // of memory pool with fallback to this implementation?\n+\n+            return new NativeMemoryPool(DefaultPadding, DefaultAlignment);\n+        }\n+\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Memory/MemoryPool.cs b/csharp/src/Apache.Arrow/Memory/MemoryPool.cs\nnew file mode 100644\nindex 0000000000..1e2c173975\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Memory/MemoryPool.cs\n@@ -0,0 +1,89 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Threading;\n+\n+namespace Apache.Arrow.Memory\n+{\n+\n+    public abstract class MemoryPool\n+    {\n+        public class Stats\n+        {\n+            private long _bytesAllocated;\n+            private long _allocations;\n+\n+            public long Allocations => Interlocked.Read(ref _allocations);\n+            public long BytesAllocated => Interlocked.Read(ref _bytesAllocated);\n+\n+            internal void Allocate(int n)\n+            {\n+                Interlocked.Increment(ref _allocations);\n+                Interlocked.Add(ref _bytesAllocated, n);\n+            }\n+        }\n+\n+        public Stats Statistics { get; }\n+\n+        protected MemoryPool()\n+        {\n+            Statistics = new Stats();\n+        }\n+\n+        public Memory<byte> Allocate(int length)\n+        {\n+            if (length < 0)\n+            {\n+                throw new ArgumentOutOfRangeException(nameof(length));\n+            }\n+\n+            var bytesAllocated = 0;\n+            var memory = AllocateInternal(length, out bytesAllocated);\n+\n+            Statistics.Allocate(length);\n+\n+            // Ensure all allocated memory is zeroed.\n+\n+            ZeroMemory(memory);\n+            \n+            return memory;\n+        }\n+\n+        public Memory<byte> Reallocate(Memory<byte> memory, int length)\n+        {\n+            if (length < 0)\n+            {\n+                throw new ArgumentOutOfRangeException(nameof(length));\n+            }\n+\n+            var bytesAllocated = 0;\n+            var buffer = ReallocateInternal(memory, length, out bytesAllocated);\n+\n+            Statistics.Allocate(bytesAllocated);\n+\n+            return buffer;\n+\n+        }\n+\n+        private static void ZeroMemory(Memory<byte> memory)\n+        {\n+            memory.Span.Fill(0);\n+        }\n+\n+        protected abstract Memory<byte> AllocateInternal(int length, out int bytesAllocated);\n+        protected abstract Memory<byte> ReallocateInternal(Memory<byte> memory, int length, out int bytesAllocated);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Memory/NativeMemory.cs b/csharp/src/Apache.Arrow/Memory/NativeMemory.cs\nnew file mode 100644\nindex 0000000000..c5e29aa2a2\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Memory/NativeMemory.cs\n@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Buffers;\n+using System.Diagnostics;\n+using System.Runtime.CompilerServices;\n+using System.Runtime.InteropServices;\n+using System.Threading;\n+\n+namespace Apache.Arrow.Memory\n+{\n+    public class NativeMemoryManager: MemoryManager<byte>\n+    {\n+        private IntPtr _ptr;\n+        private int _offset;\n+        private int _length;\n+\n+        public NativeMemoryManager(IntPtr ptr, int offset, int length)\n+        {\n+            _ptr = ptr;\n+            _offset = offset;\n+            _length = length;\n+        }\n+\n+        ~NativeMemoryManager()\n+        {\n+            Dispose(false);\n+        }\n+\n+        public unsafe override Span<byte> GetSpan()\n+        {\n+            var ptr = CalculatePointer(0);\n+            return new Span<byte>(ptr, _length);\n+        }\n+\n+        public unsafe override MemoryHandle Pin(int elementIndex = 0)\n+        {\n+            // NOTE: Unmanaged memory doesn't require GC pinning because by definition it's not\n+            // managed by the garbage collector.\n+\n+            var ptr = CalculatePointer(elementIndex);\n+            return new MemoryHandle(ptr, default, this);\n+        }\n+\n+        public override void Unpin()\n+        {\n+            // SEE: Pin implementation\n+            return;\n+        }\n+\n+        protected override void Dispose(bool disposing)\n+        {\n+            // Only free once.\n+\n+            lock (this)\n+            {\n+                if (_ptr != IntPtr.Zero)\n+                {\n+                    Marshal.FreeHGlobal(_ptr);\n+                    Interlocked.Exchange(ref _ptr, IntPtr.Zero);\n+                    GC.RemoveMemoryPressure(_length);\n+                }\n+            }\n+        }\n+\n+        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n+        private unsafe void* CalculatePointer(int index) => \n+            (_ptr + _offset + index).ToPointer();\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Memory/NativeMemoryPool.cs b/csharp/src/Apache.Arrow/Memory/NativeMemoryPool.cs\nnew file mode 100644\nindex 0000000000..9413951c39\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Memory/NativeMemoryPool.cs\n@@ -0,0 +1,66 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Runtime.InteropServices;\n+\n+namespace Apache.Arrow.Memory\n+{\n+    public class NativeMemoryPool : MemoryPool\n+    {\n+        private readonly int _padding;\n+        private readonly int _alignment;\n+\n+        public NativeMemoryPool(int padding, int alignment)\n+        {\n+            if (padding < 0) throw new ArgumentOutOfRangeException(nameof(padding));\n+            if (alignment < 0) throw new ArgumentOutOfRangeException(nameof(alignment));\n+            \n+            // TODO: Ensure alignment is a power of two.\n+\n+            _padding = padding;\n+            _alignment = alignment;\n+        }\n+\n+        protected override Memory<byte> AllocateInternal(int length, out int bytesAllocated)\n+        {\n+            // TODO: Ensure memory is released if exception occurs.\n+\n+            // TODO: Optimize storage overhead; native memory manager stores a pointer\n+            // to allocated memory, offset, and the allocation size. \n+\n+            // TODO: Should the allocation be moved to NativeMemory?\n+            \n+            var size = BitUtility.RoundUpToMultiplePowerOfTwo(length, _padding);\n+            var ptr =  Marshal.AllocHGlobal(size + _alignment);\n+            var offset = (int)(_alignment - (ptr.ToInt64() & (_alignment - 1)));\n+            \n+            var manager = new NativeMemoryManager(ptr, offset, size);\n+\n+            bytesAllocated = (size + _alignment);\n+\n+            GC.AddMemoryPressure(bytesAllocated);\n+\n+            return manager.Memory;\n+        }\n+\n+        protected override Memory<byte> ReallocateInternal(Memory<byte> memory, int length, out int bytesAllocated)\n+        {\n+            var buffer = AllocateInternal(length, out bytesAllocated);\n+            memory.CopyTo(buffer);\n+            return buffer;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Properties/Resources.Designer.cs b/csharp/src/Apache.Arrow/Properties/Resources.Designer.cs\nnew file mode 100644\nindex 0000000000..b92b34e66a\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Properties/Resources.Designer.cs\n@@ -0,0 +1,73 @@\n+\ufeff//------------------------------------------------------------------------------\n+// <auto-generated>\n+//     This code was generated by a tool.\n+//     Runtime Version:4.0.30319.42000\n+//\n+//     Changes to this file may cause incorrect behavior and will be lost if\n+//     the code is regenerated.\n+// </auto-generated>\n+//------------------------------------------------------------------------------\n+\n+namespace Apache.Arrow.Properties {\n+    using System;\n+    using System.Reflection;\n+    \n+    \n+    /// <summary>\n+    ///   A strongly-typed resource class, for looking up localized strings, etc.\n+    /// </summary>\n+    // This class was auto-generated by the StronglyTypedResourceBuilder\n+    // class via a tool like ResGen or Visual Studio.\n+    // To add or remove a member, edit your .ResX file then rerun ResGen\n+    // with the /str option, or rebuild your VS project.\n+    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Resources.Tools.StronglyTypedResourceBuilder\", \"15.0.0.0\")]\n+    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]\n+    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]\n+    internal class Resources {\n+        \n+        private static global::System.Resources.ResourceManager resourceMan;\n+        \n+        private static global::System.Globalization.CultureInfo resourceCulture;\n+        \n+        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute(\"Microsoft.Performance\", \"CA1811:AvoidUncalledPrivateCode\")]\n+        internal Resources() {\n+        }\n+        \n+        /// <summary>\n+        ///   Returns the cached ResourceManager instance used by this class.\n+        /// </summary>\n+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n+        internal static global::System.Resources.ResourceManager ResourceManager {\n+            get {\n+                if (object.ReferenceEquals(resourceMan, null)) {\n+                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager(\"Apache.Arrow.Properties.Resources\", typeof(Resources).GetTypeInfo().Assembly);\n+                    resourceMan = temp;\n+                }\n+                return resourceMan;\n+            }\n+        }\n+        \n+        /// <summary>\n+        ///   Overrides the current thread's CurrentUICulture property for all\n+        ///   resource lookups using this strongly typed resource class.\n+        /// </summary>\n+        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]\n+        internal static global::System.Globalization.CultureInfo Culture {\n+            get {\n+                return resourceCulture;\n+            }\n+            set {\n+                resourceCulture = value;\n+            }\n+        }\n+        \n+        /// <summary>\n+        ///   Looks up a localized string similar to Array has invalid data type..\n+        /// </summary>\n+        internal static string ExceptionArrayDataInvalidType {\n+            get {\n+                return ResourceManager.GetString(\"ExceptionArrayDataInvalidType\", resourceCulture);\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Properties/Resources.resx b/csharp/src/Apache.Arrow/Properties/Resources.resx\nnew file mode 100644\nindex 0000000000..271675a635\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Properties/Resources.resx\n@@ -0,0 +1,123 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<root>\n+  <!-- \n+    Microsoft ResX Schema \n+    \n+    Version 2.0\n+    \n+    The primary goals of this format is to allow a simple XML format \n+    that is mostly human readable. The generation and parsing of the \n+    various data types are done through the TypeConverter classes \n+    associated with the data types.\n+    \n+    Example:\n+    \n+    ... ado.net/XML headers & schema ...\n+    <resheader name=\"resmimetype\">text/microsoft-resx</resheader>\n+    <resheader name=\"version\">2.0</resheader>\n+    <resheader name=\"reader\">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>\n+    <resheader name=\"writer\">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>\n+    <data name=\"Name1\"><value>this is my long string</value><comment>this is a comment</comment></data>\n+    <data name=\"Color1\" type=\"System.Drawing.Color, System.Drawing\">Blue</data>\n+    <data name=\"Bitmap1\" mimetype=\"application/x-microsoft.net.object.binary.base64\">\n+        <value>[base64 mime encoded serialized .NET Framework object]</value>\n+    </data>\n+    <data name=\"Icon1\" type=\"System.Drawing.Icon, System.Drawing\" mimetype=\"application/x-microsoft.net.object.bytearray.base64\">\n+        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>\n+        <comment>This is a comment</comment>\n+    </data>\n+                \n+    There are any number of \"resheader\" rows that contain simple \n+    name/value pairs.\n+    \n+    Each data row contains a name, and value. The row also contains a \n+    type or mimetype. Type corresponds to a .NET class that support \n+    text/value conversion through the TypeConverter architecture. \n+    Classes that don't support this are serialized and stored with the \n+    mimetype set.\n+    \n+    The mimetype is used for serialized objects, and tells the \n+    ResXResourceReader how to depersist the object. This is currently not \n+    extensible. For a given mimetype the value must be set accordingly:\n+    \n+    Note - application/x-microsoft.net.object.binary.base64 is the format \n+    that the ResXResourceWriter will generate, however the reader can \n+    read any of the formats listed below.\n+    \n+    mimetype: application/x-microsoft.net.object.binary.base64\n+    value   : The object must be serialized with \n+            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter\n+            : and then encoded with base64 encoding.\n+    \n+    mimetype: application/x-microsoft.net.object.soap.base64\n+    value   : The object must be serialized with \n+            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter\n+            : and then encoded with base64 encoding.\n+\n+    mimetype: application/x-microsoft.net.object.bytearray.base64\n+    value   : The object must be serialized into a byte array \n+            : using a System.ComponentModel.TypeConverter\n+            : and then encoded with base64 encoding.\n+    -->\n+  <xsd:schema id=\"root\" xmlns=\"\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:msdata=\"urn:schemas-microsoft-com:xml-msdata\">\n+    <xsd:import namespace=\"http://www.w3.org/XML/1998/namespace\" />\n+    <xsd:element name=\"root\" msdata:IsDataSet=\"true\">\n+      <xsd:complexType>\n+        <xsd:choice maxOccurs=\"unbounded\">\n+          <xsd:element name=\"metadata\">\n+            <xsd:complexType>\n+              <xsd:sequence>\n+                <xsd:element name=\"value\" type=\"xsd:string\" minOccurs=\"0\" />\n+              </xsd:sequence>\n+              <xsd:attribute name=\"name\" use=\"required\" type=\"xsd:string\" />\n+              <xsd:attribute name=\"type\" type=\"xsd:string\" />\n+              <xsd:attribute name=\"mimetype\" type=\"xsd:string\" />\n+              <xsd:attribute ref=\"xml:space\" />\n+            </xsd:complexType>\n+          </xsd:element>\n+          <xsd:element name=\"assembly\">\n+            <xsd:complexType>\n+              <xsd:attribute name=\"alias\" type=\"xsd:string\" />\n+              <xsd:attribute name=\"name\" type=\"xsd:string\" />\n+            </xsd:complexType>\n+          </xsd:element>\n+          <xsd:element name=\"data\">\n+            <xsd:complexType>\n+              <xsd:sequence>\n+                <xsd:element name=\"value\" type=\"xsd:string\" minOccurs=\"0\" msdata:Ordinal=\"1\" />\n+                <xsd:element name=\"comment\" type=\"xsd:string\" minOccurs=\"0\" msdata:Ordinal=\"2\" />\n+              </xsd:sequence>\n+              <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\" msdata:Ordinal=\"1\" />\n+              <xsd:attribute name=\"type\" type=\"xsd:string\" msdata:Ordinal=\"3\" />\n+              <xsd:attribute name=\"mimetype\" type=\"xsd:string\" msdata:Ordinal=\"4\" />\n+              <xsd:attribute ref=\"xml:space\" />\n+            </xsd:complexType>\n+          </xsd:element>\n+          <xsd:element name=\"resheader\">\n+            <xsd:complexType>\n+              <xsd:sequence>\n+                <xsd:element name=\"value\" type=\"xsd:string\" minOccurs=\"0\" msdata:Ordinal=\"1\" />\n+              </xsd:sequence>\n+              <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\" />\n+            </xsd:complexType>\n+          </xsd:element>\n+        </xsd:choice>\n+      </xsd:complexType>\n+    </xsd:element>\n+  </xsd:schema>\n+  <resheader name=\"resmimetype\">\n+    <value>text/microsoft-resx</value>\n+  </resheader>\n+  <resheader name=\"version\">\n+    <value>2.0</value>\n+  </resheader>\n+  <resheader name=\"reader\">\n+    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>\n+  </resheader>\n+  <resheader name=\"writer\">\n+    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>\n+  </resheader>\n+  <data name=\"ExceptionArrayDataInvalidType\" xml:space=\"preserve\">\n+    <value>Array has invalid data type.</value>\n+  </data>\n+</root>\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/RecordBatch.cs b/csharp/src/Apache.Arrow/RecordBatch.cs\nnew file mode 100644\nindex 0000000000..d5a21eb484\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/RecordBatch.cs\n@@ -0,0 +1,55 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow\n+{\n+    public class RecordBatch\n+    {\n+        public Schema Schema { get; }\n+        public int ColumnCount => _arrays.Count;\n+        public IEnumerable<IArrowArray> Arrays => _arrays;\n+        public int Length { get; }\n+\n+        private readonly IList<IArrowArray> _arrays;\n+\n+        public IArrowArray Column(int i)\n+        {\n+            return _arrays[i];\n+        }\n+\n+        public IArrowArray Column(string columnName)\n+        {\n+            var fieldIndex = Schema.GetFieldIndex(columnName);\n+            return _arrays[fieldIndex];\n+        }\n+\n+        public RecordBatch(Schema schema, IEnumerable<IArrowArray> data, int length)\n+        {\n+            if (length < 0)\n+            {\n+                throw new ArgumentOutOfRangeException(nameof(length));\n+            }\n+\n+            _arrays = data?.ToList() ?? throw new ArgumentNullException(nameof(data));\n+\n+            Schema = schema ?? throw new ArgumentNullException(nameof(schema));\n+            Length = length;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Schema.Builder.cs b/csharp/src/Apache.Arrow/Schema.Builder.cs\nnew file mode 100644\nindex 0000000000..58ee7f3d0d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Schema.Builder.cs\n@@ -0,0 +1,72 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class Schema\n+    {\n+\n+        public class Builder\n+        {\n+            private readonly List<Field> _fields;\n+            private readonly Dictionary<string, string> _metadata;\n+\n+            public Builder()\n+            {\n+                _fields = new List<Field>();\n+                _metadata = new Dictionary<string, string>();\n+            }\n+\n+            public Builder Field(Field field)\n+            {\n+                if (field == null) return this;\n+\n+                _fields.Add(field);\n+                return this;\n+            }\n+\n+            public Builder Field(Action<Field.Builder> fieldBuilderAction)\n+            {\n+                if (fieldBuilderAction == null) return this;\n+\n+                var fieldBuilder = new Field.Builder();\n+                fieldBuilderAction(fieldBuilder);\n+                var field = fieldBuilder.Build();\n+\n+                _fields.Add(field);\n+                return this;\n+            }\n+\n+            public Builder Metadata(string key, string value)\n+            {\n+                if (string.IsNullOrWhiteSpace(key))\n+                {\n+                    throw new ArgumentNullException(nameof(key));\n+                }\n+\n+                _metadata[key] = value;\n+                return this;\n+            }\n+\n+            public Schema Build()\n+            {\n+                return new Schema(_fields, _metadata);\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Schema.cs b/csharp/src/Apache.Arrow/Schema.cs\nnew file mode 100644\nindex 0000000000..4255e268e5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Schema.cs\n@@ -0,0 +1,67 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow\n+{\n+    public partial class Schema\n+    {\n+        public IReadOnlyDictionary<string, Field> Fields { get; }\n+        public IReadOnlyDictionary<string, string> Metadata { get; }\n+\n+        public bool HasMetadata =>\n+            Metadata != null && Metadata.Count > 0;\n+\n+        private readonly IList<Field> _fields;\n+\n+        public Schema(\n+            IEnumerable<Field> fields,\n+            IEnumerable<KeyValuePair<string, string>> metadata)\n+        {\n+            if (fields == null)\n+            {\n+                throw new ArgumentNullException(nameof(fields));\n+            }\n+\n+            _fields = fields.ToList();\n+\n+            Fields = fields.ToDictionary(\n+                field => field.Name, field => field,\n+                StringComparer.OrdinalIgnoreCase);\n+\n+            Metadata = metadata?.ToDictionary(kv => kv.Key, kv => kv.Value);\n+        }\n+\n+        public Field GetFieldByIndex(int i)\n+        {\n+            return _fields[i];\n+        }\n+\n+        public Field GetFieldByName(string name) =>\n+            Fields.TryGetValue(name, out var field) ? field : null;\n+\n+        public int GetFieldIndex(string name, StringComparer comparer = default)\n+        {\n+            if (comparer == null)\n+                comparer = StringComparer.CurrentCulture;\n+\n+            return _fields.IndexOf(\n+                _fields.Single(x => comparer.Compare(x.Name, name) == 0));\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/ArrowType.cs b/csharp/src/Apache.Arrow/Types/ArrowType.cs\nnew file mode 100644\nindex 0000000000..9e4b3608b9\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/ArrowType.cs\n@@ -0,0 +1,28 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public abstract class ArrowType: IArrowType\n+    {\n+        public abstract ArrowTypeId TypeId { get; }\n+\n+        public abstract string Name { get; }\n+\n+        public virtual bool IsFixedWidth => false;\n+\n+        public abstract void Accept(IArrowTypeVisitor visitor);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/BinaryType.cs b/csharp/src/Apache.Arrow/Types/BinaryType.cs\nnew file mode 100644\nindex 0000000000..8ae753360c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/BinaryType.cs\n@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class BinaryType: ArrowType\n+    {\n+        public static readonly BinaryType Default = new BinaryType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Binary;\n+        public override string Name => \"binary\";\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<BinaryType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/BooleanType.cs b/csharp/src/Apache.Arrow/Types/BooleanType.cs\nnew file mode 100644\nindex 0000000000..5a26c879f5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/BooleanType.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class BooleanType: NumberType\n+    {\n+        public static readonly BooleanType Default = new BooleanType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Boolean;\n+        public override string Name => \"bool\";\n+        public override int BitWidth => 1;\n+        public override bool IsSigned => false;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int8Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/Date32Type.cs b/csharp/src/Apache.Arrow/Types/Date32Type.cs\nnew file mode 100644\nindex 0000000000..19e6823602\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Date32Type.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Date32Type: DateType\n+    {\n+        public static readonly Date32Type Default = new Date32Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Date32;\n+        public override string Name => \"date32\";\n+        public override int BitWidth => 32;\n+        public override DateUnit Unit => DateUnit.Day;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Date32Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/Date64Type.cs b/csharp/src/Apache.Arrow/Types/Date64Type.cs\nnew file mode 100644\nindex 0000000000..d301ca4130\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Date64Type.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Date64Type: DateType\n+    {\n+        public static readonly Date64Type Default = new Date64Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Date64;\n+        public override string Name => \"date64\";\n+        public override int BitWidth => 64;\n+        public override DateUnit Unit => DateUnit.Milliseconds;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Date64Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/DateType.cs b/csharp/src/Apache.Arrow/Types/DateType.cs\nnew file mode 100644\nindex 0000000000..1fa2a32294\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/DateType.cs\n@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public enum DateUnit\n+    {\n+        Day = 0,\n+        Milliseconds = 1\n+    }\n+\n+    public abstract class DateType: FixedWidthType\n+    {\n+        public abstract DateUnit Unit { get; }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/DecimalType.cs b/csharp/src/Apache.Arrow/Types/DecimalType.cs\nnew file mode 100644\nindex 0000000000..adb9a06d1a\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/DecimalType.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class DecimalType: FixedSizeBinaryType\n+    {\n+        public override ArrowTypeId TypeId => ArrowTypeId.Decimal;\n+        public override string Name => \"decimal\";\n+\n+        public int Precision { get; }\n+        public int Scale { get; }\n+\n+        public DecimalType(int precision, int scale)\n+            : base(16)\n+        {\n+            Precision = precision;\n+            Scale = scale;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/DoubleType.cs b/csharp/src/Apache.Arrow/Types/DoubleType.cs\nnew file mode 100644\nindex 0000000000..9fb0969130\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/DoubleType.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class DoubleType: FloatingPointType\n+    {\n+        public static readonly DoubleType Default = new DoubleType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Double;\n+        public override string Name => \"double\";\n+        public override int BitWidth => 64;\n+        public override bool IsSigned => true;\n+        public override PrecisionKind Precision => PrecisionKind.Double;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<DoubleType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/FixedSizeBinaryType.cs b/csharp/src/Apache.Arrow/Types/FixedSizeBinaryType.cs\nnew file mode 100644\nindex 0000000000..6e16730314\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/FixedSizeBinaryType.cs\n@@ -0,0 +1,45 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class FixedSizeBinaryType: FixedWidthType\n+    {\n+        public override ArrowTypeId TypeId => ArrowTypeId.FixedSizedBinary;\n+        public override string Name => \"fixed_size_binary\";\n+        public int ByteWidth { get; }\n+        public override int BitWidth => ByteWidth * 8;\n+\n+        public FixedSizeBinaryType(int byteWidth)\n+        {\n+            if (byteWidth <= 0)\n+                throw new ArgumentOutOfRangeException(nameof(byteWidth));\n+\n+            ByteWidth = byteWidth;\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<FixedSizeBinaryType> v)\n+                v.Visit(this);\n+        }\n+\n+        \n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/FixedWidthType.cs b/csharp/src/Apache.Arrow/Types/FixedWidthType.cs\nnew file mode 100644\nindex 0000000000..72b46a2b11\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/FixedWidthType.cs\n@@ -0,0 +1,28 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public abstract class FixedWidthType: ArrowType\n+    {\n+        public override bool IsFixedWidth => true;\n+\n+        public abstract int BitWidth { get; }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/FloatType.cs b/csharp/src/Apache.Arrow/Types/FloatType.cs\nnew file mode 100644\nindex 0000000000..c4232931d0\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/FloatType.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class FloatType: FloatingPointType\n+    {\n+        public static readonly FloatType Default = new FloatType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Float;\n+        public override string Name => \"float\";\n+        public override int BitWidth => 32;\n+        public override bool IsSigned => true;\n+        public override PrecisionKind Precision => PrecisionKind.Single;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<FloatType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/FloatingPointType.cs b/csharp/src/Apache.Arrow/Types/FloatingPointType.cs\nnew file mode 100644\nindex 0000000000..5f667c7222\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/FloatingPointType.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public abstract class FloatingPointType: NumberType\n+    {\n+        public enum PrecisionKind\n+        {\n+            Half,\n+            Single,\n+            Double\n+        }\n+\n+        public abstract PrecisionKind Precision { get; }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/HalfFloatType.cs b/csharp/src/Apache.Arrow/Types/HalfFloatType.cs\nnew file mode 100644\nindex 0000000000..22f1370af5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/HalfFloatType.cs\n@@ -0,0 +1,38 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class HalfFloatType: FloatingPointType\n+    {\n+        public static readonly HalfFloatType Default = new HalfFloatType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.HalfFloat;\n+        public override string Name => \"halffloat\";\n+        public override int BitWidth => 16;\n+        public override bool IsSigned => true;\n+        public override PrecisionKind Precision => PrecisionKind.Half;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<HalfFloatType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/IArrowType.cs b/csharp/src/Apache.Arrow/Types/IArrowType.cs\nnew file mode 100644\nindex 0000000000..d75be542a9\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/IArrowType.cs\n@@ -0,0 +1,65 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public enum ArrowTypeId\n+    {\n+        Null,\n+        Boolean,\n+        UInt8,\n+        Int8,\n+        UInt16,\n+        Int16,\n+        UInt32,\n+        Int32,\n+        UInt64,\n+        Int64,\n+        HalfFloat,\n+        Float,\n+        Double,\n+        String,\n+        Binary,\n+        FixedSizedBinary,\n+        Date32,\n+        Date64,\n+        Timestamp,\n+        Time32,\n+        Time64,\n+        Interval,\n+        Decimal,\n+        List,\n+        Struct,\n+        Union,\n+        Dictionary,\n+        Map\n+    }\n+\n+    public interface IArrowType\n+    {\n+        ArrowTypeId TypeId { get; }\n+\n+        string Name { get; }\n+ \n+        void Accept(IArrowTypeVisitor visitor);\n+\n+        bool IsFixedWidth { get; }\n+    \n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/IArrowTypeVisitor.cs b/csharp/src/Apache.Arrow/Types/IArrowTypeVisitor.cs\nnew file mode 100644\nindex 0000000000..3cd602ba18\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/IArrowTypeVisitor.cs\n@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public interface IArrowTypeVisitor\n+    {\n+        void Visit(IArrowType type);\n+    }\n+\n+    public interface IArrowTypeVisitor<in T>: IArrowTypeVisitor\n+        where T: IArrowType\n+    {\n+        void Visit(T type);\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/Int16Type.cs b/csharp/src/Apache.Arrow/Types/Int16Type.cs\nnew file mode 100644\nindex 0000000000..3a7edbe0bd\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Int16Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Int16Type : NumberType\n+    {\n+        public static readonly Int16Type Default = new Int16Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Int16;\n+        public override string Name => \"int16\";\n+        public override int BitWidth => 16;\n+        public override bool IsSigned => true;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int16Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/Int32Type.cs b/csharp/src/Apache.Arrow/Types/Int32Type.cs\nnew file mode 100644\nindex 0000000000..e8df522679\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Int32Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Int32Type : NumberType\n+    {\n+        public static readonly Int32Type Default = new Int32Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Int32;\n+        public override string Name => \"int32\";\n+        public override int BitWidth => 32;\n+        public override bool IsSigned => true;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int32Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/Int64Type.cs b/csharp/src/Apache.Arrow/Types/Int64Type.cs\nnew file mode 100644\nindex 0000000000..afdf409886\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Int64Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Int64Type : NumberType\n+    {\n+        public static readonly Int64Type Default = new Int64Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Int64;\n+        public override string Name => \"int64\";\n+        public override int BitWidth => 64;\n+        public override bool IsSigned => true;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int64Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/Int8Type.cs b/csharp/src/Apache.Arrow/Types/Int8Type.cs\nnew file mode 100644\nindex 0000000000..9687cd349c\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Int8Type.cs\n@@ -0,0 +1,37 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Int8Type: NumberType\n+    {\n+        public static readonly Int8Type Default = new Int8Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Int8;\n+        public override string Name => \"int8\";\n+        public override int BitWidth => 8;\n+        public override bool IsSigned => true;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int8Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/IntervalUnit.cs b/csharp/src/Apache.Arrow/Types/IntervalUnit.cs\nnew file mode 100644\nindex 0000000000..e287548ef6\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/IntervalUnit.cs\n@@ -0,0 +1,47 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public enum IntervalUnit\n+    {\n+        YearMonth = 0,\n+        DayTime = 1\n+    }\n+\n+    public class IntervalType: FixedWidthType\n+    {\n+        public override ArrowTypeId TypeId => ArrowTypeId.Interval;\n+        public override string Name => \"date\";\n+        public override int BitWidth => 64;\n+\n+        public IntervalUnit Unit { get; }\n+\n+        public IntervalType(IntervalUnit unit = IntervalUnit.YearMonth)\n+        {\n+            Unit = unit;\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<IntervalType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/ListType.cs b/csharp/src/Apache.Arrow/Types/ListType.cs\nnew file mode 100644\nindex 0000000000..fa5c87cd4e\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/ListType.cs\n@@ -0,0 +1,42 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class ListType: ArrowType\n+    {\n+        public override ArrowTypeId TypeId => ArrowTypeId.List;\n+        public override string Name => \"list\";\n+\n+        public Field ValueField { get; }\n+        public IArrowType ValueDataType { get; }\n+\n+        public ListType(Field valueField, IArrowType valueDataType)\n+        {\n+            ValueField = valueField ?? throw new ArgumentNullException(nameof(valueField));\n+            ValueDataType = valueDataType ?? NullType.Default;\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<ListType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/NullType.cs b/csharp/src/Apache.Arrow/Types/NullType.cs\nnew file mode 100644\nindex 0000000000..b299ed8c93\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/NullType.cs\n@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class NullType: ArrowType\n+    {\n+        public static readonly NullType Default = new NullType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Null;\n+        public override string Name => \"null\";\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<NullType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/NumberType.cs b/csharp/src/Apache.Arrow/Types/NumberType.cs\nnew file mode 100644\nindex 0000000000..a80bd44fe4\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/NumberType.cs\n@@ -0,0 +1,26 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public abstract class NumberType: FixedWidthType\n+    {\n+        public abstract bool IsSigned { get; }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/StringType.cs b/csharp/src/Apache.Arrow/Types/StringType.cs\nnew file mode 100644\nindex 0000000000..f2bb0822f8\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/StringType.cs\n@@ -0,0 +1,35 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class StringType: ArrowType\n+    {\n+        public static StringType Default = new StringType();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.String;\n+        public override string Name => \"utf8\";\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<StringType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/StructType.cs b/csharp/src/Apache.Arrow/Types/StructType.cs\nnew file mode 100644\nindex 0000000000..f9b9e0ce1d\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/StructType.cs\n@@ -0,0 +1,64 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class StructType: ArrowType\n+    {\n+        private readonly List<Field> _fields;\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Struct;\n+        public override string Name => \"struct\";\n+\n+        public IEnumerable<Field> Fields => _fields;\n+\n+        public StructType(IEnumerable<Field> fields)\n+        {\n+            _fields = fields?.ToList();\n+        }\n+\n+        public Field GetFieldByName(string name,\n+            IEqualityComparer<string> comparer = default)\n+        {\n+            if (comparer == null)\n+                comparer = StringComparer.Ordinal;\n+\n+            return Fields.FirstOrDefault(\n+                field => comparer.Equals(field.Name, name));\n+        }\n+\n+        public int GetFieldIndex(string name,\n+            IEqualityComparer<string> comparer = default)\n+        {\n+            if (comparer == null)\n+                comparer = StringComparer.Ordinal;\n+\n+            // TODO: Consider caching field index if this method is in hot path.\n+\n+            return _fields.FindIndex(\n+                field => comparer.Equals(field.Name, name));\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<StructType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/Time32Type.cs b/csharp/src/Apache.Arrow/Types/Time32Type.cs\nnew file mode 100644\nindex 0000000000..70cfe50972\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Time32Type.cs\n@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Time32Type: TimeType\n+    {\n+        public static readonly Time32Type Default = new Time32Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Time32;\n+        public override string Name => \"time32\";\n+        public override int BitWidth => 32;\n+\n+        public Time32Type(TimeUnit unit = TimeUnit.Millisecond)\n+            : base(unit) { }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int16Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/Time64Type.cs b/csharp/src/Apache.Arrow/Types/Time64Type.cs\nnew file mode 100644\nindex 0000000000..3f727859c6\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/Time64Type.cs\n@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class Time64Type: TimeType\n+    {\n+        public static readonly Time64Type Default = new Time64Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Time64;\n+        public override string Name => \"time64\";\n+        public override int BitWidth => 64;\n+\n+        public Time64Type(TimeUnit unit = TimeUnit.Millisecond)\n+            : base(unit) { }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Time64Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/TimeType.cs b/csharp/src/Apache.Arrow/Types/TimeType.cs\nnew file mode 100644\nindex 0000000000..dba488b4ea\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/TimeType.cs\n@@ -0,0 +1,39 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public enum TimeUnit\n+    {\n+        Second,\n+        Millisecond,\n+        Microsecond,\n+        Nanosecond\n+    }\n+\n+    public abstract class TimeType: FixedWidthType\n+    {\n+        public TimeUnit Unit { get; }\n+\n+        protected TimeType(TimeUnit unit)\n+        {\n+            Unit = unit;\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/TimestampType.cs b/csharp/src/Apache.Arrow/Types/TimestampType.cs\nnew file mode 100644\nindex 0000000000..22da8328dc\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/TimestampType.cs\n@@ -0,0 +1,47 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Collections.Generic;\n+using System.Text;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class TimestampType: FixedWidthType\n+    {\n+        public static readonly TimestampType Default = new TimestampType(TimeUnit.Millisecond, \"UTC\");\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.Timestamp;\n+        public override string Name => \"timestamp\";\n+        public override int BitWidth => 64;\n+\n+        public TimeUnit Unit { get; }\n+        public string Timezone { get; }\n+\n+        public TimestampType(\n+            TimeUnit unit = TimeUnit.Millisecond,\n+            string timezone = default)\n+        {\n+            Unit = unit;\n+            Timezone = timezone;\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<TimestampType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/src/Apache.Arrow/Types/UInt16Type.cs b/csharp/src/Apache.Arrow/Types/UInt16Type.cs\nnew file mode 100644\nindex 0000000000..eb87729cf5\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/UInt16Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class UInt16Type : NumberType\n+    {\n+        public static readonly UInt16Type Default = new UInt16Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.UInt16;\n+        public override string Name => \"uint16\";\n+        public override int BitWidth => 16;\n+        public override bool IsSigned => false;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<UInt16Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/UInt32Type.cs b/csharp/src/Apache.Arrow/Types/UInt32Type.cs\nnew file mode 100644\nindex 0000000000..e520004470\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/UInt32Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class UInt32Type : NumberType\n+    {\n+        public static readonly UInt32Type Default = new UInt32Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.UInt32;\n+        public override string Name => \"uint32\";\n+        public override int BitWidth => 32;\n+        public override bool IsSigned => false;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<UInt32Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/UInt64Type.cs b/csharp/src/Apache.Arrow/Types/UInt64Type.cs\nnew file mode 100644\nindex 0000000000..45c6fac056\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/UInt64Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class UInt64Type : NumberType\n+    {\n+        public static readonly UInt64Type Default = new UInt64Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.UInt64;\n+        public override string Name => \"uint64\";\n+        public override int BitWidth => 64;\n+        public override bool IsSigned => false;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<UInt64Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/UInt8Type.cs b/csharp/src/Apache.Arrow/Types/UInt8Type.cs\nnew file mode 100644\nindex 0000000000..d63e42b203\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/UInt8Type.cs\n@@ -0,0 +1,33 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+namespace Apache.Arrow.Types\n+{\n+    public class UInt8Type : NumberType\n+    {\n+        public static readonly UInt8Type Default = new UInt8Type();\n+\n+        public override ArrowTypeId TypeId => ArrowTypeId.UInt8;\n+        public override string Name => \"uint8\";\n+        public override int BitWidth => 8;\n+        public override bool IsSigned => false;\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<Int8Type> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\n\\ No newline at end of file\ndiff --git a/csharp/src/Apache.Arrow/Types/UnionType.cs b/csharp/src/Apache.Arrow/Types/UnionType.cs\nnew file mode 100644\nindex 0000000000..aadb1e7fbb\n--- /dev/null\n+++ b/csharp/src/Apache.Arrow/Types/UnionType.cs\n@@ -0,0 +1,50 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System.Collections.Generic;\n+using System.Linq;\n+\n+namespace Apache.Arrow.Types\n+{\n+    public enum UnionMode\n+    {\n+        Sparse,\n+        Dense\n+    }\n+\n+    public class UnionType: ArrowType\n+    {\n+        public override ArrowTypeId TypeId => ArrowTypeId.Union;\n+        public override string Name => \"union\";\n+\n+        public UnionMode Mode { get; }\n+        \n+        public IEnumerable<byte> TypeCodes { get; }\n+\n+        public UnionType(\n+            IEnumerable<Field> fields, IEnumerable<byte> typeCodes,\n+            UnionMode mode = UnionMode.Sparse)\n+        {\n+            TypeCodes = typeCodes.ToList();\n+            Mode = mode;\n+        }\n+\n+        public override void Accept(IArrowTypeVisitor visitor)\n+        {\n+            if (visitor is IArrowTypeVisitor<UnionType> v)\n+                v.Visit(this);\n+        }\n+    }\n+}\ndiff --git a/csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj b/csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj\nnew file mode 100644\nindex 0000000000..dca8e2d819\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj\n@@ -0,0 +1,24 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<Project Sdk=\"Microsoft.NET.Sdk\">\n+\n+  <Import Project=\"../../build/Common.props\" />\n+\n+  <PropertyGroup>\n+    <TargetFramework>netcoreapp2.1</TargetFramework>\n+    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n+  </PropertyGroup>\n+\n+  <ItemGroup>\n+    <PackageReference Include=\"Microsoft.NET.Test.Sdk\" Version=\"15.8.0\" />\n+    <PackageReference Include=\"xunit\" Version=\"2.4.0\" />\n+    <PackageReference Include=\"xunit.runner.visualstudio\" Version=\"2.4.0\">\n+      <PrivateAssets>all</PrivateAssets>\n+      <IncludeAssets>runtime; build; native; contentfiles; analyzers</IncludeAssets>\n+    </PackageReference>\n+  </ItemGroup>\n+\n+  <ItemGroup>\n+    <ProjectReference Include=\"..\\..\\src\\Apache.Arrow\\Apache.Arrow.csproj\" />\n+  </ItemGroup>\n+\n+</Project>\n\\ No newline at end of file\ndiff --git a/csharp/test/Apache.Arrow.Tests/ArrowBufferTests.cs b/csharp/test/Apache.Arrow.Tests/ArrowBufferTests.cs\nnew file mode 100644\nindex 0000000000..28de056a61\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/ArrowBufferTests.cs\n@@ -0,0 +1,88 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using System.Runtime.CompilerServices;\n+using Apache.Arrow.Memory;\n+using Apache.Arrow.Tests.Fixtures;\n+using Xunit;\n+\n+namespace Apache.Arrow.Tests\n+{\n+    public class ArrowBufferTests\n+    {\n+        public class Allocate : \n+            IClassFixture<DefaultMemoryPoolFixture>\n+        {\n+            private readonly DefaultMemoryPoolFixture _memoryPoolFixture;\n+\n+            public Allocate(DefaultMemoryPoolFixture memoryPoolFixture)\n+            {\n+                _memoryPoolFixture = memoryPoolFixture;\n+            }\n+\n+            /// <summary>\n+            /// Ensure Arrow buffers are allocated in multiples of 8-bytes.\n+            /// </summary>\n+            /// <param name=\"size\">number of bytes to allocate</param>\n+            /// <param name=\"expectedCapacity\">expected buffer capacity after allocation</param>\n+            [Theory]\n+            [InlineData(1, 8)]\n+            [InlineData(8, 8)]\n+            [InlineData(9, 16)]\n+            [InlineData(16, 16)]\n+            public void AllocatesWithExpectedPadding(int size, int expectedCapacity)\n+            {\n+                var buffer = ArrowBuffer.Allocate(size, _memoryPoolFixture.MemoryPool);\n+                Assert.Equal(buffer.Capacity, expectedCapacity);\n+            }\n+\n+            /// <summary>\n+            /// Ensure allocated buffers are aligned to multiples of 64.\n+            /// </summary>\n+            [Theory]\n+            [InlineData(1)]\n+            [InlineData(8)]\n+            [InlineData(64)]\n+            [InlineData(128)]\n+            public unsafe void AllocatesAlignedToMultipleOf64(int size)\n+            {\n+                var buffer = ArrowBuffer.Allocate(size, _memoryPoolFixture.MemoryPool);\n+\n+                using (var pin = buffer.Memory.Pin())\n+                {\n+                    var ptr = new IntPtr(pin.Pointer);\n+                    Assert.True(ptr.ToInt64() % 64 == 0);\n+                }\n+            }\n+\n+            /// <summary>\n+            /// Ensure padding in arrow buffers is initialized with zeroes.\n+            /// </summary>\n+            [Fact]\n+            public void HasZeroPadding()\n+            {\n+                var buffer = ArrowBuffer.Allocate(32, _memoryPoolFixture.MemoryPool);\n+                var span = buffer.GetSpan<byte>();\n+\n+                foreach (var b in span)\n+                {\n+                    Assert.Equal(0, b);\n+                }\n+            }\n+\n+        }\n+    }\n+}\ndiff --git a/csharp/test/Apache.Arrow.Tests/BitUtilityTests.cs b/csharp/test/Apache.Arrow.Tests/BitUtilityTests.cs\nnew file mode 100644\nindex 0000000000..b59bc4d758\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/BitUtilityTests.cs\n@@ -0,0 +1,138 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using System;\n+using Xunit;\n+\n+namespace Apache.Arrow.Tests\n+{\n+    public class BitUtilityTests\n+    {\n+        public class CountBits\n+        {\n+            [Theory]\n+            [InlineData(new byte[] { 0b00000000 }, 0)]\n+            [InlineData(new byte[] { 0b00000001 }, 1)]\n+            [InlineData(new byte[] { 0b11111111 }, 8)]\n+            [InlineData(new byte[] { 0b01001001, 0b01010010 }, 6)]\n+            public void CountsAllOneBits(byte[] data, int expectedCount)\n+            {\n+                Assert.Equal(expectedCount,\n+                    BitUtility.CountBits(data));\n+            }\n+\n+            [Theory]\n+            [InlineData(new byte[] { 0b11111111 }, 0, 8)]\n+            [InlineData(new byte[] { 0b11111111 }, 3, 5)]\n+            [InlineData(new byte[] { 0b11111111, 0b11111111 }, 9, 7)]\n+            [InlineData(new byte[] { 0b11111111 }, -1, 0)]\n+            public void CountsAllOneBitsFromAnOffset(byte[] data, int offset, int expectedCount)\n+            {\n+                Assert.Equal(expectedCount,\n+                    BitUtility.CountBits(data, offset));\n+            }\n+\n+            [Fact]\n+            public void CountsZeroBitsWhenDataIsEmpty()\n+            {\n+                Assert.Equal(0,\n+                    BitUtility.CountBits(null));\n+            }\n+        }\n+\n+        public class GetBit\n+        {\n+            [Theory]\n+            [InlineData(new byte[] { 0b01001001 }, 0, true)]\n+            [InlineData(new byte[] { 0b01001001 }, 1, false)]\n+            [InlineData(new byte[] { 0b01001001 }, 2, false)]\n+            [InlineData(new byte[] { 0b01001001 }, 3, true)]\n+            [InlineData(new byte[] { 0b01001001 }, 4, false)]\n+            [InlineData(new byte[] { 0b01001001 }, 5, false)]\n+            [InlineData(new byte[] { 0b01001001 }, 6, true)]\n+            [InlineData(new byte[] { 0b01001001 }, 7, false)]\n+            [InlineData(new byte[] { 0b01001001, 0b01010010 }, 8, false)]\n+            [InlineData(new byte[] { 0b01001001, 0b01010010 }, 14, true)]\n+            public void GetsCorrectBitForIndex(byte[] data, int index, bool expectedValue)\n+            {\n+                Assert.Equal(expectedValue,\n+                    BitUtility.GetBit(data, index));\n+            }\n+\n+            [Theory]\n+            [InlineData(null, 0)]\n+            [InlineData(new byte[] { 0b00000000 }, -1)]\n+            public void ThrowsWhenBitIndexOutOfRange(byte[] data, int index)\n+            {\n+                Assert.Throws<IndexOutOfRangeException>(() =>\n+                    BitUtility.GetBit(data, index));\n+            }\n+        }\n+\n+        public class SetBit\n+        {\n+            [Theory]\n+            [InlineData(new byte[] { 0b00000000 }, 0, new byte[] { 0b00000001 })]\n+            [InlineData(new byte[] { 0b00000000 }, 2, new byte[] { 0b00000100 })]\n+            [InlineData(new byte[] { 0b00000000 }, 7, new byte[] { 0b10000000 })]\n+            [InlineData(new byte[] { 0b00000000, 0b00000000 }, 8, new byte[] { 0b00000000, 0b00000001 })]\n+            [InlineData(new byte[] { 0b00000000, 0b00000000 }, 15, new byte[] { 0b00000000, 0b10000000 })]\n+            public void SetsBitAtIndex(byte[] data, int index, byte[] expectedValue)\n+            {\n+                BitUtility.SetBit(data, index);\n+                Assert.Equal(expectedValue, data);\n+            }\n+        }\n+\n+        public class ClearBit\n+        {\n+            [Theory]\n+            [InlineData(new byte[] { 0b00000001 }, 0, new byte[] { 0b00000000 })]\n+            [InlineData(new byte[] { 0b00000010 }, 1, new byte[] { 0b00000000 })]\n+            [InlineData(new byte[] { 0b10000001 }, 7, new byte[] { 0b00000001 })]\n+            [InlineData(new byte[] { 0b11111111, 0b11111111 }, 15, new byte[] { 0b11111111, 0b01111111 })]\n+            public void ClearsBitAtIndex(byte[] data, int index, byte[] expectedValue)\n+            {\n+                BitUtility.ClearBit(data, index);\n+                Assert.Equal(expectedValue, data);\n+            }\n+        }\n+\n+        public class RoundUpToMultipleOf64\n+        {\n+            [Theory]\n+            [InlineData(0, 0)]\n+            [InlineData(1, 64)]\n+            [InlineData(63, 64)]\n+            [InlineData(64, 64)]\n+            [InlineData(65, 128)]\n+            [InlineData(129, 192)]\n+            public void ReturnsNextMultiple(int size, int expectedSize)\n+            {\n+                Assert.Equal(expectedSize,\n+                    BitUtility.RoundUpToMultipleOf64(size));\n+            }\n+\n+            [Theory]\n+            [InlineData(0)]\n+            [InlineData(-1)]\n+            public void ReturnsZeroWhenSizeIsLessThanOrEqualToZero(int size)\n+            {\n+                Assert.Equal(0,\n+                    BitUtility.RoundUpToMultipleOf64(size));\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/test/Apache.Arrow.Tests/Fixtures/DefaultMemoryPoolFixture.cs b/csharp/test/Apache.Arrow.Tests/Fixtures/DefaultMemoryPoolFixture.cs\nnew file mode 100644\nindex 0000000000..a87bfae135\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/Fixtures/DefaultMemoryPoolFixture.cs\n@@ -0,0 +1,32 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Memory;\n+\n+namespace Apache.Arrow.Tests.Fixtures\n+{\n+    public class DefaultMemoryPoolFixture\n+    {\n+        public MemoryPool MemoryPool { get; }\n+\n+        public DefaultMemoryPoolFixture()\n+        {\n+            const int padding = 8;\n+            const int alignment = 64;\n+\n+            MemoryPool = new NativeMemoryPool(padding, alignment);\n+        }\n+    }\n+}\ndiff --git a/csharp/test/Apache.Arrow.Tests/SchemaBuilderTests.cs b/csharp/test/Apache.Arrow.Tests/SchemaBuilderTests.cs\nnew file mode 100644\nindex 0000000000..4c1fe7888b\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/SchemaBuilderTests.cs\n@@ -0,0 +1,83 @@\n+\ufeff// Licensed to the Apache Software Foundation (ASF) under one or more\n+// contributor license agreements. See the NOTICE file distributed with\n+// this work for additional information regarding copyright ownership.\n+// The ASF licenses this file to You under the Apache License, Version 2.0\n+// (the \"License\"); you may not use this file except in compliance with\n+// the License.  You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+// limitations under the License.\n+\n+using Apache.Arrow.Types;\n+using System;\n+using System.Collections.Generic;\n+using Xunit;\n+\n+namespace Apache.Arrow.Tests\n+{\n+    public class SchemaBuilderTests\n+    {\n+        public class Build\n+        {\n+            [Fact]\n+            public void FieldsAreNullableByDefault()\n+            {\n+                var b = new Schema.Builder();\n+                \n+                var schema = new Schema.Builder()\n+                    .Field(f => f.Name(\"f0\").DataType(Int32Type.Default))\n+                    .Build();\n+\n+                Assert.True(schema.Fields[\"f0\"].IsNullable);\n+            }\n+\n+            [Fact]\n+            public void FieldsHaveNullTypeByDefault()\n+            {\n+                var schema = new Schema.Builder()\n+                    .Field(f => f.Name(\"f0\"))\n+                    .Build();\n+\n+                Assert.True(schema.Fields[\"f0\"].DataType.GetType() == typeof(NullType));\n+            }\n+\n+            [Fact]\n+            public void FieldNameIsRequired()\n+            {\n+                Assert.Throws<ArgumentNullException>(() =>\n+                {\n+                    var schema = new Schema.Builder()\n+                        .Field(f => f.DataType(Int32Type.Default))\n+                        .Build();\n+                });\n+            }\n+\n+            [Theory]\n+            [MemberData(nameof(SampleSchema1))]\n+            public void FieldsHaveExpectedValues(string name, IArrowType type, bool nullable)\n+            {\n+                var schema = new Schema.Builder()\n+                    .Field(f => f.Name(name).DataType(type).Nullable(nullable))\n+                    .Build();\n+\n+                var field = schema.Fields[name];\n+\n+                Assert.Equal(name, field.Name);\n+                Assert.Equal(type.Name, field.DataType.Name);\n+                Assert.Equal(nullable, field.IsNullable);\n+            }\n+\n+            public static IEnumerable<object[]> SampleSchema1()\n+            {\n+                yield return new object[] {\"f0\", Int32Type.Default, true};\n+                yield return new object[] {\"f1\", DoubleType.Default, true};\n+                yield return new object[] {\"f2\", Int64Type.Default, false};\n+            }\n+        }\n+    }\n+}\ndiff --git a/csharp/test/Apache.Arrow.Tests/app.config b/csharp/test/Apache.Arrow.Tests/app.config\nnew file mode 100644\nindex 0000000000..b90af8430c\n--- /dev/null\n+++ b/csharp/test/Apache.Arrow.Tests/app.config\n@@ -0,0 +1,15 @@\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<configuration>\n+  <runtime>\n+    <assemblyBinding xmlns=\"urn:schemas-microsoft-com:asm.v1\">\n+      <dependentAssembly>\n+        <assemblyIdentity name=\"System.Numerics.Vectors\" publicKeyToken=\"b03f5f7f11d50a3a\" culture=\"neutral\" />\n+        <bindingRedirect oldVersion=\"0.0.0.0-4.1.4.0\" newVersion=\"4.1.4.0\" />\n+      </dependentAssembly>\n+      <dependentAssembly>\n+        <assemblyIdentity name=\"System.Buffers\" publicKeyToken=\"cc7b13ffcd2ddd51\" culture=\"neutral\" />\n+        <bindingRedirect oldVersion=\"0.0.0.0-4.0.3.0\" newVersion=\"4.0.3.0\" />\n+      </dependentAssembly>\n+    </assemblyBinding>\n+  </runtime>\n+</configuration>\n\\ No newline at end of file\ndiff --git a/dev/release/rat_exclude_files.txt b/dev/release/rat_exclude_files.txt\nindex c7329f07f8..e976ad05fc 100644\n--- a/dev/release/rat_exclude_files.txt\n+++ b/dev/release/rat_exclude_files.txt\n@@ -133,6 +133,14 @@ c_glib/doc/parquet-glib/parquet-glib.types\n c_glib/doc/parquet-glib/parquet-glib-sections.txt\n c_glib/doc/parquet-glib/parquet-glib-overrides.txt\n c_glib/gtk-doc.make\n+csharp/.gitattributes\n+csharp/src/Apache.Arrow/Flatbuf/*\n+csharp/build/Common.props\n+csharp/src/Apache.Arrow/Apache.Arrow.csproj\n+csharp/src/Apache.Arrow/Properties/Resources.Designer.cs\n+csharp/src/Apache.Arrow/Properties/Resources.resx\n+csharp/test/Apache.Arrow.Tests/Apache.Arrow.Tests.csproj\n+csharp/test/Apache.Arrow.Tests/app.config\n *.html\n *.sgml\n *.css\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-27T08:23:16.067+0000",
                    "updated": "2018-10-27T08:23:16.067+0000",
                    "started": "2018-10-27T08:23:16.067+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "159546",
                    "issueId": "13166238"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/worklog/159549",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #2815: ARROW-2712: [C#] Initial C# .NET library\nURL: https://github.com/apache/arrow/pull/2815#issuecomment-433602117\n \n \n   @chutchinson could you create an account on https://issues.apache.org/jira so I can assign ARROW-2712 to you? Thanks\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2018-10-27T08:29:57.875+0000",
                    "updated": "2018-10-27T08:29:57.875+0000",
                    "started": "2018-10-27T08:29:57.874+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "159549",
                    "issueId": "13166238"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 4800,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@d5717[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@15ac8cbf[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@219fbd12[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@502714ea[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@eee9e29[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@42164518[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1e3d0765[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@7655d00c[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@cb01739[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@7cfebd32[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@a8e8be7[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@5283ff0a[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 4800,
        "customfield_12312520": null,
        "customfield_12312521": "Sat Oct 27 08:30:26 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-10-27T08:30:33.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2712/watchers",
            "watchCount": 4,
            "isWatching": false
        },
        "created": "2018-06-15T00:53:15.000+0000",
        "updated": "2018-10-27T08:30:33.000+0000",
        "timeoriginalestimate": null,
        "description": "A feature request. I've seen this pop up\u00a0in a few places.\u00a0Want to have a\u00a0record of discussion on this topic.\u00a0\r\n\r\nI may be open to contributing this, but first need some general guidance on approach so I can understand effort level.\u00a0\r\n\r\nIt looks like there is not a good tool available for GObject Introspection binding to .NET so the easy pathway via Arrow Glib C API appears to be closed.\u00a0\r\n\r\nThe only GObject integration for .NET appears to be Mono GAPI\r\n\r\n[http://www.mono-project.com/docs/gui/gtksharp/gapi/]\r\n\r\nFrom what I can see this produces a GIR or similar XML, then generates C# code directly from that. Likely involves many manual fix ups of the XML. Worth a try?\u00a0\r\n\r\n\u00a0\r\n\r\nAlternatively I could look at generating some other direct binding from .NET to C/C++. Where I work we use Swig [http://www.swig.org/]. Good for vanilla cases, requires hand crafting of the .i files and specialized marshalling strategies for optimizing performance critical cases.\u00a0\r\n\r\nHaven't tried CppSharp but it looks more appealing than Swig in some ways\u00a0[https://github.com/mono/CppSharp/wiki/Users-Manual]\r\n\r\nIn either case,\u00a0not sure if better to use Glib C API or C++ API directly. What would be\u00a0pros/cons?\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "1h 20m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 4800
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C#] Initial C# .NET library",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16513337",
                    "id": "16513337",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "My guess would be that building a smallish native implementation of the Arrow columnar data structures would be one good path to best support and performance for .NET users, as well as to make development more accessible for C# folks. I'm not an expert though. A binding layer could be developed to use the C++ libraries in C#. ",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-06-15T04:52:32.916+0000",
                    "updated": "2018-06-15T04:52:32.916+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16513434",
                    "id": "16513434",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Thanks Wes, can you please elaborate a little. What could be the performance advantages of a native implementation over a binding layer? In terms of a reference implementation for .NET, would the Java implementation be the closest model?\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-06-15T06:42:39.069+0000",
                    "updated": "2018-06-15T06:42:39.069+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16513450",
                    "id": "16513450",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Again, I'm not an expert, but I think that going through C bindings to a C++ library would prevent the CLR runtime from generating possibly better code on hot paths. \r\n\r\nI'm not sure whether the Java or C++ implementation is going to be a better model for a .NET library. The Java codebase grew organically originally within Apache Drill until the formation of Apache Arrow. The C++ library was started from scratch at beginning of 2016",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-06-15T06:59:24.313+0000",
                    "updated": "2018-06-15T06:59:44.096+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16513540",
                    "id": "16513540",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
                        "name": "kou",
                        "key": "kou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
                        },
                        "displayName": "Kouhei Sutou",
                        "active": true,
                        "timeZone": "Asia/Tokyo"
                    },
                    "body": "Thanks for thinking .NET support! From my point of view:\r\n\r\nGLib C API based bindings:\r\n\r\nPros:\r\n\r\n* We can get well workable .NET library with the least works if Mono GAPI works well.\r\n** We can work together for Ruby library and .NET library.\r\n\r\nCons:\r\n\r\n* There is overhead than C++ API based bindings.\r\n* We don't try building GLib C API on Windows yet. (I need Windows environment...)\r\n** I'll work on it eventually.\r\n\r\nC++ API based bindings:\r\n\r\nPros:\r\n\r\n* We may get well workable .NET library with less works if Mono CppSharp works well. (It seems that it works well.)\r\n* We can use optimization in C++ API. (LLVM based JIT is planed.)\r\n\r\nCons:\r\n\r\n* It may be slower than C# native implementation.\r\n* It may be difficult to use than C# native implementation.\r\n* It may be difficult to install than C# native implementation.\r\n\r\nC# native implementation:\r\n\r\nPros:\r\n\r\n* It may be faster than bindings.\r\n* It will be easy to use.\r\n* It will be easy to install.\r\n\r\nCons:\r\n\r\n* We need many works.\r\n** We can implement step by step.\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=kou",
                        "name": "kou",
                        "key": "kou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=kou&avatarId=30762",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=kou&avatarId=30762",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=kou&avatarId=30762",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=kou&avatarId=30762"
                        },
                        "displayName": "Kouhei Sutou",
                        "active": true,
                        "timeZone": "Asia/Tokyo"
                    },
                    "created": "2018-06-15T08:47:38.482+0000",
                    "updated": "2018-06-15T08:47:38.482+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16515358",
                    "id": "16515358",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I've given a little more thought to the idea of a native C# implementation. I found the C++ implementation the easiest to understand.\u00a0\r\n\r\nConsidering a narrow proof of concept that would\u00a0replicate the classes in\u00a0arrow/cpp/src/arrow/ but not subfolders.\u00a0\r\n\r\nHopefully\u00a0enough to replicate example [https://arrow.apache.org/docs/cpp/md_tutorials_row_wise_conversion.html]\r\n\r\nIt seems to me the\u00a0scope of that is manageable and there are some more or less ready made components in corefx.\u00a0\r\n\r\n*MemoryPool*\r\n\r\n[C++ MemoryPool|[https://github.com/apache/arrow/blob/master/cpp/src/arrow/memory_pool.h]] can be replicated via\u00a0\r\n\r\n[C# MemoryPool|[https://github.com/dotnet/corefx/blob/master/src/System.Memory/src/System/Buffers/MemoryPool.cs]].\u00a0\r\n\r\nMaybe start with a built in\u00a0Memory Pool, that allocates a large block of managed memory and pins\u00a0[https://github.com/aspnet/Common/tree/dev/shared/Microsoft.Extensions.Buffers.MemoryPool.Sources]\r\n\r\nAlternatively could PInvoke Arrow C++\u00a0Allocator.\u00a0\r\n\r\nAnother interesting point of reference is [https://github.com/allisterb/jemalloc.NET]\r\n\r\n*Buffer*\r\n\r\n[C++ Buffer|[https://github.com/apache/arrow/blob/master/cpp/src/arrow/buffer.h]] can likely be replicated by something built on top of Memory<T>. Span<T> and Memory<T> are used for 0 copy slicing\u00a0\r\n\r\n[https://msdn.microsoft.com/en-us/magazine/mt814808.aspx]\r\n\r\n*Array*\r\n\r\n[https://github.com/apache/arrow/blob/master/cpp/src/arrow/array.h]\r\n\r\nBuilds naturally from Buffer.\r\n\r\nNote that ArrayVector = std::vector<std::shared_ptr<Array>>;\r\n\r\n*ChunkedArray*\u00a0\r\n\r\nA data structure managing a list of primitive Arrow arrays logically\u00a0as one large array\r\n\r\n[https://github.com/apache/arrow/blob/master/cpp/src/arrow/table.h]\r\n\r\nCompare\u00a0to [https://github.com/dotnet/corefx/blob/master/src/System.IO.Pipelines/src/System/IO/Pipelines/BufferSegment.cs]\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\nNote one assumption is that in general\u00a0std::shared_ptr<T> can be replaced by just T in C# managed classes.\u00a0\r\n\r\nGotta run now, more to follow...\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-06-18T05:23:58.179+0000",
                    "updated": "2018-06-18T09:50:46.745+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16515360",
                    "id": "16515360",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "I wanted to say - I already thought of a cool name for a .NET Arrow implementation.\u00a0Can anyone guess?\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-06-18T05:26:42.991+0000",
                    "updated": "2018-06-18T05:26:42.991+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16549775",
                    "id": "16549775",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "body": "Thanks [~Jamie Elliott] for taking a look at this! Some feedback to your proposal:\r\n\r\n* MemoryPool: I guess it is best to go with https://github.com/allisterb/jemalloc.NET A speciality we have in Arrow is that we want to have 64byte-aligned allocations to make the most use out of SIMD instruction set. I don't see that there is an interface in the linked ones that provides aligned allocation and especially aligned reallocation.\r\n* Buffer: At a first glance the mentioned .net interfaces here seem to fit quite good to what we have in the C++ implementation.\r\n* ChunkedArray: Not sure how much you would want to build upon BufferSegment. It provides a nice .net-style scaffold for an API for ChunkedArray but it still a bit away from what ChunkedArray really is about.\r\n\r\nCool name: No good idea but in your text you naturally used the word {{narrow}}. But this is probably more a bad pun that a good name :D",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=uwe",
                        "name": "uwe",
                        "key": "xhochy",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=xhochy&avatarId=30652",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=xhochy&avatarId=30652",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=xhochy&avatarId=30652",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=xhochy&avatarId=30652"
                        },
                        "displayName": "Uwe Korn",
                        "active": true,
                        "timeZone": "Europe/Berlin"
                    },
                    "created": "2018-07-19T20:01:01.045+0000",
                    "updated": "2018-07-19T20:01:01.045+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16658378",
                    "id": "16658378",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I have renamed this JIRA since we are receiving a donation of a native C# .NET implementation",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-10-21T20:42:32.609+0000",
                    "updated": "2018-10-21T20:42:32.609+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16659971",
                    "id": "16659971",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "Hey! Sorry I let this slide. I had more or less clear in my head what I was planning but just got too busy with my day job.\u00a0If someone is donating that is very exciting. Can you give any more details?\u00a0\r\n\r\nBTW - the name I was going to suggest was SharpArrow.\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=Jamie+Elliott",
                        "name": "Jamie Elliott",
                        "key": "jamie elliott",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=jamie+elliott&avatarId=35919",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=jamie+elliott&avatarId=35919",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=jamie+elliott&avatarId=35919",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=jamie+elliott&avatarId=35919"
                        },
                        "displayName": "Jamie Elliott",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-10-23T02:27:30.074+0000",
                    "updated": "2018-10-23T02:27:30.074+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16660242",
                    "id": "16660242",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "See https://github.com/apache/arrow/pull/2815. I think it's just going to be {{Apache.Arrow}} in C#",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-10-23T08:14:31.689+0000",
                    "updated": "2018-10-23T08:14:31.689+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13166238/comment/16665988",
                    "id": "16665988",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Resolved in https://github.com/apache/arrow/commit/940254200febf017b4d912912f836cddeb76ee0b",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2018-10-27T08:30:26.753+0000",
                    "updated": "2018-10-27T08:30:26.753+0000"
                }
            ],
            "maxResults": 11,
            "total": 11,
            "startAt": 0
        },
        "customfield_12311820": "0|i3uw5r:",
        "customfield_12314139": null
    }
}