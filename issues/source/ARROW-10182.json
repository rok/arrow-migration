{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13333809",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809",
    "key": "ARROW-10182",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12348823",
                "id": "12348823",
                "description": "",
                "name": "3.0.0",
                "archived": false,
                "released": true,
                "releaseDate": "2021-01-25"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=westonpace",
            "name": "westonpace",
            "key": "westonpace",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=34045",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=34045",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=34045",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=34045"
            },
            "displayName": "Weston Pace",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 35400,
            "total": 35400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 35400,
            "total": 35400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10182/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 59,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/512462",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz opened a new pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680\n\n\n   Adds `Future<T>::Then(OnSuccess, OnFailure)` which registers callbacks to be executed on completion of the future and yields a future which wraps the result of those callbacks; if a callback returns:\r\n   \r\n   - `void`, Then() returns a `Future<>` which completes successully as soon as the callback runs.\r\n   - `Status`, Then() returns a `Future<>` which completes with the returned `Status` as soon as the callback runs.\r\n   - `V` or `Result<V>`, Then() returns a `Future<V>` which completes with whatever the callback returns.\r\n   - `Future<V>`, Then() returns a `Future<V>` which will be marked complete when the future returned by the callback completes (and will complete with the same result).\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-16T17:13:25.984+0000",
                    "updated": "2020-11-16T17:13:25.984+0000",
                    "started": "2020-11-16T17:13:25.984+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512462",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/512465",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#issuecomment-728205092\n\n\n   https://issues.apache.org/jira/browse/ARROW-10182\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-16T17:20:24.441+0000",
                    "updated": "2020-11-16T17:20:24.441+0000",
                    "started": "2020-11-16T17:20:24.440+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512465",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/512595",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#issuecomment-728333688\n\n\n   Added a benchmark to measure the cost of creating a Future in Executor::Submit instead of just using Executor::Spawn. Locally:\r\n   ```\r\n   ---------------------------------------------------------------------------------------------\r\n   Benchmark                                                      Time           CPU Iterations\r\n   ---------------------------------------------------------------------------------------------\r\n   ThreadPoolSpawn/threads:4/task_cost:1000/real_time     201939036 ns  173389187 ns          6    967.19k items/s\r\n   ThreadPoolSpawn/threads:8/task_cost:1000/real_time     294998893 ns  264699658 ns          2   662.082k items/s\r\n   ThreadPoolSpawn/threads:4/task_cost:10000/real_time     36495616 ns    2546067 ns         19   535.194k items/s\r\n   ThreadPoolSpawn/threads:8/task_cost:10000/real_time     20151885 ns    3711374 ns         30   969.251k items/s\r\n   ThreadPoolSpawn/threads:4/task_cost:100000/real_time    36728060 ns     285424 ns         19   53.2046k items/s\r\n   ThreadPoolSpawn/threads:8/task_cost:100000/real_time    23104241 ns     415593 ns         29   84.5776k items/s\r\n   ThreadPoolSubmit/threads:4/task_cost:1000/real_time     20986410 ns   19332114 ns         33   465.377k items/s\r\n   ThreadPoolSubmit/threads:8/task_cost:1000/real_time     19378929 ns   18328342 ns         36    503.98k items/s\r\n   ThreadPoolSubmit/threads:4/task_cost:10000/real_time     2320937 ns     761124 ns        303   421.183k items/s\r\n   ThreadPoolSubmit/threads:8/task_cost:10000/real_time     1727973 ns    1442820 ns        393   565.714k items/s\r\n   ThreadPoolSubmit/threads:4/task_cost:100000/real_time    2085426 ns     112413 ns        329   47.2962k items/s\r\n   ThreadPoolSubmit/threads:8/task_cost:100000/real_time    1279387 ns     104251 ns        514   77.0938k items/s\r\n   ```\r\n   This shows there is significant overhead for small tasks and pools with fewer threads. Follow up: https://issues.apache.org/jira/browse/ARROW-10625\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-11-16T21:15:29.426+0000",
                    "updated": "2020-11-16T21:15:29.426+0000",
                    "started": "2020-11-16T21:15:29.426+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "512595",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519088",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534291430\n\n\n\n##########\nFile path: cpp/src/arrow/util/functional.h\n##########\n@@ -79,5 +84,47 @@ struct call_traits {\n       typename std::enable_if<std::is_same<return_type<F>, T>::value, RT>;\n };\n \n+/// A type erased callable object which may only be invoked once.\n\nReview comment:\n       Is it a kind of lighter-weight `std::function`?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T16:10:58.246+0000",
                    "updated": "2020-12-02T16:10:58.246+0000",
                    "started": "2020-12-02T16:10:58.246+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519088",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519121",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534335689\n\n\n\n##########\nFile path: cpp/src/arrow/util/functional.h\n##########\n@@ -79,5 +84,47 @@ struct call_traits {\n       typename std::enable_if<std::is_same<return_type<F>, T>::value, RT>;\n };\n \n+/// A type erased callable object which may only be invoked once.\n\nReview comment:\n       yes, with the added guarantee that when it is called it will drop all references which it has in closure\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:08:40.474+0000",
                    "updated": "2020-12-02T17:08:40.474+0000",
                    "started": "2020-12-02T17:08:40.474+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519121",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519129",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534295329\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -243,6 +253,12 @@ class ConcreteFutureImpl : public FutureImpl {\n       }\n     }\n     cv_.notify_all();\n+\n+    // run callbacks\n+    for (auto&& callback : callbacks_) {\n\nReview comment:\n       This isn't safe without the mutex held. But of course we don't want to call the callback while locked. The solution is probably to move the callbacks to another vector while locked.\n\n##########\nFile path: cpp/src/arrow/util/task_group.h\n##########\n@@ -56,21 +67,13 @@ class ARROW_EXPORT TaskGroup : public std::enable_shared_from_this<TaskGroup> {\n   /// The current aggregate error Status.  Non-blocking, useful for stopping early.\n   virtual Status current_status() = 0;\n \n-  /// Whether some tasks have already failed.  Non-blocking , useful for stopping early.\n+  /// Whether some tasks have already failed.  Non-blocking, useful for stopping early.\n   virtual bool ok() = 0;\n \n   /// How many tasks can typically be executed in parallel.\n   /// This is only a hint, useful for testing or debugging.\n   virtual int parallelism() = 0;\n \n-  /// Create a subgroup of this group.  This group can only finish\n-  /// when all subgroups have finished (this means you must be\n-  /// be careful to call Finish() on subgroups before calling it\n-  /// on the main group).\n-  // XXX if a subgroup errors out, should it propagate immediately to the parent\n-  // and to children?\n-  virtual std::shared_ptr<TaskGroup> MakeSubGroup() = 0;\n\nReview comment:\n       Thanks for removing this :-)\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n\nReview comment:\n       Hmm... what sense does it make to take a `Result<int>` if the callback is not executed on failure?\r\n   (same comment for the above test snippet)\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int i) { return std::to_string(i); },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n\nReview comment:\n       This test seems to already be in `FutureCompletionTest::Void`\n\n##########\nFile path: cpp/src/arrow/util/functional.h\n##########\n@@ -79,5 +84,47 @@ struct call_traits {\n       typename std::enable_if<std::is_same<return_type<F>, T>::value, RT>;\n };\n \n+/// A type erased callable object which may only be invoked once.\n+/// It can be constructed from any lambda which matches the provided call signature.\n+/// Invoking it results in destruction of the lambda, freeing any state/references\n+/// immediately. Invoking a default constructed FnOnce or one which has already been\n+/// invoked will segfault.\n+template <typename Signature>\n+class FnOnce;\n+\n+template <typename R, typename... A>\n+class FnOnce<R(A...)> {\n+ public:\n+  FnOnce() = default;\n+\n+  template <typename Fn,\n+            typename = typename std::enable_if<std::is_convertible<\n+                typename std::result_of<Fn && (A...)>::type, R>::value>::type>\n+  FnOnce(Fn fn) : impl_(new FnImpl<Fn>(std::move(fn))) {  // NOLINT runtime/explicit\n+  }\n+\n+  explicit operator bool() const { return impl_ != NULLPTR; }\n+\n+  R operator()(A... a) && {\n+    auto bye = std::move(impl_);\n+    return bye->invoke(static_cast<A&&>(a)...);\n\nReview comment:\n       Why not forward the arguments here?\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -229,6 +229,16 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n+  void AddCallback(Callback callback) {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    if (IsFutureFinished(state_)) {\n+      lock.unlock();\n+      std::move(callback)();\n\nReview comment:\n       This callback could be run before the other ones, if `DoMarkFinishedOrFailed` is still running. Is that a concern?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n\nReview comment:\n       \"produced\" means \"returned\"?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n\nReview comment:\n       You should move both callbacks in each branch, shouldn't you?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -19,63 +19,150 @@\n \n #include <atomic>\n #include <cmath>\n+#include <functional>\n #include <memory>\n #include <type_traits>\n #include <utility>\n #include <vector>\n \n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/type_fwd.h\"\n #include \"arrow/util/visibility.h\"\n \n namespace arrow {\n \n+namespace detail {\n+\n+struct Empty {\n+  static Result<Empty> ToResult(Status s) {\n+    if (ARROW_PREDICT_TRUE(s.ok())) {\n+      return Empty{};\n+    }\n+    return s;\n+  }\n+};\n+\n+template <typename>\n+struct is_future : std::false_type {};\n+\n+template <typename T>\n+struct is_future<Future<T>> : std::true_type {};\n+\n+template <typename Signature>\n+using result_of_t = typename std::result_of<Signature>::type;\n+\n+constexpr struct ContinueFuture {\n+  template <typename Return>\n+  struct ForReturnImpl;\n+\n+  template <typename Return>\n+  using ForReturn = typename ForReturnImpl<Return>::type;\n+\n+  template <typename Signature>\n+  using ForSignature = ForReturn<result_of_t<Signature>>;\n+\n+  template <typename F, typename... A, typename R = result_of_t<F && (A && ...)>,\n\nReview comment:\n       Can you use less terse argument names? I keep thinking `F` means \"future\" here.\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n\nReview comment:\n       Explain which arguments the callback should expect.\n\n##########\nFile path: cpp/src/arrow/util/task_group.h\n##########\n@@ -22,22 +22,33 @@\n #include <utility>\n \n #include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n\nReview comment:\n       This doesn't look required?\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n+        }\n+      }\n+\n+      OnSuccess on_success;\n+      OnFailure on_failure;\n+      ContinuedFuture next;\n+    };\n+\n+    AddCallback(Callback{std::forward<OnSuccess>(on_success),\n+                         std::forward<OnFailure>(on_failure), next});\n+\n+    return next;\n+  }\n+\n+  /// \\brief Overload without OnFailure. Failures will be passed through unchanged.\n+  template <typename OnSuccess,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success) const {\n+    return Then(std::forward<OnSuccess>(on_success), [](const Status& s) {\n+      return Result<typename ContinuedFuture::ValueType>(s);\n+    });\n+  }\n+\n+  template <typename OnComplete,\n+            typename ContinuedFuture = typename detail::ContinueFuture::ForSignature<\n+                OnComplete && (const Status&)>>\n+  ContinuedFuture Then(decltype(StatusOnly), OnComplete&& on_complete) const {\n\nReview comment:\n       I don't understand what this one does. Can you add a docstring or comment?\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -91,14 +81,17 @@ class ThreadedTaskGroup : public TaskGroup {\n       nremaining_.fetch_add(1, std::memory_order_acquire);\n \n       auto self = checked_pointer_cast<ThreadedTaskGroup>(shared_from_this());\n-      Status st = executor_->Spawn([self, task]() {\n-        if (self->ok_.load(std::memory_order_acquire)) {\n-          // XXX what about exceptions?\n-          Status st = task();\n-          self->UpdateStatus(std::move(st));\n-        }\n-        self->OneTaskDone();\n-      });\n+      Status st = executor_->Spawn(std::bind(\n+          [](const std::shared_ptr<ThreadedTaskGroup>& self,\n+             const std::function<Status()>& task) {\n+            if (self->ok_.load(std::memory_order_acquire)) {\n+              // XXX what about exceptions?\n+              Status st = task();\n+              self->UpdateStatus(std::move(st));\n+            }\n+            self->OneTaskDone();\n+          },\n+          std::move(self), std::move(task)));\n\nReview comment:\n       C++14 would make this easier...\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -116,25 +109,15 @@ class ThreadedTaskGroup : public TaskGroup {\n       cv_.wait(lock, [&]() { return nremaining_.load() == 0; });\n       // Current tasks may start other tasks, so only set this when done\n       finished_ = true;\n-      if (parent_) {\n-        parent_->OneTaskDone();\n-      }\n+      completion_future_.MarkFinished(status_);\n     }\n     return status_;\n   }\n \n   int parallelism() override { return executor_->GetCapacity(); }\n \n-  std::shared_ptr<TaskGroup> MakeSubGroup() override {\n-    std::lock_guard<std::mutex> lock(mutex_);\n-    auto child = new ThreadedTaskGroup(executor_);\n-    child->parent_ = this;\n-    nremaining_.fetch_add(1, std::memory_order_acquire);\n-    return std::shared_ptr<TaskGroup>(child);\n-  }\n-\n  protected:\n-  void UpdateStatus(Status&& st) {\n+  void UpdateStatus(const Status& st) {\n\nReview comment:\n       Hmm, `st` is moved below.\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -159,13 +142,13 @@ class ThreadedTaskGroup : public TaskGroup {\n   Executor* executor_;\n   std::atomic<int32_t> nremaining_;\n   std::atomic<bool> ok_;\n+  Future<> completion_future_ = Future<>::Make();\n\nReview comment:\n       This isn't used yet? Or does its presence have side effects?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_benchmark.cc\n##########\n@@ -103,8 +103,40 @@ static void ThreadPoolSpawn(benchmark::State& state) {\n   state.SetItemsProcessed(state.iterations() * nspawns);\n }\n \n+// Benchmark ThreadPool::Submit\n+static void ThreadPoolSubmit(benchmark::State& state) {  // NOLINT non-const reference\n+  const auto nthreads = static_cast<int>(state.range(0));\n+  const auto workload_size = static_cast<int32_t>(state.range(1));\n+\n+  Workload workload(workload_size);\n+\n+  const int32_t nspawns = 10000000 / workload_size + 1;\n+\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    auto pool = *ThreadPool::Make(nthreads);\n+    std::atomic<int32_t> n_finished{0};\n+    state.ResumeTiming();\n+\n+    for (int32_t i = 0; i < nspawns; ++i) {\n+      // Pass the task by reference to avoid copying it around\n+      (void)DeferNotOk(pool->Submit(std::ref(workload))).Then([&](...) {\n\nReview comment:\n       This is benchmarking much more than `Submit`, because it is also stressing the callback and continuation management. I would rather have separate `Future` micro-benchmarks (for construction, simple use cases, callbacks, continuations...).\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n\nReview comment:\n       Out of curiosity, what happens if one of these callbacks captures `fut`?\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_benchmark.cc\n##########\n@@ -136,21 +168,24 @@ static void ThreadedTaskGroup(benchmark::State& state) {\n \n   for (auto _ : state) {\n     auto task_group = TaskGroup::MakeThreaded(pool.get());\n-    for (int32_t i = 0; i < nspawns; ++i) {\n-      // Pass the task by reference to avoid copying it around\n-      task_group->Append(std::ref(task));\n-    }\n+    task_group->Append([&task, nspawns, task_group] {\n\nReview comment:\n       Why the nested append?\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -122,15 +122,21 @@ void AssertFinished(const Future<T>& fut) {\n // Assert the future is successful *now*\n template <typename T>\n void AssertSuccessful(const Future<T>& fut) {\n-  ASSERT_EQ(fut.state(), FutureState::SUCCESS);\n-  ASSERT_OK(fut.status());\n+  ASSERT_TRUE(fut.Wait(0.1));\n\nReview comment:\n       Hmm... this doesn't match the comment above anymore.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -768,4 +1361,27 @@ TYPED_TEST(FutureIteratorTest, ErrorsAsCompleted) { this->TestErrorsAsCompleted(\n \n TYPED_TEST(FutureIteratorTest, StressAsCompleted) { this->TestStressAsCompleted(); }\n \n+namespace internal {\n+TEST(FnOnceTest, MoveOnlyDataType) {\n+  // ensuring this is valid guarantees we are making no unnecessary copies\n\nReview comment:\n       Nice. Do we want to use `FnOnce` in other places at some point? (perhaps open a JIRA?)\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n\nReview comment:\n       Did you copy/paste this? This seems to be the same test snippet as a couple dozens lines above.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int i) { return std::to_string(i); },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n\nReview comment:\n       Ditto? (not sure)\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_benchmark.cc\n##########\n@@ -103,8 +103,40 @@ static void ThreadPoolSpawn(benchmark::State& state) {\n   state.SetItemsProcessed(state.iterations() * nspawns);\n }\n \n+// Benchmark ThreadPool::Submit\n+static void ThreadPoolSubmit(benchmark::State& state) {  // NOLINT non-const reference\n+  const auto nthreads = static_cast<int>(state.range(0));\n+  const auto workload_size = static_cast<int32_t>(state.range(1));\n+\n+  Workload workload(workload_size);\n+\n+  const int32_t nspawns = 10000000 / workload_size + 1;\n+\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    auto pool = *ThreadPool::Make(nthreads);\n+    std::atomic<int32_t> n_finished{0};\n+    state.ResumeTiming();\n+\n+    for (int32_t i = 0; i < nspawns; ++i) {\n+      // Pass the task by reference to avoid copying it around\n+      (void)DeferNotOk(pool->Submit(std::ref(workload))).Then([&](...) {\n\nReview comment:\n       (the `Future` micro-benchmarks can be deferred to another PR, though)\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n+        }\n+      }\n+\n+      OnSuccess on_success;\n+      OnFailure on_failure;\n+      ContinuedFuture next;\n+    };\n+\n+    AddCallback(Callback{std::forward<OnSuccess>(on_success),\n+                         std::forward<OnFailure>(on_failure), next});\n+\n+    return next;\n+  }\n+\n+  /// \\brief Overload without OnFailure. Failures will be passed through unchanged.\n+  template <typename OnSuccess,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success) const {\n+    return Then(std::forward<OnSuccess>(on_success), [](const Status& s) {\n+      return Result<typename ContinuedFuture::ValueType>(s);\n+    });\n+  }\n+\n+  template <typename OnComplete,\n+            typename ContinuedFuture = typename detail::ContinueFuture::ForSignature<\n+                OnComplete && (const Status&)>>\n+  ContinuedFuture Then(decltype(StatusOnly), OnComplete&& on_complete) const {\n\nReview comment:\n       Hmm, looking at the tests, I think I understand. The `StatusOnly` idiom doesn't look terrific. How about instead declaring this as `ContinuedFuture ThenBoth(OnComplete&& on_complete)`, where `OnComplete` would take either a `Result<T>` or a `Status`, depending on the future type?\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int i) { return std::to_string(i); },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 =\n+        fut.Then(StatusOnly, [&status_seen](const Status& s) { status_seen = s; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureStatus) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result, innerFut](const int& i) {\n+      passed_in_result = i;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(Status::OK());\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<>::Make();\n+    auto fut2 = fut.Then([innerFut](const int& i) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](const int& i) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(Status::OK());\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [&innerFut](const Status&) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(Status::OK());\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(Status::OK());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Result) {\n+  {\n\nReview comment:\n       Do we want to test cases where a failed `Result` is returned? Though it should work, since `MarkFinished` accepts it.\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n\nReview comment:\n       Ditto here? (though I'm not sure)\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -122,15 +122,21 @@ void AssertFinished(const Future<T>& fut) {\n // Assert the future is successful *now*\n template <typename T>\n void AssertSuccessful(const Future<T>& fut) {\n-  ASSERT_EQ(fut.state(), FutureState::SUCCESS);\n-  ASSERT_OK(fut.status());\n+  ASSERT_TRUE(fut.Wait(0.1));\n\nReview comment:\n       Perhaps instead add separate `AssertSuccessfulSoon` and `AssertFailedSoon`?\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, TailRemoved) {\n+  // Keeping the head of the future chain should keep the entire chain alive\n+  std::shared_ptr<Future<>> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  bool side_effect_run = false;\n+  {\n+    ref = std::make_shared<Future<>>(Future<>::Make());\n+    auto fut2 = ref->Then(StatusOnly, [&side_effect_run](const Status& status) {\n+      side_effect_run = true;\n+      return Status::OK();\n+    });\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_FALSE(ref2.expired());\n+\n+  ref->MarkFinished();\n+  ASSERT_TRUE(side_effect_run);\n+  ASSERT_TRUE(ref2.expired());\n+}\n+\n+TEST(FutureRefTest, HeadRemoved) {\n+  // Keeping the tail of the future chain should not keep the entire chain alive.  If no\n+  // one has a reference to the head then there is no need to keep it, nothing will finish\n+  // it.  In theory the intermediate futures could be finished by some external process\n+  // but that would be highly unusual and bad practice so in reality this would just be a\n+  // reference to a future that will never complete which is ok.\n+  std::weak_ptr<FutureImpl> ref;\n+  std::shared_ptr<Future<>> ref2;\n+  {\n+    auto fut = std::make_shared<Future<>>(Future<>::Make());\n+    ref = fut->impl_;\n+    ref2 = std::make_shared<Future<>>(fut->Then([](...) {}));\n+  }\n+  ASSERT_TRUE(ref.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    ref2 = std::make_shared<Future<>>(fut.Then([&](...) {\n+      auto intermediate = Future<>::Make();\n+      ref = intermediate.impl_;\n+      return intermediate;\n+    }));\n+    fut.MarkFinished();\n+  }\n+  ASSERT_TRUE(ref.expired());\n+}\n+\n+TEST(FutureCompletionTest, Void) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 =\n+        fut.Then([&passed_in_result](const int& result) { passed_in_result = result; });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    ASSERT_EQ(passed_in_result, 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const int& result) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& s) { return s; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly,\n+                         [&status_seen](const Status& result) { status_seen = result; });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, NonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(42);\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42 * 42);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto fut2 = fut.Then([](const Result<int>& result) {\n+      auto passed_in_result = *result;\n+      return passed_in_result * passed_in_result;\n+    });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int) { return 99; },\n+                         [&was_io_error](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return 100;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 100);\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then([](...) { return 42; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen](const Status& s) {\n+      status_seen = s;\n+      return 42;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, 42);\n+  }\n+}\n+\n+TEST(FutureCompletionTest, FutureNonVoid) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    int passed_in_result = 0;\n+    auto fut2 = fut.Then([&passed_in_result, innerFut](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return innerFut;\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([innerFut](int) { return innerFut; },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished();\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+  {\n+    // From failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([&innerFut](...) { return innerFut; });\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    AssertFailed(fut2);\n+  }\n+  {\n+    // Recover a failed status\n+    auto fut = Future<>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    Status status_seen = Status::OK();\n+    auto fut2 = fut.Then(StatusOnly, [&status_seen, &innerFut](const Status& s) {\n+      status_seen = s;\n+      return innerFut;\n+    });\n+    ASSERT_TRUE(status_seen.ok());\n+    fut.MarkFinished(Status::IOError(\"xxx\"));\n+    ASSERT_TRUE(status_seen.IsIOError());\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+  }\n+}\n+\n+TEST(FutureCompletionTest, Status) {\n+  {\n+    // Simple callback\n+    auto fut = Future<int>::Make();\n+    int passed_in_result = 0;\n+    Future<> fut2 = fut.Then([&passed_in_result](const Result<int>& result) {\n+      passed_in_result = *result;\n+      return Status::OK();\n+    });\n+    fut.MarkFinished(42);\n+    ASSERT_EQ(passed_in_result, 42);\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // Propagate failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    auto fut2 = fut.Then([innerFut](const Result<int>& result) { return innerFut; });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertFailed(fut2);\n+    ASSERT_TRUE(fut2.status().IsIOError());\n+  }\n+  {\n+    // Swallow failure\n+    auto fut = Future<int>::Make();\n+    auto innerFut = Future<std::string>::Make();\n+    bool was_io_error = false;\n+    auto fut2 = fut.Then([](int i) { return std::to_string(i); },\n+                         [&was_io_error, innerFut](const Status& s) {\n+                           was_io_error = s.IsIOError();\n+                           return innerFut;\n+                         });\n+    fut.MarkFinished(Result<int>(Status::IOError(\"xxx\")));\n+    AssertNotFinished(fut2);\n+    innerFut.MarkFinished(\"hello\");\n+    AssertSuccessful(fut2);\n+    auto result = *fut2.result();\n+    ASSERT_EQ(result, \"hello\");\n+    ASSERT_TRUE(was_io_error);\n+  }\n+  {\n+    // From void\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) {});\n+    fut.MarkFinished();\n+    AssertSuccessful(fut2);\n+  }\n+  {\n+    // From failed status\n\nReview comment:\n       DItto?\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:23:26.713+0000",
                    "updated": "2020-12-02T17:23:26.713+0000",
                    "started": "2020-12-02T17:23:26.713+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519129",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519134",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534350582\n\n\n\n##########\nFile path: cpp/src/arrow/util/functional.h\n##########\n@@ -79,5 +84,47 @@ struct call_traits {\n       typename std::enable_if<std::is_same<return_type<F>, T>::value, RT>;\n };\n \n+/// A type erased callable object which may only be invoked once.\n+/// It can be constructed from any lambda which matches the provided call signature.\n+/// Invoking it results in destruction of the lambda, freeing any state/references\n+/// immediately. Invoking a default constructed FnOnce or one which has already been\n+/// invoked will segfault.\n+template <typename Signature>\n+class FnOnce;\n+\n+template <typename R, typename... A>\n+class FnOnce<R(A...)> {\n+ public:\n+  FnOnce() = default;\n+\n+  template <typename Fn,\n+            typename = typename std::enable_if<std::is_convertible<\n+                typename std::result_of<Fn && (A...)>::type, R>::value>::type>\n+  FnOnce(Fn fn) : impl_(new FnImpl<Fn>(std::move(fn))) {  // NOLINT runtime/explicit\n+  }\n+\n+  explicit operator bool() const { return impl_ != NULLPTR; }\n+\n+  R operator()(A... a) && {\n+    auto bye = std::move(impl_);\n+    return bye->invoke(static_cast<A&&>(a)...);\n\nReview comment:\n       Since the types of the arguments are already fixed at class scope (so this is not a function template), perfect forwarding is not *really* available here.\r\n   \r\n   `A` might be:\r\n   - `std::string`, in which case `static_cast<A&&>` becomes `static_cast<std::string&&>` (appropriate move)\r\n   - `const std::string&`, in which case `static_cast<A&&>` reference-decays to `static_cast<const std::string&>` (no inappropriate move)\r\n   - `std::string&&`, in which case `static_cast<A&&>` becomes `static_cast<std::string&&>` (appropriate move)\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:30:03.193+0000",
                    "updated": "2020-12-02T17:30:03.193+0000",
                    "started": "2020-12-02T17:30:03.192+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519134",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519136",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534351495\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -229,6 +229,16 @@ class ConcreteFutureImpl : public FutureImpl {\n \n   void DoMarkFailed() { DoMarkFinishedOrFailed(FutureState::FAILURE); }\n \n+  void AddCallback(Callback callback) {\n+    std::unique_lock<std::mutex> lock(mutex_);\n+    if (IsFutureFinished(state_)) {\n+      lock.unlock();\n+      std::move(callback)();\n\nReview comment:\n       I don't think so; we don't provide guarantees on callback ordering. I'll add a comment to that effect\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:31:11.980+0000",
                    "updated": "2020-12-02T17:31:11.980+0000",
                    "started": "2020-12-02T17:31:11.979+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519136",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519137",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534351861\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n\nReview comment:\n       no, since this is in a FnOnce all members will be dropped as soon as it's invoked\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:31:47.265+0000",
                    "updated": "2020-12-02T17:31:47.265+0000",
                    "started": "2020-12-02T17:31:47.265+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519137",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519138",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534351861\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n\nReview comment:\n       not necessary; since this is in a FnOnce all members will be dropped as soon as it's invoked\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:32:00.426+0000",
                    "updated": "2020-12-02T17:32:00.426+0000",
                    "started": "2020-12-02T17:32:00.425+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519138",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519139",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534352213\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -19,63 +19,150 @@\n \n #include <atomic>\n #include <cmath>\n+#include <functional>\n #include <memory>\n #include <type_traits>\n #include <utility>\n #include <vector>\n \n #include \"arrow/result.h\"\n #include \"arrow/status.h\"\n+#include \"arrow/util/functional.h\"\n #include \"arrow/util/macros.h\"\n+#include \"arrow/util/type_fwd.h\"\n #include \"arrow/util/visibility.h\"\n \n namespace arrow {\n \n+namespace detail {\n+\n+struct Empty {\n+  static Result<Empty> ToResult(Status s) {\n+    if (ARROW_PREDICT_TRUE(s.ok())) {\n+      return Empty{};\n+    }\n+    return s;\n+  }\n+};\n+\n+template <typename>\n+struct is_future : std::false_type {};\n+\n+template <typename T>\n+struct is_future<Future<T>> : std::true_type {};\n+\n+template <typename Signature>\n+using result_of_t = typename std::result_of<Signature>::type;\n+\n+constexpr struct ContinueFuture {\n+  template <typename Return>\n+  struct ForReturnImpl;\n+\n+  template <typename Return>\n+  using ForReturn = typename ForReturnImpl<Return>::type;\n+\n+  template <typename Signature>\n+  using ForSignature = ForReturn<result_of_t<Signature>>;\n+\n+  template <typename F, typename... A, typename R = result_of_t<F && (A && ...)>,\n\nReview comment:\n       will do\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:32:23.749+0000",
                    "updated": "2020-12-02T17:32:23.749+0000",
                    "started": "2020-12-02T17:32:23.748+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519139",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519140",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534352606\n\n\n\n##########\nFile path: cpp/src/arrow/util/task_group.h\n##########\n@@ -22,22 +22,33 @@\n #include <utility>\n \n #include \"arrow/status.h\"\n+#include \"arrow/util/future.h\"\n\nReview comment:\n       will remove\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -91,14 +81,17 @@ class ThreadedTaskGroup : public TaskGroup {\n       nremaining_.fetch_add(1, std::memory_order_acquire);\n \n       auto self = checked_pointer_cast<ThreadedTaskGroup>(shared_from_this());\n-      Status st = executor_->Spawn([self, task]() {\n-        if (self->ok_.load(std::memory_order_acquire)) {\n-          // XXX what about exceptions?\n-          Status st = task();\n-          self->UpdateStatus(std::move(st));\n-        }\n-        self->OneTaskDone();\n-      });\n+      Status st = executor_->Spawn(std::bind(\n+          [](const std::shared_ptr<ThreadedTaskGroup>& self,\n+             const std::function<Status()>& task) {\n+            if (self->ok_.load(std::memory_order_acquire)) {\n+              // XXX what about exceptions?\n+              Status st = task();\n+              self->UpdateStatus(std::move(st));\n+            }\n+            self->OneTaskDone();\n+          },\n+          std::move(self), std::move(task)));\n\nReview comment:\n       indeed\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:33:00.150+0000",
                    "updated": "2020-12-02T17:33:00.150+0000",
                    "started": "2020-12-02T17:33:00.149+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519140",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519141",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534354000\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -768,4 +1361,27 @@ TYPED_TEST(FutureIteratorTest, ErrorsAsCompleted) { this->TestErrorsAsCompleted(\n \n TYPED_TEST(FutureIteratorTest, StressAsCompleted) { this->TestStressAsCompleted(); }\n \n+namespace internal {\n+TEST(FnOnceTest, MoveOnlyDataType) {\n+  // ensuring this is valid guarantees we are making no unnecessary copies\n\nReview comment:\n       Yes, I think it should replace `std::function` in `thread_pool.h` at least\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:34:44.219+0000",
                    "updated": "2020-12-02T17:34:44.219+0000",
                    "started": "2020-12-02T17:34:44.219+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519141",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519145",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534356842\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -243,6 +253,12 @@ class ConcreteFutureImpl : public FutureImpl {\n       }\n     }\n     cv_.notify_all();\n+\n+    // run callbacks\n+    for (auto&& callback : callbacks_) {\n\nReview comment:\n       I'm not sure why this isn't safe. During iteration the vector won't be dropped (since we have at least the reference held by the thread calling `MarkFinished`) or mutated (since attempting to add a callback to a finished future will immediately evaluate that callback)\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n\nReview comment:\n       will do\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:39:20.732+0000",
                    "updated": "2020-12-02T17:39:20.732+0000",
                    "started": "2020-12-02T17:39:20.731+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519145",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519147",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534357174\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n\nReview comment:\n       yes, I'll s/produced/returned\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:39:37.000+0000",
                    "updated": "2020-12-02T17:39:37.000+0000",
                    "started": "2020-12-02T17:39:37.000+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519147",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519149",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534358014\n\n\n\n##########\nFile path: cpp/src/arrow/util/task_group.cc\n##########\n@@ -159,13 +142,13 @@ class ThreadedTaskGroup : public TaskGroup {\n   Executor* executor_;\n   std::atomic<int32_t> nremaining_;\n   std::atomic<bool> ok_;\n+  Future<> completion_future_ = Future<>::Make();\n\nReview comment:\n       nope, I'll clean this up\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:40:44.944+0000",
                    "updated": "2020-12-02T17:40:44.944+0000",
                    "started": "2020-12-02T17:40:44.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519149",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519150",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534358168\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.cc\n##########\n@@ -243,6 +253,12 @@ class ConcreteFutureImpl : public FutureImpl {\n       }\n     }\n     cv_.notify_all();\n+\n+    // run callbacks\n+    for (auto&& callback : callbacks_) {\n\nReview comment:\n       Because you're accessing an object that's mutated (potentially) from another thread in `AddCallback`.\r\n   Ideally there should be a multi-threaded stress test for adding callbacks to a future.\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:40:59.056+0000",
                    "updated": "2020-12-02T17:40:59.056+0000",
                    "started": "2020-12-02T17:40:59.055+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519150",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519151",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534358943\n\n\n\n##########\nFile path: cpp/src/arrow/util/future.h\n##########\n@@ -264,11 +335,125 @@ class Future {\n   }\n \n   /// \\brief Make a finished Future<> with the provided Status.\n-  template <typename E = ValueType, typename = detail::Empty::EnableIfSame<E>>\n+  template <typename E = ValueType, typename = typename std::enable_if<\n+                                        std::is_same<E, detail::Empty>::value>::type>\n   static Future<> MakeFinished(Status s = Status::OK()) {\n     return MakeFinished(E::ToResult(std::move(s)));\n   }\n \n+  /// \\brief Consumer API: Register a callback to run when this future completes\n+  template <typename OnComplete>\n+  void AddCallback(OnComplete&& on_complete) const {\n+    struct Callback {\n+      void operator()() && {\n+        auto self = weak_self.get();\n+        std::move(on_complete)(*self.GetResult());\n+      }\n+\n+      WeakFuture<T> weak_self;\n+      OnComplete on_complete;\n+    };\n+\n+    // We know impl_ will not be dangling when invoking callbacks because at least one\n+    // thread will be waiting for MarkFinished to return. Thus it's safe to keep a\n+    // weak reference to impl_ here\n+    impl_->AddCallback(\n+        Callback{WeakFuture<T>(*this), std::forward<OnComplete>(on_complete)});\n+  }\n+\n+  /// \\brief Consumer API: Register a continuation to run when this future completes\n+  ///\n+  /// The continuation will run in the same thread that called MarkFinished (whatever\n+  /// callback is registered with this function will run before MarkFinished returns).\n+  /// Avoid long-running callbacks in favor of submitting a task to an Executor and\n+  /// returning the future.\n+  ///\n+  /// Two callbacks are supported:\n+  /// - OnSuccess, called against the result (const ValueType&) on successul completion.\n+  /// - OnFailure, called against the error (const Status&) on failed completion.\n+  ///\n+  /// Then() returns a Future whose ValueType is derived from the return type of the\n+  /// callbacks. If a callback returns:\n+  /// - void, a Future<> will be produced which will completes successully as soon\n+  ///   as the callback runs.\n+  /// - Status, a Future<> will be produced which will complete with the returned Status\n+  ///   as soon as the callback runs.\n+  /// - V or Result<V>, a Future<V> will be produced which will complete with the result\n+  ///   of invoking the callback as soon as the callback runs.\n+  /// - Future<V>, a Future<V> will be produced which will be marked complete when the\n+  ///   future returned by the callback completes (and will complete with the same\n+  ///   result).\n+  ///\n+  /// The continued Future type must be the same for both callbacks.\n+  ///\n+  /// Note that OnFailure can swallow errors, allowing continued Futures to successully\n+  /// complete even if this Future fails.\n+  ///\n+  /// If this future is already completed then the callback will be run immediately\n+  /// (before this method returns) and the returned future may already be marked complete\n+  /// (it will definitely be marked complete if the callback returns a non-future or a\n+  /// completed future).\n+  template <typename OnSuccess, typename OnFailure,\n+            typename ContinuedFuture =\n+                detail::ContinueFuture::ForSignature<OnSuccess && (const T&)>>\n+  ContinuedFuture Then(OnSuccess&& on_success, OnFailure&& on_failure) const {\n+    static_assert(\n+        std::is_same<detail::ContinueFuture::ForSignature<OnFailure && (const Status&)>,\n+                     ContinuedFuture>::value,\n+        \"OnSuccess and OnFailure must continue with the same future type\");\n+\n+    auto next = ContinuedFuture::Make();\n+\n+    struct Callback {\n+      void operator()(const Result<T>& result) && {\n+        if (ARROW_PREDICT_TRUE(result.ok())) {\n+          detail::Continue(std::move(next), std::move(on_success), result.ValueOrDie());\n+        } else {\n+          detail::Continue(std::move(next), std::move(on_failure), result.status());\n\nReview comment:\n       Hmm, ok. I thought calling `std::move` on the unused callback before calling `detail::Continue`, but that may not matter much (though it's always nice to release resources earlier).\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:42:15.595+0000",
                    "updated": "2020-12-02T17:42:15.595+0000",
                    "started": "2020-12-02T17:42:15.594+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519151",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519152",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534359769\n\n\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_benchmark.cc\n##########\n@@ -103,8 +103,40 @@ static void ThreadPoolSpawn(benchmark::State& state) {\n   state.SetItemsProcessed(state.iterations() * nspawns);\n }\n \n+// Benchmark ThreadPool::Submit\n+static void ThreadPoolSubmit(benchmark::State& state) {  // NOLINT non-const reference\n+  const auto nthreads = static_cast<int>(state.range(0));\n+  const auto workload_size = static_cast<int32_t>(state.range(1));\n+\n+  Workload workload(workload_size);\n+\n+  const int32_t nspawns = 10000000 / workload_size + 1;\n+\n+  for (auto _ : state) {\n+    state.PauseTiming();\n+    auto pool = *ThreadPool::Make(nthreads);\n+    std::atomic<int32_t> n_finished{0};\n+    state.ResumeTiming();\n+\n+    for (int32_t i = 0; i < nspawns; ++i) {\n+      // Pass the task by reference to avoid copying it around\n+      (void)DeferNotOk(pool->Submit(std::ref(workload))).Then([&](...) {\n\nReview comment:\n       I agree it warrants improvement and individual benchmarking, but my intent was to measure the end-to-end cost of using Submit+callbacks since that's relevant to the csv parsing case\n\n##########\nFile path: cpp/src/arrow/util/thread_pool_benchmark.cc\n##########\n@@ -136,21 +168,24 @@ static void ThreadedTaskGroup(benchmark::State& state) {\n \n   for (auto _ : state) {\n     auto task_group = TaskGroup::MakeThreaded(pool.get());\n-    for (int32_t i = 0; i < nspawns; ++i) {\n-      // Pass the task by reference to avoid copying it around\n-      task_group->Append(std::ref(task));\n-    }\n+    task_group->Append([&task, nspawns, task_group] {\n\nReview comment:\n       hold over, will clean\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:43:46.525+0000",
                    "updated": "2020-12-02T17:43:46.525+0000",
                    "started": "2020-12-02T17:43:46.524+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519152",
                    "issueId": "13333809"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/worklog/519153",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "bkietz commented on a change in pull request #8680:\nURL: https://github.com/apache/arrow/pull/8680#discussion_r534360066\n\n\n\n##########\nFile path: cpp/src/arrow/util/future_test.cc\n##########\n@@ -276,6 +282,593 @@ TEST(FutureSyncTest, Int) {\n   }\n }\n \n+TEST(FutureRefTest, ChainRemoved) {\n+  // Creating a future chain should not prevent the futures from being deleted if the\n+  // entire chain is deleted\n+  std::weak_ptr<FutureImpl> ref;\n+  std::weak_ptr<FutureImpl> ref2;\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status& status) { return Status::OK(); });\n+    ref = fut.impl_;\n+    ref2 = fut2.impl_;\n+  }\n+  ASSERT_TRUE(ref.expired());\n+  ASSERT_TRUE(ref2.expired());\n+\n+  {\n+    auto fut = Future<>::Make();\n+    auto fut2 = fut.Then(StatusOnly, [](const Status&) { return Future<>::Make(); });\n\nReview comment:\n       I'll add a case for that\n\n\n\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n\nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-12-02T17:43:59.858+0000",
                    "updated": "2020-12-02T17:43:59.858+0000",
                    "started": "2020-12-02T17:43:59.857+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "519153",
                    "issueId": "13333809"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
            "id": "2",
            "description": "A new feature of the product, which has yet to be developed.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
            "name": "New Feature",
            "subtask": false,
            "avatarId": 21141
        },
        "timespent": 35400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@270f8e11[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@388f0042[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@4c66dae9[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@c2b4e37[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@78f7d63e[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@7a3f02a7[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@f42e9b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@56788244[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1078f893[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@12d0fa01[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@33f18e36[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@218950ae[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 35400,
        "customfield_12312520": null,
        "customfield_12312521": "Fri Dec 18 20:06:30 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-12-18T20:06:30.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-10182/watchers",
            "watchCount": 1,
            "isWatching": false
        },
        "created": "2020-10-05T22:31:16.000+0000",
        "updated": "2021-01-16T21:45:14.000+0000",
        "timeoriginalestimate": null,
        "description": "Add support for Then, WhenAny, and WhenAll.\u00a0 This will allow for expressing dependencies between tasks and eliminates threads in the thread pool that are simply waiting for other tasks to complete.",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 35400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Add basic continuation support to futures",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13333809/comment/17251983",
                    "id": "17251983",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 8680\n[https://github.com/apache/arrow/pull/8680]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=bkietz",
                        "name": "bkietz",
                        "key": "bkietz",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bkietz&avatarId=37277",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bkietz&avatarId=37277",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bkietz&avatarId=37277",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bkietz&avatarId=37277"
                        },
                        "displayName": "Ben Kietzman",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-12-18T20:06:30.140+0000",
                    "updated": "2020-12-18T20:06:30.140+0000"
                }
            ],
            "maxResults": 1,
            "total": 1,
            "startAt": 0
        },
        "customfield_12311820": "0|z0jfp4:",
        "customfield_12314139": null
    }
}