{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13151618",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618",
    "key": "ARROW-2447",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12346687",
                "id": "12346687",
                "description": "",
                "name": "0.17.0",
                "archived": false,
                "released": true,
                "releaseDate": "2020-04-20"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": 0,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [
            {
                "id": "12553473",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12553473",
                "type": {
                    "id": "12310010",
                    "name": "Incorporates",
                    "inward": "is part of",
                    "outward": "incorporates",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310010"
                },
                "inwardIssue": {
                    "id": "13073522",
                    "key": "ARROW-1055",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13073522",
                    "fields": {
                        "summary": "[C++] GPU support library development",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
                            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
                            "name": "Resolved",
                            "id": "5",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12531516",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12531516",
                "type": {
                    "id": "10030",
                    "name": "Reference",
                    "inward": "is related to",
                    "outward": "relates to",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10030"
                },
                "outwardIssue": {
                    "id": "13151609",
                    "key": "ARROW-2446",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151609",
                    "fields": {
                        "summary": "[C++] SliceBuffer on CudaBuffer should return CudaBuffer",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12580834",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12580834",
                "type": {
                    "id": "12310051",
                    "name": "Supercedes",
                    "inward": "is superceded by",
                    "outward": "supercedes",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/12310051"
                },
                "outwardIssue": {
                    "id": "13100135",
                    "key": "ARROW-1470",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13100135",
                    "fields": {
                        "summary": "[C++] Add BufferAllocator abstract interface",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/2",
                            "id": "2",
                            "description": "A new feature of the product, which has yet to be developed.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21141&avatarType=issuetype",
                            "name": "New Feature",
                            "subtask": false,
                            "avatarId": 21141
                        }
                    }
                }
            },
            {
                "id": "12579662",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12579662",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13283003",
                    "key": "ARROW-7748",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13283003",
                    "fields": {
                        "summary": "[C++] [Cuda] Cache CUDA contexts",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/1",
                            "description": "The issue is open and ready for the assignee to start work on it.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/open.png",
                            "name": "Open",
                            "id": "1",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/2",
                                "id": 2,
                                "key": "new",
                                "colorName": "blue-gray",
                                "name": "To Do"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            },
            {
                "id": "12579435",
                "self": "https://issues.apache.org/jira/rest/api/2/issueLink/12579435",
                "type": {
                    "id": "10001",
                    "name": "dependent",
                    "inward": "is depended upon by",
                    "outward": "depends upon",
                    "self": "https://issues.apache.org/jira/rest/api/2/issueLinkType/10001"
                },
                "inwardIssue": {
                    "id": "13118806",
                    "key": "ARROW-1824",
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13118806",
                    "fields": {
                        "summary": "[C++] Add better GPU support for RecordBatch objects in arrow::ipc::*",
                        "status": {
                            "self": "https://issues.apache.org/jira/rest/api/2/status/6",
                            "description": "The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/closed.png",
                            "name": "Closed",
                            "id": "6",
                            "statusCategory": {
                                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                                "id": 3,
                                "key": "done",
                                "colorName": "green",
                                "name": "Done"
                            }
                        },
                        "priority": {
                            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
                            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
                            "name": "Major",
                            "id": "3"
                        },
                        "issuetype": {
                            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
                            "id": "4",
                            "description": "An improvement or enhancement to an existing feature or task.",
                            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
                            "name": "Improvement",
                            "subtask": false,
                            "avatarId": 21140
                        }
                    }
                }
            }
        ],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328935",
                "id": "12328935",
                "name": "C++"
            },
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12333104",
                "id": "12333104",
                "name": "GPU"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": 0,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "aggregateprogress": {
            "progress": 35400,
            "total": 35400,
            "percent": 100
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 35400,
            "total": 35400,
            "percent": 100
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2447/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 65,
            "worklogs": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/377833",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on pull request #6295: [WIP] ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295\n \n \n   Add an abstraction layer to allow safe handling of buffers residing on different devices (the CPU, a GPU...). \r\n   The API provides convenience functions to view or copy a buffer from one device to the other.\r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-27T20:15:45.797+0000",
                    "updated": "2020-01-27T20:15:45.797+0000",
                    "started": "2020-01-27T20:15:45.797+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "377833",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/377834",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6295: [WIP] ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-578932368\n \n \n   <!--\n     Licensed to the Apache Software Foundation (ASF) under one\n     or more contributor license agreements.  See the NOTICE file\n     distributed with this work for additional information\n     regarding copyright ownership.  The ASF licenses this file\n     to you under the Apache License, Version 2.0 (the\n     \"License\"); you may not use this file except in compliance\n     with the License.  You may obtain a copy of the License at\n   \n       http://www.apache.org/licenses/LICENSE-2.0\n   \n     Unless required by applicable law or agreed to in writing,\n     software distributed under the License is distributed on an\n     \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n     KIND, either express or implied.  See the License for the\n     specific language governing permissions and limitations\n     under the License.\n   -->\n   \n   Thanks for opening a pull request!\n   \n   Could you open an issue for this pull request on JIRA?\n   https://issues.apache.org/jira/browse/ARROW\n   \n   Then could you also rename pull request title in the following format?\n   \n       ARROW-${JIRA_ID}: [${COMPONENT}] ${SUMMARY}\n   \n   See also:\n   \n     * [Other pull requests](https://github.com/apache/arrow/pulls/)\n     * [Contribution Guidelines - How to contribute patches](https://arrow.apache.org/docs/developers/contributing.html#how-to-contribute-patches)\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-27T20:16:40.626+0000",
                    "updated": "2020-01-27T20:16:40.626+0000",
                    "started": "2020-01-27T20:16:40.626+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "377834",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/378169",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "github-actions[bot] commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-579207765\n \n \n   https://issues.apache.org/jira/browse/ARROW-2447\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-28T11:46:33.614+0000",
                    "updated": "2020-01-28T11:46:33.614+0000",
                    "started": "2020-01-28T11:46:33.614+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "378169",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/378507",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "wesm commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-579479868\n \n \n   As a preliminary, it would be helpful to know the microperformance implications on the zero-copy IPC hot path (i.e. the before/after of https://github.com/apache/arrow/blob/master/cpp/src/arrow/ipc/read_write_benchmark.cc)\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-28T22:04:15.842+0000",
                    "updated": "2020-01-28T22:04:15.842+0000",
                    "started": "2020-01-28T22:04:15.842+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "378507",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/378696",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-579682493\n \n \n   Ok, here are the benchmark results. It seems there is a slowdown on the read path:\r\n   * before:\r\n   ```\r\n   ------------------------------------------------------------------------------------------\r\n   Benchmark                                Time             CPU   Iterations UserCounters...\r\n   ------------------------------------------------------------------------------------------\r\n   WriteRecordBatch/1/real_time         57037 ns        57024 ns        49637 bytes_per_second=17.1216G/s\r\n   WriteRecordBatch/4/real_time         22435 ns        22431 ns       125916 bytes_per_second=43.528G/s\r\n   WriteRecordBatch/16/real_time        24192 ns        24187 ns       115458 bytes_per_second=40.3679G/s\r\n   WriteRecordBatch/64/real_time        32327 ns        32320 ns        84962 bytes_per_second=30.2088G/s\r\n   WriteRecordBatch/256/real_time       61745 ns        61732 ns        45951 bytes_per_second=15.816G/s\r\n   WriteRecordBatch/1024/real_time     180312 ns       180268 ns        15595 bytes_per_second=5.41596G/s\r\n   WriteRecordBatch/4096/real_time     642503 ns       642354 ns         4357 bytes_per_second=1.51993G/s\r\n   WriteRecordBatch/8192/real_time    1311063 ns      1310645 ns         1967 bytes_per_second=762.74M/s\r\n   ReadRecordBatch/1/real_time            916 ns          915 ns      3036262 bytes_per_second=1066.49G/s\r\n   ReadRecordBatch/4/real_time           1599 ns         1598 ns      1745660 bytes_per_second=610.904G/s\r\n   ReadRecordBatch/16/real_time          4614 ns         4613 ns       608964 bytes_per_second=211.637G/s\r\n   ReadRecordBatch/64/real_time         16549 ns        16546 ns       169957 bytes_per_second=59.0093G/s\r\n   ReadRecordBatch/256/real_time        78461 ns        78443 ns        36050 bytes_per_second=12.4465G/s\r\n   ReadRecordBatch/1024/real_time      313487 ns       313403 ns         9045 bytes_per_second=3.11516G/s\r\n   ReadRecordBatch/4096/real_time     1392722 ns      1392241 ns         2015 bytes_per_second=718.018M/s\r\n   ReadRecordBatch/8192/real_time     2754512 ns      2753567 ns         1023 bytes_per_second=363.041M/s\r\n   ```\r\n   * after:\r\n   ```\r\n   ------------------------------------------------------------------------------------------\r\n   Benchmark                                Time             CPU   Iterations UserCounters...\r\n   ------------------------------------------------------------------------------------------\r\n   WriteRecordBatch/1/real_time         56888 ns        56880 ns        49308 bytes_per_second=17.1665G/s\r\n   WriteRecordBatch/4/real_time         21998 ns        21995 ns       128021 bytes_per_second=44.3928G/s\r\n   WriteRecordBatch/16/real_time        24570 ns        24567 ns       115878 bytes_per_second=39.7461G/s\r\n   WriteRecordBatch/64/real_time        33321 ns        33315 ns        84767 bytes_per_second=29.308G/s\r\n   WriteRecordBatch/256/real_time       62866 ns        62856 ns        44577 bytes_per_second=15.534G/s\r\n   WriteRecordBatch/1024/real_time     182013 ns       181983 ns        15492 bytes_per_second=5.36534G/s\r\n   WriteRecordBatch/4096/real_time     653490 ns       653338 ns         4260 bytes_per_second=1.49438G/s\r\n   WriteRecordBatch/8192/real_time    1307078 ns      1306782 ns         2158 bytes_per_second=765.065M/s\r\n   ReadRecordBatch/1/real_time           1285 ns         1285 ns      2091915 bytes_per_second=759.691G/s\r\n   ReadRecordBatch/4/real_time           2082 ns         2082 ns      1327615 bytes_per_second=469.107G/s\r\n   ReadRecordBatch/16/real_time          5681 ns         5680 ns       490930 bytes_per_second=171.898G/s\r\n   ReadRecordBatch/64/real_time         20053 ns        20051 ns       100000 bytes_per_second=48.6979G/s\r\n   ReadRecordBatch/256/real_time        85744 ns        85733 ns        33086 bytes_per_second=11.3893G/s\r\n   ReadRecordBatch/1024/real_time      344091 ns       344038 ns         8083 bytes_per_second=2.8381G/s\r\n   ReadRecordBatch/4096/real_time     1394700 ns      1394456 ns         2034 bytes_per_second=717M/s\r\n   ReadRecordBatch/8192/real_time     2655597 ns      2655116 ns         1045 bytes_per_second=376.563M/s\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-29T10:03:23.366+0000",
                    "updated": "2020-01-29T10:03:23.366+0000",
                    "started": "2020-01-29T10:03:23.366+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "378696",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/379481",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-580350074\n \n \n   @kou You may want to take a look.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-30T16:55:54.541+0000",
                    "updated": "2020-01-30T16:55:54.541+0000",
                    "started": "2020-01-30T16:55:54.541+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "379481",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/379631",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-580481093\n \n \n   Thanks for pinging me. I'll take a look this later.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-30T21:59:53.819+0000",
                    "updated": "2020-01-30T21:59:53.819+0000",
                    "started": "2020-01-30T21:59:53.819+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "379631",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/379633",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "dhirschfeld commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-580483100\n \n \n   This seems similar in concept to umem?\r\n   https://github.com/xnd-project/umem\r\n   \r\n   Just wondering if there is anything to share between the implementations\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-30T22:04:38.562+0000",
                    "updated": "2020-01-30T22:04:38.562+0000",
                    "started": "2020-01-30T22:04:38.560+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "379633",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380212",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "pitrou commented on issue #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#issuecomment-580918840\n \n \n   @dhirschfeld It seems so, though `umem` seems lower-level. Perhaps @pearu can chime in, he's the author.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-01-31T21:28:46.944+0000",
                    "updated": "2020-01-31T21:28:46.944+0000",
                    "started": "2020-01-31T21:28:46.943+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380212",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380390",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373802408\n \n \n\n ##########\n File path: cpp/src/arrow/buffer.h\n ##########\n @@ -178,16 +200,46 @@ class ARROW_EXPORT Buffer {\n   explicit operator util::bytes_view() const { return util::bytes_view(data_, size_); }\n \n   /// \\brief Return a pointer to the buffer's data\n-  const uint8_t* data() const { return data_; }\n+  ///\n+  /// The buffer has to be a CPU buffer (`is_cpu()` is true).\n+  /// Otherwise, an assertion may be thrown or a null pointer may be returned.\n+  ///\n+  /// To get the buffer's data address regardless of its device, call `address()`.\n+  const uint8_t* data() const {\n+#ifndef NDEBUG\n+    CheckCPU();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? data_ : NULLPTR;\n+  }\n+\n   /// \\brief Return a writable pointer to the buffer's data\n   ///\n-  /// The buffer has to be mutable.  Otherwise, an assertion may be thrown\n-  /// or a null pointer may be returned.\n+  /// The buffer has to be a mutable CPU buffer (`is_cpu()` and `is_mutable()`\n+  /// are true).  Otherwise, an assertion may be thrown or a null pointer may\n+  /// be returned.\n+  ///\n+  /// To get the buffer's mutable data address regardless of its device, call\n+  /// `mutable_address()`.\n   uint8_t* mutable_data() {\n+#ifndef NDEBUG\n+    CheckCPU();\n+    CheckMutable();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? mutable_data_ : NULLPTR;\n+  }\n+\n+  /// \\brief Return the device address of the buffer's data\n+  uintptr_t address() const { return reinterpret_cast<uintptr_t>(data_); }\n+\n+  /// \\brief Return a writable device address to the buffer's data\n+  ///\n+  /// The buffer has to be a mutable CPU buffer (`is_mutable()` is true).\n \n Review comment:\n   \"`is_cpu()` and `is_mutable()` are true\"?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:06.409+0000",
                    "updated": "2020-02-02T00:02:06.409+0000",
                    "started": "2020-02-02T00:02:06.408+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380390",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380391",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373805787\n \n \n\n ##########\n File path: cpp/src/arrow/gpu/cuda_context.cc\n ##########\n @@ -176,73 +208,280 @@ class CudaContext::CudaContextImpl {\n   std::atomic<int64_t> bytes_allocated_;\n };\n \n-class CudaDeviceManager::CudaDeviceManagerImpl {\n+// ----------------------------------------------------------------------\n+// CudaDevice implementation\n+\n+CudaDevice::CudaDevice(Impl impl) : impl_(new Impl(std::move(impl))) {}\n+\n+const char* CudaDevice::type_name() const { return kCudaDeviceTypeName; }\n+\n+std::string CudaDevice::ToString() const {\n+  std::stringstream ss;\n+  ss << \"CudaDevice(device_number=\" << device_number() << \", name=\\\"\" << device_name()\n+     << \"\\\")\";\n+  return ss.str();\n+}\n+\n+bool CudaDevice::Equals(const Device& other) const {\n+  if (!IsCudaDevice(other)) {\n+    return false;\n+  }\n+  return checked_cast<const CudaDevice&>(other).device_number() == device_number();\n+}\n+\n+int CudaDevice::device_number() const { return impl_->props.device_number_; }\n+\n+std::string CudaDevice::device_name() const { return impl_->props.name_; }\n+\n+int64_t CudaDevice::total_memory() const { return impl_->props.total_memory_; }\n+\n+int CudaDevice::handle() const { return impl_->props.handle_; }\n+\n+Result<std::shared_ptr<CudaDevice>> CudaDevice::Make(int device_number) {\n+  ARROW_ASSIGN_OR_RAISE(auto manager, CudaDeviceManager::Instance());\n+  return manager->GetDevice(device_number);\n+}\n+\n+std::shared_ptr<MemoryManager> CudaDevice::default_memory_manager() {\n+  return CudaMemoryManager::Make(shared_from_this());\n+}\n+\n+Result<std::shared_ptr<CudaContext>> CudaDevice::GetContext() {\n+  // XXX should we cache a default context in CudaDevice instance?\n \n Review comment:\n   I think so.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:06.477+0000",
                    "updated": "2020-02-02T00:02:06.477+0000",
                    "started": "2020-02-02T00:02:06.477+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380391",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380392",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373802352\n \n \n\n ##########\n File path: cpp/src/arrow/buffer.h\n ##########\n @@ -178,16 +200,46 @@ class ARROW_EXPORT Buffer {\n   explicit operator util::bytes_view() const { return util::bytes_view(data_, size_); }\n \n   /// \\brief Return a pointer to the buffer's data\n-  const uint8_t* data() const { return data_; }\n+  ///\n+  /// The buffer has to be a CPU buffer (`is_cpu()` is true).\n+  /// Otherwise, an assertion may be thrown or a null pointer may be returned.\n+  ///\n+  /// To get the buffer's data address regardless of its device, call `address()`.\n+  const uint8_t* data() const {\n+#ifndef NDEBUG\n+    CheckCPU();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? data_ : NULLPTR;\n+  }\n+\n   /// \\brief Return a writable pointer to the buffer's data\n   ///\n-  /// The buffer has to be mutable.  Otherwise, an assertion may be thrown\n-  /// or a null pointer may be returned.\n+  /// The buffer has to be a mutable CPU buffer (`is_cpu()` and `is_mutable()`\n+  /// are true).  Otherwise, an assertion may be thrown or a null pointer may\n+  /// be returned.\n+  ///\n+  /// To get the buffer's mutable data address regardless of its device, call\n+  /// `mutable_address()`.\n   uint8_t* mutable_data() {\n+#ifndef NDEBUG\n+    CheckCPU();\n+    CheckMutable();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? mutable_data_ : NULLPTR;\n+  }\n+\n+  /// \\brief Return the device address of the buffer's data\n+  uintptr_t address() const { return reinterpret_cast<uintptr_t>(data_); }\n+\n+  /// \\brief Return a writable device address to the buffer's data\n+  ///\n+  /// The buffer has to be a mutable CPU buffer (`is_mutable()` is true).\n+  /// Otherwise, an assertion may be thrown or a null pointer may be returned.\n+  uintptr_t mutable_address() const {\n #ifndef NDEBUG\n     CheckMutable();\n #endif\n-    return mutable_data_;\n+    return reinterpret_cast<uintptr_t>(mutable_data_);\n \n Review comment:\n   How about using `reinterpret_cast<uintptr_t>(mutable_data())` and remove the assertion in this method?\r\n   \n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:06.574+0000",
                    "updated": "2020-02-02T00:02:06.574+0000",
                    "started": "2020-02-02T00:02:06.573+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380392",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380393",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373803432\n \n \n\n ##########\n File path: cpp/src/arrow/device.cc\n ##########\n @@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/device.h\"\n+\n+#include <cstring>\n+#include <utility>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+MemoryManager::~MemoryManager() {}\n+\n+Device::~Device() {}\n+\n+#define COPY_BUFFER_SUCCESS(maybe_buffer) \\\n+  ((maybe_buffer).ok() && *(maybe_buffer) != nullptr)\n+\n+#define COPY_BUFFER_RETURN(maybe_buffer, to)              \\\n+  if (!maybe_buffer.ok()) {                               \\\n+    return maybe_buffer;                                  \\\n+  }                                                       \\\n+  if (COPY_BUFFER_SUCCESS(maybe_buffer)) {                \\\n+    DCHECK_EQ(*(**maybe_buffer).device(), *to->device()); \\\n+    return maybe_buffer;                                  \\\n+  }\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->CopyBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support copying from `from`, try the other way\n+  maybe_buffer = from->CopyBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  if (!from->is_cpu() && !to->is_cpu()) {\n+    // Try an intermediate view on the CPU\n+    auto cpu_mm = default_cpu_memory_manager();\n+    maybe_buffer = from->ViewBufferTo(buf, cpu_mm);\n+    if (!COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // View failed, try a copy instead\n+      // XXX should we have a MemoryManager::IsCopySupportedTo(MemoryManager)\n+      // to avoid copying to CPU if copy from CPU to dest is unsupported?\n+      maybe_buffer = from->CopyBufferTo(buf, cpu_mm);\n+    }\n+    if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // Copy from source to CPU succeeded, now try to copy from CPU into dest\n+      maybe_buffer = to->CopyBufferFrom(*maybe_buffer, cpu_mm);\n+      if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+        return maybe_buffer;\n+      }\n+    }\n+  }\n+\n+  return Status::NotImplemented(\"Copying buffer from \", from->device()->ToString(),\n+                                \" to \", to->device()->ToString(), \" not supported\");\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->ViewBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support viewing from `from`, try the other way\n+  maybe_buffer = from->ViewBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+\n+  return Status::NotImplemented(\"Viewing buffer from \", from->device()->ToString(),\n+                                \" on \", to->device()->ToString(), \" not supported\");\n+}\n+\n+#undef COPY_BUFFER_RETURN\n+#undef COPY_BUFFER_SUCCESS\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+// ----------------------------------------------------------------------\n+// CPU backend implementation\n+\n+namespace {\n+const char kCPUDeviceTypeName[] = \"arrow::CPUDevice\";\n+}\n+\n+std::shared_ptr<MemoryManager> CPUMemoryManager::Make(\n+    const std::shared_ptr<Device>& device, MemoryPool* pool) {\n+  return std::shared_ptr<MemoryManager>(\n+      new CPUMemoryManager(CPUDevice::Instance(), pool));\n \n Review comment:\n   Why is the given `device` not used?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:06.793+0000",
                    "updated": "2020-02-02T00:02:06.793+0000",
                    "started": "2020-02-02T00:02:06.793+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380393",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380394",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373802295\n \n \n\n ##########\n File path: cpp/src/arrow/buffer.h\n ##########\n @@ -178,16 +200,46 @@ class ARROW_EXPORT Buffer {\n   explicit operator util::bytes_view() const { return util::bytes_view(data_, size_); }\n \n   /// \\brief Return a pointer to the buffer's data\n-  const uint8_t* data() const { return data_; }\n+  ///\n+  /// The buffer has to be a CPU buffer (`is_cpu()` is true).\n+  /// Otherwise, an assertion may be thrown or a null pointer may be returned.\n+  ///\n+  /// To get the buffer's data address regardless of its device, call `address()`.\n+  const uint8_t* data() const {\n+#ifndef NDEBUG\n+    CheckCPU();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? data_ : NULLPTR;\n+  }\n+\n   /// \\brief Return a writable pointer to the buffer's data\n   ///\n-  /// The buffer has to be mutable.  Otherwise, an assertion may be thrown\n-  /// or a null pointer may be returned.\n+  /// The buffer has to be a mutable CPU buffer (`is_cpu()` and `is_mutable()`\n+  /// are true).  Otherwise, an assertion may be thrown or a null pointer may\n+  /// be returned.\n+  ///\n+  /// To get the buffer's mutable data address regardless of its device, call\n+  /// `mutable_address()`.\n   uint8_t* mutable_data() {\n+#ifndef NDEBUG\n+    CheckCPU();\n+    CheckMutable();\n+#endif\n+    return ARROW_PREDICT_TRUE(is_cpu_) ? mutable_data_ : NULLPTR;\n+  }\n+\n+  /// \\brief Return the device address of the buffer's data\n+  uintptr_t address() const { return reinterpret_cast<uintptr_t>(data_); }\n+\n+  /// \\brief Return a writable device address to the buffer's data\n+  ///\n+  /// The buffer has to be a mutable CPU buffer (`is_mutable()` is true).\n+  /// Otherwise, an assertion may be thrown or a null pointer may be returned.\n \n Review comment:\n   `null pointer` -> `0`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.046+0000",
                    "updated": "2020-02-02T00:02:07.046+0000",
                    "started": "2020-02-02T00:02:07.046+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380394",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380395",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373804293\n \n \n\n ##########\n File path: cpp/src/arrow/device.cc\n ##########\n @@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/device.h\"\n+\n+#include <cstring>\n+#include <utility>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+MemoryManager::~MemoryManager() {}\n+\n+Device::~Device() {}\n+\n+#define COPY_BUFFER_SUCCESS(maybe_buffer) \\\n+  ((maybe_buffer).ok() && *(maybe_buffer) != nullptr)\n+\n+#define COPY_BUFFER_RETURN(maybe_buffer, to)              \\\n+  if (!maybe_buffer.ok()) {                               \\\n+    return maybe_buffer;                                  \\\n+  }                                                       \\\n+  if (COPY_BUFFER_SUCCESS(maybe_buffer)) {                \\\n+    DCHECK_EQ(*(**maybe_buffer).device(), *to->device()); \\\n+    return maybe_buffer;                                  \\\n+  }\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->CopyBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support copying from `from`, try the other way\n+  maybe_buffer = from->CopyBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  if (!from->is_cpu() && !to->is_cpu()) {\n+    // Try an intermediate view on the CPU\n+    auto cpu_mm = default_cpu_memory_manager();\n+    maybe_buffer = from->ViewBufferTo(buf, cpu_mm);\n+    if (!COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // View failed, try a copy instead\n+      // XXX should we have a MemoryManager::IsCopySupportedTo(MemoryManager)\n+      // to avoid copying to CPU if copy from CPU to dest is unsupported?\n+      maybe_buffer = from->CopyBufferTo(buf, cpu_mm);\n+    }\n+    if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // Copy from source to CPU succeeded, now try to copy from CPU into dest\n+      maybe_buffer = to->CopyBufferFrom(*maybe_buffer, cpu_mm);\n+      if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+        return maybe_buffer;\n+      }\n+    }\n+  }\n+\n+  return Status::NotImplemented(\"Copying buffer from \", from->device()->ToString(),\n+                                \" to \", to->device()->ToString(), \" not supported\");\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->ViewBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support viewing from `from`, try the other way\n+  maybe_buffer = from->ViewBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+\n+  return Status::NotImplemented(\"Viewing buffer from \", from->device()->ToString(),\n+                                \" on \", to->device()->ToString(), \" not supported\");\n+}\n+\n+#undef COPY_BUFFER_RETURN\n+#undef COPY_BUFFER_SUCCESS\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+// ----------------------------------------------------------------------\n+// CPU backend implementation\n+\n+namespace {\n+const char kCPUDeviceTypeName[] = \"arrow::CPUDevice\";\n+}\n+\n+std::shared_ptr<MemoryManager> CPUMemoryManager::Make(\n+    const std::shared_ptr<Device>& device, MemoryPool* pool) {\n+  return std::shared_ptr<MemoryManager>(\n+      new CPUMemoryManager(CPUDevice::Instance(), pool));\n+}\n+\n+Result<std::shared_ptr<io::RandomAccessFile>> CPUMemoryManager::GetBufferReader(\n+    std::shared_ptr<Buffer> buf) {\n+  return std::make_shared<io::BufferReader>(std::move(buf));\n+}\n+\n+Result<std::shared_ptr<io::OutputStream>> CPUMemoryManager::GetBufferWriter(\n+    std::shared_ptr<Buffer> buf) {\n+  return std::make_shared<io::FixedSizeBufferWriter>(std::move(buf));\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::AllocateBuffer(int64_t size) {\n+  std::shared_ptr<Buffer> buf;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, size, &buf));\n+  return buf;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::CopyBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  if (!from->is_cpu()) {\n+    return nullptr;\n+  }\n+  std::shared_ptr<Buffer> dest;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, buf->size(), &dest));\n+  if (buf->size() > 0) {\n+    memcpy(dest->mutable_data(), buf->data(), static_cast<size_t>(buf->size()));\n+  }\n+  return dest;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::ViewBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  if (!from->is_cpu()) {\n+    return nullptr;\n+  }\n+  return buf;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  if (!to->is_cpu()) {\n+    return nullptr;\n+  }\n+  std::shared_ptr<Buffer> dest;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, buf->size(), &dest));\n+  if (buf->size() > 0) {\n+    memcpy(dest->mutable_data(), buf->data(), static_cast<size_t>(buf->size()));\n+  }\n+  return dest;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::ViewBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  if (!to->is_cpu()) {\n+    return nullptr;\n+  }\n+  return buf;\n+}\n+\n+std::shared_ptr<MemoryManager> default_cpu_memory_manager() {\n+  static auto instance =\n+      CPUMemoryManager::Make(CPUDevice::Instance(), default_memory_pool());\n \n Review comment:\n   `CPUDevice::memory_manager(default_memory_pool())` may be better to share implementation.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.194+0000",
                    "updated": "2020-02-02T00:02:07.194+0000",
                    "started": "2020-02-02T00:02:07.194+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380395",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380396",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373804885\n \n \n\n ##########\n File path: cpp/src/arrow/device.cc\n ##########\n @@ -0,0 +1,211 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include \"arrow/device.h\"\n+\n+#include <cstring>\n+#include <utility>\n+\n+#include \"arrow/buffer.h\"\n+#include \"arrow/io/memory.h\"\n+#include \"arrow/result.h\"\n+#include \"arrow/util/logging.h\"\n+\n+namespace arrow {\n+\n+MemoryManager::~MemoryManager() {}\n+\n+Device::~Device() {}\n+\n+#define COPY_BUFFER_SUCCESS(maybe_buffer) \\\n+  ((maybe_buffer).ok() && *(maybe_buffer) != nullptr)\n+\n+#define COPY_BUFFER_RETURN(maybe_buffer, to)              \\\n+  if (!maybe_buffer.ok()) {                               \\\n+    return maybe_buffer;                                  \\\n+  }                                                       \\\n+  if (COPY_BUFFER_SUCCESS(maybe_buffer)) {                \\\n+    DCHECK_EQ(*(**maybe_buffer).device(), *to->device()); \\\n+    return maybe_buffer;                                  \\\n+  }\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->CopyBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support copying from `from`, try the other way\n+  maybe_buffer = from->CopyBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  if (!from->is_cpu() && !to->is_cpu()) {\n+    // Try an intermediate view on the CPU\n+    auto cpu_mm = default_cpu_memory_manager();\n+    maybe_buffer = from->ViewBufferTo(buf, cpu_mm);\n+    if (!COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // View failed, try a copy instead\n+      // XXX should we have a MemoryManager::IsCopySupportedTo(MemoryManager)\n+      // to avoid copying to CPU if copy from CPU to dest is unsupported?\n+      maybe_buffer = from->CopyBufferTo(buf, cpu_mm);\n+    }\n+    if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+      // Copy from source to CPU succeeded, now try to copy from CPU into dest\n+      maybe_buffer = to->CopyBufferFrom(*maybe_buffer, cpu_mm);\n+      if (COPY_BUFFER_SUCCESS(maybe_buffer)) {\n+        return maybe_buffer;\n+      }\n+    }\n+  }\n+\n+  return Status::NotImplemented(\"Copying buffer from \", from->device()->ToString(),\n+                                \" to \", to->device()->ToString(), \" not supported\");\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBuffer(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  const auto& from = buf->memory_manager();\n+  auto maybe_buffer = to->ViewBufferFrom(buf, from);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+  // `to` doesn't support viewing from `from`, try the other way\n+  maybe_buffer = from->ViewBufferTo(buf, to);\n+  COPY_BUFFER_RETURN(maybe_buffer, to);\n+\n+  return Status::NotImplemented(\"Viewing buffer from \", from->device()->ToString(),\n+                                \" on \", to->device()->ToString(), \" not supported\");\n+}\n+\n+#undef COPY_BUFFER_RETURN\n+#undef COPY_BUFFER_SUCCESS\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  return nullptr;\n+}\n+\n+Result<std::shared_ptr<Buffer>> MemoryManager::ViewBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  return nullptr;\n+}\n+\n+// ----------------------------------------------------------------------\n+// CPU backend implementation\n+\n+namespace {\n+const char kCPUDeviceTypeName[] = \"arrow::CPUDevice\";\n+}\n+\n+std::shared_ptr<MemoryManager> CPUMemoryManager::Make(\n+    const std::shared_ptr<Device>& device, MemoryPool* pool) {\n+  return std::shared_ptr<MemoryManager>(\n+      new CPUMemoryManager(CPUDevice::Instance(), pool));\n+}\n+\n+Result<std::shared_ptr<io::RandomAccessFile>> CPUMemoryManager::GetBufferReader(\n+    std::shared_ptr<Buffer> buf) {\n+  return std::make_shared<io::BufferReader>(std::move(buf));\n+}\n+\n+Result<std::shared_ptr<io::OutputStream>> CPUMemoryManager::GetBufferWriter(\n+    std::shared_ptr<Buffer> buf) {\n+  return std::make_shared<io::FixedSizeBufferWriter>(std::move(buf));\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::AllocateBuffer(int64_t size) {\n+  std::shared_ptr<Buffer> buf;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, size, &buf));\n+  return buf;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::CopyBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  if (!from->is_cpu()) {\n+    return nullptr;\n+  }\n+  std::shared_ptr<Buffer> dest;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, buf->size(), &dest));\n+  if (buf->size() > 0) {\n+    memcpy(dest->mutable_data(), buf->data(), static_cast<size_t>(buf->size()));\n+  }\n+  return dest;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::ViewBufferFrom(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& from) {\n+  if (!from->is_cpu()) {\n+    return nullptr;\n+  }\n+  return buf;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  if (!to->is_cpu()) {\n+    return nullptr;\n+  }\n+  std::shared_ptr<Buffer> dest;\n+  RETURN_NOT_OK(::arrow::AllocateBuffer(pool_, buf->size(), &dest));\n+  if (buf->size() > 0) {\n+    memcpy(dest->mutable_data(), buf->data(), static_cast<size_t>(buf->size()));\n+  }\n+  return dest;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CPUMemoryManager::ViewBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  if (!to->is_cpu()) {\n+    return nullptr;\n+  }\n+  return buf;\n+}\n+\n+std::shared_ptr<MemoryManager> default_cpu_memory_manager() {\n+  static auto instance =\n+      CPUMemoryManager::Make(CPUDevice::Instance(), default_memory_pool());\n+  return instance;\n+}\n+\n+std::shared_ptr<Device> CPUDevice::Instance() {\n+  static auto instance = std::shared_ptr<Device>(new CPUDevice());\n+  return instance;\n+}\n+\n+const char* CPUDevice::type_name() const { return kCPUDeviceTypeName; }\n+\n+std::string CPUDevice::ToString() const { return \"CPUDevice()\"; }\n+\n+bool CPUDevice::Equals(const Device& other) const {\n+  return other.type_name() == kCPUDeviceTypeName;\n+}\n+\n+std::shared_ptr<MemoryManager> CPUDevice::memory_manager(MemoryPool* pool) {\n+  return CPUMemoryManager::Make(Instance(), pool);\n+}\n+\n+std::shared_ptr<MemoryManager> CPUDevice::default_memory_manager() {\n+  return default_cpu_memory_manager();\n \n Review comment:\n   I know we can't write `CPUMemoryManager::Make(shared_from_this(), default_memory_pool())` here but I think that creating a `CPUMemoryManager` from this instance (and `CPUDevice::default_cpu_memory_manager()` calls `Instance()->default_memory_manager()`) is better because this is an instance method. Using this instance for `device` instead of singleton instance is straightforward.\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.254+0000",
                    "updated": "2020-02-02T00:02:07.254+0000",
                    "started": "2020-02-02T00:02:07.253+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380396",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380397",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373807151\n \n \n\n ##########\n File path: cpp/src/arrow/ipc/writer.cc\n ##########\n @@ -1270,6 +1270,27 @@ Result<std::unique_ptr<RecordBatchWriter>> OpenRecordBatchWriter(\n // ----------------------------------------------------------------------\n // Serialization public APIs\n \n+Result<std::shared_ptr<Buffer>> SerializeRecordBatch(const RecordBatch& batch,\n+                                                     std::shared_ptr<MemoryManager> mm) {\n+  int64_t size = 0;\n+  RETURN_NOT_OK(GetRecordBatchSize(batch, &size));\n+  ARROW_ASSIGN_OR_RAISE(auto buffer, mm->AllocateBuffer(size));\n+  ARROW_ASSIGN_OR_RAISE(auto writer, mm->GetBufferWriter(buffer));\n+\n+  MemoryPool* pool;\n+  // XXX Should we have a helper function for getting a MemoryPool\n+  // for any MemoryManager (not only CPU)?\n+  if (mm->is_cpu()) {\n+    pool = checked_cast<CPUMemoryManager*>(mm.get())->pool();\n \n Review comment:\n   `checked_pointer_cast<CPUMemoryManager>(mm)->pool()`?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.257+0000",
                    "updated": "2020-02-02T00:02:07.257+0000",
                    "started": "2020-02-02T00:02:07.257+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380397",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380398",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373806029\n \n \n\n ##########\n File path: cpp/src/arrow/gpu/cuda_context.cc\n ##########\n @@ -176,73 +208,280 @@ class CudaContext::CudaContextImpl {\n   std::atomic<int64_t> bytes_allocated_;\n };\n \n-class CudaDeviceManager::CudaDeviceManagerImpl {\n+// ----------------------------------------------------------------------\n+// CudaDevice implementation\n+\n+CudaDevice::CudaDevice(Impl impl) : impl_(new Impl(std::move(impl))) {}\n+\n+const char* CudaDevice::type_name() const { return kCudaDeviceTypeName; }\n+\n+std::string CudaDevice::ToString() const {\n+  std::stringstream ss;\n+  ss << \"CudaDevice(device_number=\" << device_number() << \", name=\\\"\" << device_name()\n+     << \"\\\")\";\n+  return ss.str();\n+}\n+\n+bool CudaDevice::Equals(const Device& other) const {\n+  if (!IsCudaDevice(other)) {\n+    return false;\n+  }\n+  return checked_cast<const CudaDevice&>(other).device_number() == device_number();\n+}\n+\n+int CudaDevice::device_number() const { return impl_->props.device_number_; }\n+\n+std::string CudaDevice::device_name() const { return impl_->props.name_; }\n+\n+int64_t CudaDevice::total_memory() const { return impl_->props.total_memory_; }\n+\n+int CudaDevice::handle() const { return impl_->props.handle_; }\n+\n+Result<std::shared_ptr<CudaDevice>> CudaDevice::Make(int device_number) {\n+  ARROW_ASSIGN_OR_RAISE(auto manager, CudaDeviceManager::Instance());\n+  return manager->GetDevice(device_number);\n+}\n+\n+std::shared_ptr<MemoryManager> CudaDevice::default_memory_manager() {\n+  return CudaMemoryManager::Make(shared_from_this());\n+}\n+\n+Result<std::shared_ptr<CudaContext>> CudaDevice::GetContext() {\n+  // XXX should we cache a default context in CudaDevice instance?\n+  auto context = std::shared_ptr<CudaContext>(new CudaContext());\n+  auto self = checked_pointer_cast<CudaDevice>(shared_from_this());\n+  RETURN_NOT_OK(context->impl_->Init(self));\n+  return context;\n+}\n+\n+Result<std::shared_ptr<CudaContext>> CudaDevice::GetSharedContext(void* handle) {\n+  auto context = std::shared_ptr<CudaContext>(new CudaContext());\n+  auto self = checked_pointer_cast<CudaDevice>(shared_from_this());\n+  RETURN_NOT_OK(context->impl_->InitShared(self, reinterpret_cast<CUcontext>(handle)));\n+  return context;\n+}\n+\n+Result<std::shared_ptr<CudaHostBuffer>> CudaDevice::AllocateHostBuffer(int64_t size) {\n+  ARROW_ASSIGN_OR_RAISE(auto context, GetContext());\n+  ContextSaver set_temporary(*context);\n+  void* ptr;\n+  CU_RETURN_NOT_OK(\"cuMemHostAlloc\", cuMemHostAlloc(&ptr, static_cast<size_t>(size),\n+                                                    CU_MEMHOSTALLOC_PORTABLE));\n+  return std::make_shared<CudaHostBuffer>(reinterpret_cast<uint8_t*>(ptr), size);\n+}\n+\n+bool IsCudaDevice(const Device& device) {\n+  return device.type_name() == kCudaDeviceTypeName;\n+}\n+\n+Result<std::shared_ptr<CudaDevice>> AsCudaDevice(const std::shared_ptr<Device>& device) {\n+  if (IsCudaDevice(*device)) {\n+    return checked_pointer_cast<CudaDevice>(device);\n+  } else {\n+    return Status::TypeError(\"Device is not a Cuda device: \", device->ToString());\n+  }\n+}\n+\n+// ----------------------------------------------------------------------\n+// CudaMemoryManager implementation\n+\n+std::shared_ptr<CudaMemoryManager> CudaMemoryManager::Make(\n+    const std::shared_ptr<Device>& device) {\n+  return std::shared_ptr<CudaMemoryManager>(new CudaMemoryManager(device));\n+}\n+\n+std::shared_ptr<CudaDevice> CudaMemoryManager::cuda_device() const {\n+  return checked_pointer_cast<CudaDevice>(device_);\n+}\n+\n+Result<std::shared_ptr<io::RandomAccessFile>> CudaMemoryManager::GetBufferReader(\n+    std::shared_ptr<Buffer> buf) {\n+  if (*buf->device() != *device_) {\n+    return Status::Invalid(\"CudaMemoryManager::GetBufferReader called on foreign buffer\");\n+  }\n+  return std::make_shared<CudaBufferReader>(checked_pointer_cast<CudaBuffer>(buf));\n+}\n+\n+Result<std::shared_ptr<io::OutputStream>> CudaMemoryManager::GetBufferWriter(\n+    std::shared_ptr<Buffer> buf) {\n+  if (*buf->device() != *device_) {\n+    return Status::Invalid(\"CudaMemoryManager::GetBufferWriter called on foreign buffer\");\n+  }\n+  std::shared_ptr<CudaBuffer> cuda_buf;\n+  RETURN_NOT_OK(CudaBuffer::FromBuffer(buf, &cuda_buf));\n+  auto writer = std::make_shared<CudaBufferWriter>(cuda_buf);\n+  // Use 8MB buffering, which yields generally good performance\n+  RETURN_NOT_OK(writer->SetBufferSize(1 << 23));\n+  return writer;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CudaMemoryManager::AllocateBuffer(int64_t size) {\n+  ARROW_ASSIGN_OR_RAISE(auto context, cuda_device()->GetContext());\n+  std::shared_ptr<CudaBuffer> dest;\n+  RETURN_NOT_OK(context->Allocate(size, &dest));\n+  return dest;\n+}\n+\n+Result<std::shared_ptr<Buffer>> CudaMemoryManager::CopyBufferTo(\n+    const std::shared_ptr<Buffer>& buf, const std::shared_ptr<MemoryManager>& to) {\n+  if (to->is_cpu()) {\n+    // Device-to-CPU copy\n+    std::shared_ptr<Buffer> dest;\n+    ARROW_ASSIGN_OR_RAISE(auto from_context, cuda_device()->GetContext());\n+    ARROW_ASSIGN_OR_RAISE(dest, to->AllocateBuffer(buf->size()));\n+    RETURN_NOT_OK(from_context->CopyDeviceToHost(dest->mutable_data(), buf->address(),\n+                                                 buf->size()));\n+    return dest;\n+  }\n \n Review comment:\n   Device-to-device copy logic is missing?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.260+0000",
                    "updated": "2020-02-02T00:02:07.260+0000",
                    "started": "2020-02-02T00:02:07.259+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380398",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380399",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373805947\n \n \n\n ##########\n File path: cpp/src/arrow/gpu/cuda_context.cc\n ##########\n @@ -176,73 +208,280 @@ class CudaContext::CudaContextImpl {\n   std::atomic<int64_t> bytes_allocated_;\n };\n \n-class CudaDeviceManager::CudaDeviceManagerImpl {\n+// ----------------------------------------------------------------------\n+// CudaDevice implementation\n+\n+CudaDevice::CudaDevice(Impl impl) : impl_(new Impl(std::move(impl))) {}\n+\n+const char* CudaDevice::type_name() const { return kCudaDeviceTypeName; }\n+\n+std::string CudaDevice::ToString() const {\n+  std::stringstream ss;\n+  ss << \"CudaDevice(device_number=\" << device_number() << \", name=\\\"\" << device_name()\n+     << \"\\\")\";\n+  return ss.str();\n+}\n+\n+bool CudaDevice::Equals(const Device& other) const {\n+  if (!IsCudaDevice(other)) {\n+    return false;\n+  }\n+  return checked_cast<const CudaDevice&>(other).device_number() == device_number();\n+}\n+\n+int CudaDevice::device_number() const { return impl_->props.device_number_; }\n+\n+std::string CudaDevice::device_name() const { return impl_->props.name_; }\n+\n+int64_t CudaDevice::total_memory() const { return impl_->props.total_memory_; }\n+\n+int CudaDevice::handle() const { return impl_->props.handle_; }\n+\n+Result<std::shared_ptr<CudaDevice>> CudaDevice::Make(int device_number) {\n+  ARROW_ASSIGN_OR_RAISE(auto manager, CudaDeviceManager::Instance());\n+  return manager->GetDevice(device_number);\n+}\n+\n+std::shared_ptr<MemoryManager> CudaDevice::default_memory_manager() {\n+  return CudaMemoryManager::Make(shared_from_this());\n+}\n+\n+Result<std::shared_ptr<CudaContext>> CudaDevice::GetContext() {\n+  // XXX should we cache a default context in CudaDevice instance?\n+  auto context = std::shared_ptr<CudaContext>(new CudaContext());\n+  auto self = checked_pointer_cast<CudaDevice>(shared_from_this());\n+  RETURN_NOT_OK(context->impl_->Init(self));\n+  return context;\n+}\n+\n+Result<std::shared_ptr<CudaContext>> CudaDevice::GetSharedContext(void* handle) {\n+  auto context = std::shared_ptr<CudaContext>(new CudaContext());\n+  auto self = checked_pointer_cast<CudaDevice>(shared_from_this());\n+  RETURN_NOT_OK(context->impl_->InitShared(self, reinterpret_cast<CUcontext>(handle)));\n+  return context;\n+}\n+\n+Result<std::shared_ptr<CudaHostBuffer>> CudaDevice::AllocateHostBuffer(int64_t size) {\n+  ARROW_ASSIGN_OR_RAISE(auto context, GetContext());\n+  ContextSaver set_temporary(*context);\n+  void* ptr;\n+  CU_RETURN_NOT_OK(\"cuMemHostAlloc\", cuMemHostAlloc(&ptr, static_cast<size_t>(size),\n+                                                    CU_MEMHOSTALLOC_PORTABLE));\n+  return std::make_shared<CudaHostBuffer>(reinterpret_cast<uint8_t*>(ptr), size);\n+}\n+\n+bool IsCudaDevice(const Device& device) {\n+  return device.type_name() == kCudaDeviceTypeName;\n+}\n+\n+Result<std::shared_ptr<CudaDevice>> AsCudaDevice(const std::shared_ptr<Device>& device) {\n+  if (IsCudaDevice(*device)) {\n+    return checked_pointer_cast<CudaDevice>(device);\n+  } else {\n+    return Status::TypeError(\"Device is not a Cuda device: \", device->ToString());\n+  }\n+}\n+\n+// ----------------------------------------------------------------------\n+// CudaMemoryManager implementation\n+\n+std::shared_ptr<CudaMemoryManager> CudaMemoryManager::Make(\n+    const std::shared_ptr<Device>& device) {\n+  return std::shared_ptr<CudaMemoryManager>(new CudaMemoryManager(device));\n+}\n+\n+std::shared_ptr<CudaDevice> CudaMemoryManager::cuda_device() const {\n+  return checked_pointer_cast<CudaDevice>(device_);\n+}\n+\n+Result<std::shared_ptr<io::RandomAccessFile>> CudaMemoryManager::GetBufferReader(\n+    std::shared_ptr<Buffer> buf) {\n+  if (*buf->device() != *device_) {\n+    return Status::Invalid(\"CudaMemoryManager::GetBufferReader called on foreign buffer\");\n \n Review comment:\n   How about adding `buf->device()` (and `device_`?) information to the error message?\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.287+0000",
                    "updated": "2020-02-02T00:02:07.287+0000",
                    "started": "2020-02-02T00:02:07.286+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380399",
                    "issueId": "13151618"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/worklog/380400",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "comment": "kou commented on pull request #6295: ARROW-2447: [C++] Device and MemoryManager API\nURL: https://github.com/apache/arrow/pull/6295#discussion_r373802594\n \n \n\n ##########\n File path: cpp/src/arrow/buffer.h\n ##########\n @@ -196,10 +248,31 @@ class ARROW_EXPORT Buffer {\n   /// \\brief Return the buffer's capacity (number of allocated bytes)\n   int64_t capacity() const { return capacity_; }\n \n+  /// \\brief Whether the buffer is directly CPU-accessible\n+  ///\n+  /// If this function returns true, you can read directly from the buffer's\n+  /// `data()` pointer.  Otherwise, you'll have to `View()` or `Copy()` it.\n+  bool is_cpu() const { return is_cpu_; }\n+\n+  const std::shared_ptr<Device>& device() const { return memory_manager_->device(); }\n+\n+  const std::shared_ptr<MemoryManager>& memory_manager() const { return memory_manager_; }\n+\n   std::shared_ptr<Buffer> parent() const { return parent_; }\n \n+  // Convenience functions\n \n Review comment:\n   Why do you prefer static functions to instance methods?\r\n   (Because we can't define instance methods for `std::shared_ptr<Buffer>`?)\r\n   \r\n   I think that instance methods are more convenient than static functions because user's code is shorter with instance methods:\r\n   \r\n   ```cpp\r\n   buffer->GetReader(); // instance method\r\n   arrow::Buffer::GetReader(buffer); // static functions\r\n   ```\n \n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on to GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "created": "2020-02-02T00:02:07.422+0000",
                    "updated": "2020-02-02T00:02:07.422+0000",
                    "started": "2020-02-02T00:02:07.421+0000",
                    "timeSpent": "10m",
                    "timeSpentSeconds": 600,
                    "id": "380400",
                    "issueId": "13151618"
                }
            ]
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/4",
            "id": "4",
            "description": "An improvement or enhancement to an existing feature or task.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21140&avatarType=issuetype",
            "name": "Improvement",
            "subtask": false,
            "avatarId": 21140
        },
        "timespent": 35400,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@13253123[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@166d1f0d[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52b1464[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@7bc0f6bb[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@725e2673[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@2104ef7f[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7cd1570f[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@d80300[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@336d0d6[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@54fa8d8[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@73d0fe51[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@33d03328[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": 35400,
        "customfield_12312520": null,
        "customfield_12312521": "Wed Feb 12 23:28:09 UTC 2020",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2020-02-12T23:28:09.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2447/watchers",
            "watchCount": 8,
            "isWatching": false
        },
        "created": "2018-04-11T11:14:02.000+0000",
        "updated": "2020-02-18T18:16:13.000+0000",
        "timeoriginalestimate": null,
        "description": "Right now, a plain Buffer doesn't carry information about where it actually lies. That information also cannot be passed around, so you get APIs like {{PlasmaClient}} which take or return device number integers, and have implementations which hardcode operations on CUDA buffers. Also, unsuspecting receivers of a {{Buffer}} pointer may try to act on the underlying memory without knowing whether it's CPU-reachable or not.\r\n\r\nHere is a sketch for a proposed Device abstraction:\r\n{code}\r\nclass Device {\r\n    enum DeviceKind { KIND_CPU, KIND_CUDA };\r\n\r\n    virtual DeviceKind kind() const;\r\n    //MemoryPool* default_memory_pool() const;\r\n    //std::shared_ptr<Buffer> Allocate(...);\r\n};\r\n\r\nclass CpuDevice : public Device {};\r\n\r\nclass CudaDevice : public Device {\r\n    int device_num() const;\r\n};\r\n\r\nclass Buffer {\r\n    virtual DeviceKind device_kind() const;\r\n    virtual std::shared_ptr<Device> device() const;\r\n    virtual bool on_cpu() const {\r\n        return true;\r\n    }\r\n\r\n    const uint8_t* cpu_data() const {\r\n        return on_cpu() ? data() : nullptr;\r\n    }\r\n    uint8_t* cpu_mutable_data() {\r\n        return on_cpu() ? mutable_data() : nullptr;\r\n    }\r\n\r\n    virtual CopyToCpu(std::shared_ptr<Buffer> dest) const;\r\n    virtual CopyFromCpu(std::shared_ptr<Buffer> src);\r\n};\r\n\r\nclass CudaBuffer : public Buffer {\r\n    virtual bool on_cpu() const {\r\n        return false;\r\n    }\r\n};\r\n\r\nCopyBuffer(std::shared_ptr<Buffer> dest, const std::shared_ptr<Buffer> src);\r\n{code}",
        "customfield_10010": null,
        "timetracking": {
            "remainingEstimate": "0h",
            "timeSpent": "9h 50m",
            "remainingEstimateSeconds": 0,
            "timeSpentSeconds": 35400
        },
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[C++] Create a device abstraction",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16758270",
                    "id": "16758270",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "[~wesmckinn],\u00a0[~pitrou], and others interested in this:\r\n\r\nI'd like to revive this issue and discuss the memory buffer model on heterogeneous systems where accessing device memory is possible only via copying of some memory content. Other than this restriction, one would wish to treat the device memory buffers in the same way as host memory buffers. That is, operations and algorithms developed for host memory buffer should be applicable to device memory buffer without any extra work required.\r\n\r\nSo, let may lay down some of the key features and issues of this problem as follows.\r\n\r\nIn CUDA, one can allocate memory that is accessible both from host and device without explicit copying. This includes:\r\n(i) managed memory (allocated using `cudaMallocManaged`) where the device driver will handle the copying step on demand triggered by page faults;\r\n(ii) host memory (allocated using `cudaMallocHost`) where host memory is accessible from a device via DMA;\r\n(iii) host memory (allocated using `malloc` or `new`) that is page-locked using `cudaHostRegister`, and again, the host memory is accessible from a device via DMA.\r\n\r\nDEFINITION: The notion \"accessible from a device\" (CPU or GPU) means that with a given memory pointer to data one can read and write data by pointer dereferencing within the device process. This is possible when host and device memories uses the same virtual memory area (VMA) or there exists a mapping between host and device VMAs where the access requires pointer value transformation (but no data copying) using `cudaHostGetDevicePointer`, for instance.\r\n\r\nOn the other hand, one can allocate memory that will not be accessible neither from device nor from host:\r\n(iv) host memory (allocated using `malloc` or `new`) is generally not accessible from device;\r\n(v) device memory (allocate using `cudaMalloc`) is generally not accessible from host.\r\n\r\nFinally, there is also a need to provide a way for one device to access the memory of another device. While CUDA provides various (copy or no-copy) methods for establishing the access between different GPU devices, there exists other accelerators (FPGA, etc) that memory buffers would need to be made accessible by other devices. Although, when direct connection between the two devices is missing, the host RAM can be used as a copy buffer.\r\n\r\nSo, my first suggestion is to revise the title of this issue, \"Create a device abstraction\" as well as the proposed Device abstraction semantics because these consider only the cases (iv) and (v) while the Device abstraction would suggest suboptimal usage for the cases (i), (ii) and (iii). For instance, managed memory could be hold both by `Buffer` as well as `CudaBuffer` while in the latter case unnecessary copies will be made by algorithms that need to access the `CudaBuffer` memory from a host process.\r\n\r\nThe memory buffer abstraction should capture the following data flow cases:\r\n(A) if buffer data is accessible within a device process (using pointer value or its transformed value), then the process will interpret the buffer data pointer as device pointer.\r\n(B) if buffer data is not accessible within a device process, then the process or the buffer object needs to implement a copy method. The copy method would involve a data copy as well as memory management of a temporary buffer.\r\n\r\nThe proposed Device abstraction already involves components for both (A) and (B) but I could see that it can be generalized for arbitrary devices and provide optimal abstraction for data access and movement. For instance:\r\n1. replace `cpu_data()` and `on_cpu` with `accessible_data(const Device& other)` and `is_accessible(const Device& other)`, respectively;\r\n2. replace `CopyToCpu` and `CopyFromCpu` with `CopyTo` and `CopyFrom`, respectively;\r\n3. instead of `Buffer`, `CudaBuffer`, `FPGABuffer`, etc just have `Buffer`;\r\n4. internally, use `uintptr_t` to hold buffer pointer value instead of `uint8_t*` to prevent accidental dereferencing when the pointer is not accessible from the given device . `accessible_data` can still return `uint8_t*`;\r\n\r\nAtm, I don't have a good replacement for a `Device` as its substance is not to specify a particular \"device\" but a \"memory area\". While in many cases these coincide, there are cases where a memory area can represent the memory of multiple devices (see cases (i)-(iii) above). Perhaps replace `Device` with `VirtualMemoryArea`? Or `MemoryPool`? Other ideas?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-02-01T12:55:38.796+0000",
                    "updated": "2019-02-01T12:55:38.796+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16758320",
                    "id": "16758320",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "I marked for 0.13. I won't be able to comment in detail until next week but I agree we should sort a solution that meets the requirements for this",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-02-01T13:53:19.288+0000",
                    "updated": "2019-02-01T13:53:19.288+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16761692",
                    "id": "16761692",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Thanks [~pearu]. Regarding your propositions:\r\n\r\n1) sounds fine to me, though we might keep `cpu_data` and `on_cpu` as shortcuts for `accessible_data(CPUDevice())` and `is_accessible(CPUDevice())`, respectively. Expecting CPU-accessible memory will still be the dominant case in code using this API (since, after all, this is code running on the CPU).\r\n\r\n(a concern here is that querying the CPU address of a buffer should ideally not go through a virtual function call)\r\n\r\n2) sounds fine to me (but might also keep shortcuts, see above)\r\n\r\n3) sounds fine as well... but need a way to query device-specific buffer properties (such as `cuda_buffer->context()`) in another way, then.\r\n\r\n4) I have no particular opinion about this.\r\n\r\nIn case (iii), the memory still resides on a particular device, it just happens to be readable from another device as well. So e.g. the memory sits on a GPU, but is CPU-accessible (at higher cost than normal) which suggests that `accessible_data(CPUDevice())` would return the appropriate CPU memory pointer.\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-02-06T12:06:10.029+0000",
                    "updated": "2019-02-06T12:06:10.029+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16788766",
                    "id": "16788766",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "Re [~pitrou] comment:\u00a0In case (iii), the memory still resides on a particular device, it just happens to be readable from another device as well. So e.g. the memory sits on a GPU, but is CPU-accessible..\r\n\r\nDid you meant the case (i) as in the case (iii) the memory should reside on RAM (since it allocated using `malloc`)?",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-09T18:34:42.873+0000",
                    "updated": "2019-03-09T18:34:42.873+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16788770",
                    "id": "16788770",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "FYI, CUDA introduces [MemoryType|https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__TYPES.html#group__CUDART__TYPES_1g13de56a8fe75569530ecc3a3106e9b6d]\u00a0concept that together with [cudaPointerGetAttributes|https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__UNIFIED.html#group__CUDART__UNIFIED_1gd89830e17d399c064a2f3c3fa8bb4390]\u00a0allows to determine if the given pointer value can be accessed from device or host or from both, and when on device then what is the device number.\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-09T18:51:10.763+0000",
                    "updated": "2019-03-09T18:51:10.763+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16788777",
                    "id": "16788777",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "If a CUDA device supports compute capability 7.0 or higher (ATS over NVLink), [all of the system memory would be accessible by a device|https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#um-system-allocator]. So, if ATS over NVLink is available, tackling the current issue simplifies considerably.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-09T19:11:45.172+0000",
                    "updated": "2019-03-09T19:12:10.549+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16788780",
                    "id": "16788780",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "Re [~pitrou] comment:\u00a0\u00a0need a way to query device-specific buffer properties (such as `cuda_buffer->context()`) ..\r\n\r\nCurrently, Arrow CUDA support uses primary context management which means that to get the CUDA context, one only needs to know the device number (use [cuDevicePrimaryCtxRetain|https://docs.nvidia.com/cuda/cuda-driver-api/group__CUDA__PRIMARY__CTX.html#group__CUDA__PRIMARY__CTX_1g9051f2d5c31501997a6cb0530290a300]). The device number can be retrieved from the memory pointer (use [cudaPointerGetAttributes|https://docs.nvidia.com/cuda/cuda-runtime-api/group__CUDART__UNIFIED.html#group__CUDART__UNIFIED_1gd89830e17d399c064a2f3c3fa8bb4390]). So, it would be sufficient to know that the pointer is a CUDA device pointer to establish its accessibility properties as well as context if needed.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-09T19:28:54.616+0000",
                    "updated": "2019-03-09T19:28:54.616+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16788883",
                    "id": "16788883",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "Also the MemoryPool plays an important role in this issue: MemoryPool allocate the memory and hence is the first source of information that determines the pointer's accessibility properties. In the Device class proposal, MemoryPool is suggested to become a part of the Device class, but see below.\r\n\r\nIn the CUDA case, the pointer's accessibility property is defined by the method that is used for allocating the memory. The device number is more a parameter that is not sufficient for determining the pointer's accessibility. From that I would conclude that one should attach to the Buffer the allocation method information (that includes device number), not the Device instance which does not provide all of the required information.\r\n\r\nSo, perhaps we should be attaching MemoryPool to the Buffer (instead of introducing Device class) so that the accessibility of memory pointer is determined by the MemoryPool instance which contains also the process information. Recall, CUDA context is essentially a device process.\r\n\r\nCurrently, CPU based Arrow uses DefaultMemoryPool. For CUDA support, several new memory pools would be defined:\r\nCudaManagedMemoryPool\r\nCudaMemoryPool\r\nCudaHostMemoryPool\r\nCudaRegistrededMemoryPool\r\n\r\nor in more general, one should be able to define their own MemoryPool instance that manages the memory of any device or uses some custom memory manager such as [RMM|https://github.com/rapidsai/rmm]\u00a0for allocating memory for Arrow buffers.\r\n\r\n`Buffer.is_accessible` would take a MemoryPool instance as argument and pairing this with the MemoryPool instance attached to the Buffer will determine the Buffer pointer accessibility properties. For that, MemoryPool classes would implement a method, say, `is_compatible(<other MemoryPool instance>)` that returns `true` if the pointer can be accessed from the process that the other MemoryPool represents. In addition, MemoryPool instances would implement the CopyTo and CopyFrom methods.\r\n\r\n[~wesmckinn], [~pitrou], and others, what do you think?\r\n\r\n\u00a0",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-10T11:06:53.105+0000",
                    "updated": "2019-03-10T11:06:53.105+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16789498",
                    "id": "16789498",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "It turns out that MemoryPool should be always attached to its Buffers, otherwise it may be destructed before all its memory is released. See https://issues.apache.org/jira/browse/ARROW-4825\u00a0.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-11T12:39:07.054+0000",
                    "updated": "2019-03-11T12:39:07.054+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16789651",
                    "id": "16789651",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "It _is_ attached, but not by a shared_ptr\r\n\r\nhttps://github.com/apache/arrow/blob/8b65bf845a2bc9ad071451c6924a9c33e29a4e9f/cpp/src/arrow/buffer.cc#L99\r\n\r\nOne possibility is to use shared_ptr. There are probably other possibilities to extend the life of allocated memory; probably some microbenchmarks should be implemented to evaluate whatever strategy is employed",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-03-11T14:45:31.161+0000",
                    "updated": "2019-03-11T14:45:31.161+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16789753",
                    "id": "16789753",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "body": "Thanks for the pointer! I'll give shared_ptr-approach a try and prepare a PR for ARROW-4825.\r\n\r\nBtw, I have implemented CudaMemoryPool(<cuda.Context>) and the approach seems to work fine. For instance, `pa.allocate_buffer(512, memory_pool=<CudaMemoryPool instance>)` creates an arrow Buffer with device pointers. It only required overriding ZeroPadding that used `memset` with a method that uses `cuMemsetD8`.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=pearu",
                        "name": "pearu",
                        "key": "pearu",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pearu&avatarId=35984",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pearu&avatarId=35984",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pearu&avatarId=35984",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pearu&avatarId=35984"
                        },
                        "displayName": "Pearu Peterson",
                        "active": true,
                        "timeZone": "Europe/Tallinn"
                    },
                    "created": "2019-03-11T16:55:39.989+0000",
                    "updated": "2019-03-11T16:55:39.989+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16801755",
                    "id": "16801755",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "bq. For instance, `pa.allocate_buffer(512, memory_pool=<CudaMemoryPool instance>)` creates an arrow Buffer with device pointers.\r\n\r\nI'm not sure that's the right approach, API-wise. What if allocating a given buffer type requires more than just getting a pointer from the underlying memory pool? So, rather than pass a CUDA memory pool to `pa.allocate`, it sounds more future proof to have a dedicated `pa.cuda.allocate_buffer` (or something).\r\n\r\nbq. So, perhaps we should be attaching MemoryPool to the Buffer (instead of introducing Device class) so that the accessibility of memory pointer is determined by the MemoryPool instance which contains also the process information.\r\n\r\nI don't know. Getting device information in itself may be useful. Inspecting a MemoryPool doesn't sound sufficient. Of course, perhaps the device could be attached to the MemoryPool rather than to the Buffer itself?\r\n\r\nYou're right about accessibility information: it seems more fine-grained than I initially assumed. It would still be worthwhile to find a solution to make uses of Buffer are less error-prone, though. Right now the only thing that protects the user is that CUDA buffers are hardly ever used, so you don't risk encountering them ;-)\r\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-03-26T14:09:24.603+0000",
                    "updated": "2019-03-26T14:09:24.603+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16931565",
                    "id": "16931565",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Ideally we would have this in 1.0.0, but it may be starting to be a bit short.",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2019-09-17T15:30:13.156+0000",
                    "updated": "2019-09-17T15:30:13.156+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/16931710",
                    "id": "16931710",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Agreed. I don't think we should stress ourselves about creating a stable API for an initial cut, but having the basics in place would be beneficial, I think",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2019-09-17T18:02:12.155+0000",
                    "updated": "2019-09-17T18:02:12.155+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13151618/comment/17035789",
                    "id": "17035789",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "body": "Issue resolved by pull request 6295\n[https://github.com/apache/arrow/pull/6295]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=wesm",
                        "name": "wesm",
                        "key": "wesmckinn",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=wesmckinn&avatarId=29931",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=wesmckinn&avatarId=29931",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=wesmckinn&avatarId=29931",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=wesmckinn&avatarId=29931"
                        },
                        "displayName": "Wes McKinney",
                        "active": true,
                        "timeZone": "America/New_York"
                    },
                    "created": "2020-02-12T23:28:09.285+0000",
                    "updated": "2020-02-12T23:28:09.285+0000"
                }
            ],
            "maxResults": 15,
            "total": 15,
            "startAt": 0
        },
        "customfield_12311820": "0|i3setj:",
        "customfield_12314139": null
    }
}