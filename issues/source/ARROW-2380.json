{
    "expand": "operations,versionedRepresentations,editmeta,changelog,renderedFields",
    "id": "13149590",
    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590",
    "key": "ARROW-2380",
    "fields": {
        "fixVersions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12342562",
                "id": "12342562",
                "description": "",
                "name": "0.10.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-08-06"
            }
        ],
        "resolution": {
            "self": "https://issues.apache.org/jira/rest/api/2/resolution/1",
            "id": "1",
            "description": "A fix for this issue is checked into the tree and tested.",
            "name": "Fixed"
        },
        "customfield_12312322": null,
        "customfield_12312323": null,
        "customfield_12312320": null,
        "customfield_12310420": "9223372036854775807",
        "customfield_12312321": null,
        "customfield_12312328": null,
        "customfield_12312329": null,
        "customfield_12312326": null,
        "customfield_12310300": null,
        "customfield_12312327": null,
        "customfield_12312324": null,
        "customfield_12312720": null,
        "customfield_12312325": null,
        "lastViewed": null,
        "priority": {
            "self": "https://issues.apache.org/jira/rest/api/2/priority/3",
            "iconUrl": "https://issues.apache.org/jira/images/icons/priorities/major.svg",
            "name": "Major",
            "id": "3"
        },
        "labels": [
            "pull-request-available"
        ],
        "customfield_12312333": null,
        "customfield_12312334": null,
        "customfield_12313422": "false",
        "customfield_12310310": "0.0",
        "customfield_12312331": null,
        "customfield_12312332": null,
        "aggregatetimeoriginalestimate": null,
        "timeestimate": null,
        "customfield_12312330": null,
        "versions": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/version/12341707",
                "id": "12341707",
                "description": "",
                "name": "0.9.0",
                "archived": false,
                "released": true,
                "releaseDate": "2018-03-19"
            }
        ],
        "customfield_12311120": null,
        "customfield_12313826": null,
        "customfield_12312339": null,
        "issuelinks": [],
        "customfield_12313825": null,
        "assignee": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
            "name": "apitrou",
            "key": "pitrou",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
            },
            "displayName": "Antoine Pitrou",
            "active": true,
            "timeZone": "Europe/Paris"
        },
        "customfield_12312337": null,
        "customfield_12313823": null,
        "customfield_12312338": null,
        "customfield_12311920": null,
        "customfield_12313822": null,
        "customfield_12312335": null,
        "customfield_12313821": null,
        "customfield_12312336": null,
        "customfield_12313820": null,
        "status": {
            "self": "https://issues.apache.org/jira/rest/api/2/status/5",
            "description": "A resolution has been taken, and it is awaiting verification by reporter. From here issues are either reopened, or are closed.",
            "iconUrl": "https://issues.apache.org/jira/images/icons/statuses/resolved.png",
            "name": "Resolved",
            "id": "5",
            "statusCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/statuscategory/3",
                "id": 3,
                "key": "done",
                "colorName": "green",
                "name": "Done"
            }
        },
        "components": [
            {
                "self": "https://issues.apache.org/jira/rest/api/2/component/12328936",
                "id": "12328936",
                "name": "Python"
            }
        ],
        "customfield_12312026": null,
        "customfield_12312023": null,
        "customfield_12312024": null,
        "aggregatetimeestimate": null,
        "customfield_12312022": null,
        "customfield_12310921": null,
        "customfield_12310920": "9223372036854775807",
        "customfield_12312823": null,
        "creator": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "subtasks": [],
        "reporter": {
            "self": "https://issues.apache.org/jira/rest/api/2/user?username=bryanc",
            "name": "bryanc",
            "key": "bryanc",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=bryanc&avatarId=23479",
                "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=bryanc&avatarId=23479",
                "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=bryanc&avatarId=23479",
                "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=bryanc&avatarId=23479"
            },
            "displayName": "Bryan Cutler",
            "active": true,
            "timeZone": "America/Los_Angeles"
        },
        "aggregateprogress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313520": null,
        "customfield_12310250": null,
        "progress": {
            "progress": 0,
            "total": 0
        },
        "customfield_12313924": null,
        "votes": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2380/votes",
            "votes": 0,
            "hasVoted": false
        },
        "worklog": {
            "startAt": 0,
            "maxResults": 20,
            "total": 0,
            "worklogs": []
        },
        "customfield_12313920": null,
        "issuetype": {
            "self": "https://issues.apache.org/jira/rest/api/2/issuetype/1",
            "id": "1",
            "description": "A problem which impairs or prevents the functions of the product.",
            "iconUrl": "https://issues.apache.org/jira/secure/viewavatar?size=xsmall&avatarId=21133&avatarType=issuetype",
            "name": "Bug",
            "subtask": false,
            "avatarId": 21133
        },
        "timespent": null,
        "customfield_12314020": "{summaryBean=com.atlassian.jira.plugin.devstatus.rest.SummaryBean@96aa2b8[summary={pullrequest=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@52434a85[overall=PullRequestOverallBean{stateCount=0, state='OPEN', details=PullRequestOverallDetails{openCount=0, mergedCount=0, declinedCount=0}},byInstanceType={}], build=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@7ea3c902[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BuildOverallBean@367ca331[failedBuildCount=0,successfulBuildCount=0,unknownBuildCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], review=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1cb1b066[overall=com.atlassian.jira.plugin.devstatus.summary.beans.ReviewsOverallBean@38112778[stateCount=0,state=<null>,dueDate=<null>,overDue=false,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], deployment-environment=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@581a12a1[overall=com.atlassian.jira.plugin.devstatus.summary.beans.DeploymentOverallBean@bac47b8[topEnvironments=[],showProjects=false,successfulCount=0,count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], repository=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@1a0ff42b[overall=com.atlassian.jira.plugin.devstatus.summary.beans.CommitOverallBean@2b942af5[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}], branch=com.atlassian.jira.plugin.devstatus.rest.SummaryItemBean@2313ba3c[overall=com.atlassian.jira.plugin.devstatus.summary.beans.BranchOverallBean@4aeba861[count=0,lastUpdated=<null>,lastUpdatedTimestamp=<null>],byInstanceType={}]},errors=[],configErrors=[]], devSummaryJson={\"cachedValue\":{\"errors\":[],\"configErrors\":[],\"summary\":{\"pullrequest\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":\"OPEN\",\"details\":{\"openCount\":0,\"mergedCount\":0,\"declinedCount\":0,\"total\":0},\"open\":true},\"byInstanceType\":{}},\"build\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"failedBuildCount\":0,\"successfulBuildCount\":0,\"unknownBuildCount\":0},\"byInstanceType\":{}},\"review\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"stateCount\":0,\"state\":null,\"dueDate\":null,\"overDue\":false,\"completed\":false},\"byInstanceType\":{}},\"deployment-environment\":{\"overall\":{\"count\":0,\"lastUpdated\":null,\"topEnvironments\":[],\"showProjects\":false,\"successfulCount\":0},\"byInstanceType\":{}},\"repository\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}},\"branch\":{\"overall\":{\"count\":0,\"lastUpdated\":null},\"byInstanceType\":{}}}},\"isStale\":false}}",
        "customfield_12314141": null,
        "customfield_12314140": null,
        "project": {
            "self": "https://issues.apache.org/jira/rest/api/2/project/12319525",
            "id": "12319525",
            "key": "ARROW",
            "name": "Apache Arrow",
            "projectTypeKey": "software",
            "avatarUrls": {
                "48x48": "https://issues.apache.org/jira/secure/projectavatar?pid=12319525&avatarId=10011",
                "24x24": "https://issues.apache.org/jira/secure/projectavatar?size=small&pid=12319525&avatarId=10011",
                "16x16": "https://issues.apache.org/jira/secure/projectavatar?size=xsmall&pid=12319525&avatarId=10011",
                "32x32": "https://issues.apache.org/jira/secure/projectavatar?size=medium&pid=12319525&avatarId=10011"
            },
            "projectCategory": {
                "self": "https://issues.apache.org/jira/rest/api/2/projectCategory/13960",
                "id": "13960",
                "description": "Apache Arrow",
                "name": "Arrow"
            }
        },
        "aggregatetimespent": null,
        "customfield_12312520": null,
        "customfield_12312521": "Thu Apr 05 17:59:32 UTC 2018",
        "customfield_12314422": null,
        "customfield_12314421": null,
        "customfield_12314146": null,
        "customfield_12314420": null,
        "customfield_12314145": null,
        "customfield_12314144": null,
        "customfield_12314143": null,
        "resolutiondate": "2018-04-05T13:35:08.000+0000",
        "workratio": -1,
        "customfield_12312923": null,
        "customfield_12312920": null,
        "customfield_12312921": null,
        "watches": {
            "self": "https://issues.apache.org/jira/rest/api/2/issue/ARROW-2380/watchers",
            "watchCount": 2,
            "isWatching": false
        },
        "created": "2018-04-02T21:16:48.000+0000",
        "updated": "2018-04-05T17:59:32.000+0000",
        "timeoriginalestimate": null,
        "description": "Following the discussion at [https://github.com/apache/arrow/pull/1689,] there are a few issues with conversion of various types to arrow that are incorrect or could be improved:\r\n * PyBytes_GET_SIZE is being casted to the wrong type, for example \r\n{{const int32_t length = static_cast<int32_t>(PyBytes_GET_SIZE(obj));}}\r\n\r\n * Handle the possibility with the statement\r\n{{builder->value_data_length() + length > kBinaryMemoryLimit}}\r\nif length is larger than kBinaryMemoryLimit\r\n\r\n * Look into using common code for binary object conversion to avoid duplication, and allow support for bytes and bytearray objects in other places than numpy_to_arrow.  (possibly put in src/arrow/python/helpers.h)",
        "customfield_10010": null,
        "timetracking": {},
        "customfield_12314523": null,
        "customfield_12314127": null,
        "customfield_12314522": null,
        "customfield_12314126": null,
        "customfield_12314521": null,
        "customfield_12314125": null,
        "customfield_12314520": null,
        "customfield_12314124": null,
        "attachment": [],
        "customfield_12312340": null,
        "customfield_12314123": null,
        "customfield_12312341": null,
        "customfield_12312220": null,
        "customfield_12314122": null,
        "customfield_12314121": null,
        "customfield_12314120": null,
        "customfield_12314129": null,
        "customfield_12314524": null,
        "customfield_12314128": null,
        "summary": "[Python] Correct issues in numpy_to_arrow conversion routines",
        "customfield_12314130": null,
        "customfield_12310291": null,
        "customfield_12310290": null,
        "customfield_12314138": null,
        "customfield_12314137": null,
        "environment": null,
        "customfield_12314136": null,
        "customfield_12314135": null,
        "customfield_12311020": null,
        "customfield_12314134": null,
        "duedate": null,
        "customfield_12314132": null,
        "customfield_12314131": null,
        "comment": {
            "comments": [
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16425712",
                    "id": "16425712",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou opened a new pull request #1835: [WIP] ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835\n \n \n   * Correctly check for overflow when constructing string / binary objects\r\n   * Accept bytearrays in the same places as bytes objects\r\n   * Other small refactorings\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T15:23:21.180+0000",
                    "updated": "2018-04-04T15:23:21.180+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16425934",
                    "id": "16425934",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1835: [WIP] ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835#issuecomment-378689567\n \n \n   @BryanCutler \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T17:56:30.548+0000",
                    "updated": "2018-04-04T17:56:30.548+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16425937",
                    "id": "16425937",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1835: [WIP] ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835#issuecomment-378689735\n \n \n   Note to self: I should run the benchmarks when this PR is ready\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-04T17:57:06.904+0000",
                    "updated": "2018-04-04T17:57:06.904+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16426725",
                    "id": "16426725",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1835: ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835#issuecomment-378891483\n \n \n   Running the benchmarks led me to identify a regression due to instantiating a `std::string` in critical places (fixed).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-05T10:30:41.579+0000",
                    "updated": "2018-04-05T10:30:41.579+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16426726",
                    "id": "16426726",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou commented on issue #1835: ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835#issuecomment-378891901\n \n \n   Without this PR:\r\n   ```\r\n   [ 28.57%] \u00b7\u00b7\u00b7 Running convert_builtins.ConvertPyListToArray.time_convert                                                                                ok\r\n   [ 28.57%] \u00b7\u00b7\u00b7\u00b7 \r\n                  ==================== =============\r\n                          type                      \r\n                  -------------------- -------------\r\n                         int32          5.67\u00b10.06ms \r\n                         uint32         5.77\u00b10.06ms \r\n                         int64           5.72\u00b10.1ms \r\n                         uint64          5.09\u00b10.1ms \r\n                        float32         5.16\u00b10.01ms \r\n                        float64         5.32\u00b10.05ms \r\n                          bool          4.51\u00b10.02ms \r\n                        decimal          187\u00b10.2ms  \r\n                         binary          8.40\u00b10.1ms \r\n                        binary10         8.35\u00b10.1ms \r\n                         ascii           13.2\u00b10.2ms \r\n                        unicode          28.8\u00b10.7ms \r\n                       int64 list        51.0\u00b10.6ms \r\n                         struct           31.6\u00b11ms  \r\n                   struct from tuples     31.0\u00b12ms  \r\n                  ==================== =============\r\n   \r\n   [ 42.86%] \u00b7\u00b7\u00b7 Running convert_builtins.InferPyListToArray.time_infer                                                                                    ok\r\n   [ 42.86%] \u00b7\u00b7\u00b7\u00b7 \r\n                  ============ =============\r\n                      type                  \r\n                  ------------ -------------\r\n                     int64       11.3\u00b10.1ms \r\n                    float64     10.4\u00b10.02ms \r\n                      bool      9.85\u00b10.04ms \r\n                    decimal       383\u00b11ms   \r\n                     binary      14.8\u00b10.1ms \r\n                     ascii       20.3\u00b10.3ms \r\n                    unicode      38.2\u00b10.4ms \r\n                   int64 list    102\u00b10.3ms  \r\n                  ============ =============\r\n   ```\r\n   \r\n   With this PR:\r\n   ```\r\n   [ 28.57%] \u00b7\u00b7\u00b7 Running convert_builtins.ConvertPyListToArray.time_convert                                                                                 ok\r\n   [ 28.57%] \u00b7\u00b7\u00b7\u00b7 \r\n                  ==================== =============\r\n                          type                      \r\n                  -------------------- -------------\r\n                         int32          5.20\u00b10.05ms \r\n                         uint32         5.03\u00b10.06ms \r\n                         int64           5.69\u00b10.2ms \r\n                         uint64          5.83\u00b10.1ms \r\n                        float32         4.84\u00b10.02ms \r\n                        float64         4.99\u00b10.03ms \r\n                          bool          4.27\u00b10.02ms \r\n                        decimal          179\u00b10.7ms  \r\n                         binary          8.61\u00b10.1ms \r\n                        binary10         12.1\u00b10.1ms \r\n                         ascii          10.5\u00b10.04ms \r\n                        unicode          17.2\u00b10.7ms \r\n                       int64 list        49.8\u00b10.7ms \r\n                         struct           32.8\u00b11ms  \r\n                   struct from tuples     32.7\u00b12ms  \r\n                  ==================== =============\r\n   \r\n   [ 42.86%] \u00b7\u00b7\u00b7 Running convert_builtins.InferPyListToArray.time_infer                                                                                     ok\r\n   [ 42.86%] \u00b7\u00b7\u00b7\u00b7 \r\n                  ============ =============\r\n                      type                  \r\n                  ------------ -------------\r\n                     int64       11.1\u00b10.1ms \r\n                    float64     10.2\u00b10.02ms \r\n                      bool      9.27\u00b10.03ms \r\n                    decimal      371\u00b10.5ms  \r\n                     binary      15.0\u00b10.1ms \r\n                     ascii       17.2\u00b10.1ms \r\n                    unicode      28.7\u00b10.6ms \r\n                   int64 list    97.1\u00b10.4ms \r\n                  ============ =============\r\n   ```\r\n   \r\n   It's mostly a wash, except that convert unicode strings to Arrow became faster (on Python 3).\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-05T10:32:33.856+0000",
                    "updated": "2018-04-05T10:32:33.856+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16426929",
                    "id": "16426929",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "pitrou closed pull request #1835: ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835\n \n \n   \n\nThis is a PR merged from a forked repository.\nAs GitHub hides the original diff on merge, it is displayed below for\nthe sake of provenance:\n\nAs this is a foreign pull request (from a fork), the diff is supplied\nbelow (as it won't show otherwise due to GitHub magic):\n\ndiff --git a/cpp/src/arrow/python/CMakeLists.txt b/cpp/src/arrow/python/CMakeLists.txt\nindex b985df914..f6c92a79b 100644\n--- a/cpp/src/arrow/python/CMakeLists.txt\n+++ b/cpp/src/arrow/python/CMakeLists.txt\n@@ -54,6 +54,7 @@ set(ARROW_PYTHON_SRCS\n   builtin_convert.cc\n   common.cc\n   config.cc\n+  decimal.cc\n   helpers.cc\n   init.cc\n   io.cc\n@@ -104,6 +105,7 @@ install(FILES\n   builtin_convert.h\n   common.h\n   config.h\n+  decimal.h\n   helpers.h\n   init.h\n   io.h\ndiff --git a/cpp/src/arrow/python/arrow_to_pandas.cc b/cpp/src/arrow/python/arrow_to_pandas.cc\nindex 92461fc16..41a07d007 100644\n--- a/cpp/src/arrow/python/arrow_to_pandas.cc\n+++ b/cpp/src/arrow/python/arrow_to_pandas.cc\n@@ -47,6 +47,7 @@\n #include \"arrow/python/builtin_convert.h\"\n #include \"arrow/python/common.h\"\n #include \"arrow/python/config.h\"\n+#include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n #include \"arrow/python/numpy-internal.h\"\n #include \"arrow/python/numpy_convert.h\"\ndiff --git a/cpp/src/arrow/python/builtin_convert.cc b/cpp/src/arrow/python/builtin_convert.cc\nindex 5e99992f1..459e299c3 100644\n--- a/cpp/src/arrow/python/builtin_convert.cc\n+++ b/cpp/src/arrow/python/builtin_convert.cc\n@@ -33,6 +33,7 @@\n #include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n \n+#include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n #include \"arrow/python/numpy_convert.h\"\n #include \"arrow/python/util/datetime.h\"\n@@ -42,26 +43,9 @@ namespace py {\n \n Status InvalidConversion(PyObject* obj, const std::string& expected_types,\n                          std::ostream* out) {\n-  OwnedRef type(PyObject_Type(obj));\n-  RETURN_IF_PYERROR();\n-  DCHECK_NE(type.obj(), nullptr);\n-\n-  OwnedRef type_name(PyObject_GetAttrString(type.obj(), \"__name__\"));\n-  RETURN_IF_PYERROR();\n-  DCHECK_NE(type_name.obj(), nullptr);\n-\n-  PyObjectStringify bytestring(type_name.obj());\n-  RETURN_IF_PYERROR();\n-\n-  const char* bytes = bytestring.bytes;\n-  DCHECK_NE(bytes, nullptr) << \"bytes from type(...).__name__ were null\";\n-\n-  Py_ssize_t size = bytestring.size;\n-\n-  std::string cpp_type_name(bytes, size);\n-\n-  (*out) << \"Got Python object of type \" << cpp_type_name\n+  (*out) << \"Got Python object of type \" << Py_TYPE(obj)->tp_name\n          << \" but can only handle these types: \" << expected_types;\n+  // XXX streamline this?\n   return Status::OK();\n }\n \n@@ -100,7 +84,7 @@ class ScalarVisitor {\n       ++date_count_;\n     } else if (PyDateTime_CheckExact(obj)) {\n       ++timestamp_count_;\n-    } else if (PyBytes_Check(obj)) {\n+    } else if (internal::IsPyBinary(obj)) {\n       ++binary_count_;\n     } else if (PyUnicode_Check(obj)) {\n       ++unicode_count_;\n@@ -445,122 +429,15 @@ class BoolConverter : public TypedConverterVisitor<BooleanBuilder, BoolConverter\n   }\n };\n \n-class Int8Converter : public TypedConverterVisitor<Int8Builder, Int8Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<int8_t>::max() ||\n-                            val < std::numeric_limits<int8_t>::min())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    RETURN_IF_PYERROR();\n-    return typed_builder_->Append(static_cast<int8_t>(val));\n-  }\n-};\n-\n-class Int16Converter : public TypedConverterVisitor<Int16Builder, Int16Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<int16_t>::max() ||\n-                            val < std::numeric_limits<int16_t>::min())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    RETURN_IF_PYERROR();\n-    return typed_builder_->Append(static_cast<int16_t>(val));\n-  }\n-};\n-\n-class Int32Converter : public TypedConverterVisitor<Int32Builder, Int32Converter> {\n+template <typename IntType>\n+class TypedIntConverter\n+    : public TypedConverterVisitor<NumericBuilder<IntType>, TypedIntConverter<IntType>> {\n  public:\n   // Append a non-missing item\n   Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<int32_t>::max() ||\n-                            val < std::numeric_limits<int32_t>::min())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    RETURN_IF_PYERROR();\n-    return typed_builder_->Append(static_cast<int32_t>(val));\n-  }\n-};\n-\n-class Int64Converter : public TypedConverterVisitor<Int64Builder, Int64Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-    RETURN_IF_PYERROR();\n-    return typed_builder_->Append(val);\n-  }\n-};\n-\n-class UInt8Converter : public TypedConverterVisitor<UInt8Builder, UInt8Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<uint64_t>(PyLong_AsLongLong(obj));\n-    RETURN_IF_PYERROR();\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<uint8_t>::max())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    return typed_builder_->Append(static_cast<uint8_t>(val));\n-  }\n-};\n-\n-class UInt16Converter : public TypedConverterVisitor<UInt16Builder, UInt16Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<uint64_t>(PyLong_AsLongLong(obj));\n-    RETURN_IF_PYERROR();\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<uint16_t>::max())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    return typed_builder_->Append(static_cast<uint16_t>(val));\n-  }\n-};\n-\n-class UInt32Converter : public TypedConverterVisitor<UInt32Builder, UInt32Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    const auto val = static_cast<uint64_t>(PyLong_AsLongLong(obj));\n-    RETURN_IF_PYERROR();\n-\n-    if (ARROW_PREDICT_FALSE(val > std::numeric_limits<uint32_t>::max())) {\n-      return Status::Invalid(\n-          \"Cannot coerce values to array type that would \"\n-          \"lose data\");\n-    }\n-    return typed_builder_->Append(static_cast<uint32_t>(val));\n-  }\n-};\n-\n-class UInt64Converter : public TypedConverterVisitor<UInt64Builder, UInt64Converter> {\n- public:\n-  // Append a non-missing item\n-  Status AppendItem(PyObject* obj) {\n-    uint64_t val;\n-    RETURN_NOT_OK(internal::UInt64FromPythonInt(obj, &val));\n-    return typed_builder_->Append(val);\n+    typename IntType::c_type value;\n+    RETURN_NOT_OK(internal::CIntFromPython(obj, &value));\n+    return this->typed_builder_->Append(value);\n   }\n };\n \n@@ -573,12 +450,7 @@ class Date32Converter : public TypedConverterVisitor<Date32Builder, Date32Conver\n       auto pydate = reinterpret_cast<PyDateTime_Date*>(obj);\n       t = static_cast<int32_t>(PyDate_to_s(pydate));\n     } else {\n-      const auto casted_val = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-      RETURN_IF_PYERROR();\n-      if (casted_val > std::numeric_limits<int32_t>::max()) {\n-        return Status::Invalid(\"Integer as date32 larger than INT32_MAX\");\n-      }\n-      t = static_cast<int32_t>(casted_val);\n+      RETURN_NOT_OK(internal::CIntFromPython(obj, &t, \"Integer too large for date32\"));\n     }\n     return typed_builder_->Append(t);\n   }\n@@ -593,8 +465,7 @@ class Date64Converter : public TypedConverterVisitor<Date64Builder, Date64Conver\n       auto pydate = reinterpret_cast<PyDateTime_Date*>(obj);\n       t = PyDate_to_ms(pydate);\n     } else {\n-      t = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-      RETURN_IF_PYERROR();\n+      RETURN_NOT_OK(internal::CIntFromPython(obj, &t, \"Integer too large for date64\"));\n     }\n     return typed_builder_->Append(t);\n   }\n@@ -645,8 +516,7 @@ class TimestampConverter\n \n       t = reinterpret_cast<PyDatetimeScalarObject*>(obj)->obval;\n     } else {\n-      t = static_cast<int64_t>(PyLong_AsLongLong(obj));\n-      RETURN_IF_PYERROR();\n+      RETURN_NOT_OK(internal::CIntFromPython(obj, &t));\n     }\n     return typed_builder_->Append(t);\n   }\n@@ -690,27 +560,7 @@ class BytesConverter : public TypedConverterVisitor<BinaryBuilder, BytesConverte\n  public:\n   // Append a non-missing item\n   Status AppendItem(PyObject* obj) {\n-    PyObject* bytes_obj;\n-    const char* bytes;\n-    Py_ssize_t length;\n-    OwnedRef tmp;\n-\n-    if (PyUnicode_Check(obj)) {\n-      tmp.reset(PyUnicode_AsUTF8String(obj));\n-      RETURN_IF_PYERROR();\n-      bytes_obj = tmp.obj();\n-    } else if (PyBytes_Check(obj)) {\n-      bytes_obj = obj;\n-    } else {\n-      std::stringstream ss;\n-      ss << \"Error converting to Binary type: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"bytes\", &ss));\n-      return Status::Invalid(ss.str());\n-    }\n-    // No error checking\n-    length = PyBytes_GET_SIZE(bytes_obj);\n-    bytes = PyBytes_AS_STRING(bytes_obj);\n-    return typed_builder_->Append(bytes, static_cast<int32_t>(length));\n+    return internal::BuilderAppend(typed_builder_, obj);\n   }\n };\n \n@@ -719,27 +569,7 @@ class FixedWidthBytesConverter\n  public:\n   // Append a non-missing item\n   Status AppendItem(PyObject* obj) {\n-    PyObject* bytes_obj;\n-    OwnedRef tmp;\n-    Py_ssize_t expected_length =\n-        std::dynamic_pointer_cast<FixedSizeBinaryType>(typed_builder_->type())\n-            ->byte_width();\n-    if (PyUnicode_Check(obj)) {\n-      tmp.reset(PyUnicode_AsUTF8String(obj));\n-      RETURN_IF_PYERROR();\n-      bytes_obj = tmp.obj();\n-    } else if (PyBytes_Check(obj)) {\n-      bytes_obj = obj;\n-    } else {\n-      std::stringstream ss;\n-      ss << \"Error converting to FixedSizeBinary type: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"bytes\", &ss));\n-      return Status::Invalid(ss.str());\n-    }\n-    // No error checking\n-    RETURN_NOT_OK(CheckPythonBytesAreFixedLength(bytes_obj, expected_length));\n-    return typed_builder_->Append(\n-        reinterpret_cast<const uint8_t*>(PyBytes_AS_STRING(bytes_obj)));\n+    return internal::BuilderAppend(typed_builder_, obj);\n   }\n };\n \n@@ -747,32 +577,7 @@ class UTF8Converter : public TypedConverterVisitor<StringBuilder, UTF8Converter>\n  public:\n   // Append a non-missing item\n   Status AppendItem(PyObject* obj) {\n-    PyObject* bytes_obj;\n-    OwnedRef tmp;\n-    const char* bytes;\n-    Py_ssize_t length;\n-\n-    if (PyBytes_Check(obj)) {\n-      tmp.reset(\n-          PyUnicode_FromStringAndSize(PyBytes_AS_STRING(obj), PyBytes_GET_SIZE(obj)));\n-      RETURN_IF_PYERROR();\n-      bytes_obj = obj;\n-    } else if (!PyUnicode_Check(obj)) {\n-      OwnedRef repr(PyObject_Repr(obj));\n-      PyObjectStringify stringified(repr.obj());\n-      std::stringstream ss;\n-      ss << \"Non bytes/unicode value encountered: \" << stringified.bytes;\n-      return Status::Invalid(ss.str());\n-    } else {\n-      tmp.reset(PyUnicode_AsUTF8String(obj));\n-      RETURN_IF_PYERROR();\n-      bytes_obj = tmp.obj();\n-    }\n-\n-    // No error checking\n-    length = PyBytes_GET_SIZE(bytes_obj);\n-    bytes = PyBytes_AS_STRING(bytes_obj);\n-    return typed_builder_->Append(bytes, static_cast<int32_t>(length));\n+    return internal::BuilderAppend(typed_builder_, obj, true /* check_valid */);\n   }\n };\n \n@@ -876,21 +681,21 @@ std::unique_ptr<SeqConverter> GetConverter(const std::shared_ptr<DataType>& type\n     case Type::BOOL:\n       return std::unique_ptr<SeqConverter>(new BoolConverter);\n     case Type::INT8:\n-      return std::unique_ptr<SeqConverter>(new Int8Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<Int8Type>);\n     case Type::INT16:\n-      return std::unique_ptr<SeqConverter>(new Int16Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<Int16Type>);\n     case Type::INT32:\n-      return std::unique_ptr<SeqConverter>(new Int32Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<Int32Type>);\n     case Type::INT64:\n-      return std::unique_ptr<SeqConverter>(new Int64Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<Int64Type>);\n     case Type::UINT8:\n-      return std::unique_ptr<SeqConverter>(new UInt8Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<UInt8Type>);\n     case Type::UINT16:\n-      return std::unique_ptr<SeqConverter>(new UInt16Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<UInt16Type>);\n     case Type::UINT32:\n-      return std::unique_ptr<SeqConverter>(new UInt32Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<UInt32Type>);\n     case Type::UINT64:\n-      return std::unique_ptr<SeqConverter>(new UInt64Converter);\n+      return std::unique_ptr<SeqConverter>(new TypedIntConverter<UInt64Type>);\n     case Type::DATE32:\n       return std::unique_ptr<SeqConverter>(new Date32Converter);\n     case Type::DATE64:\n@@ -1032,16 +837,5 @@ Status ConvertPySequence(PyObject* obj, int64_t size,\n   return ConvertPySequenceReal(obj, size, &type, pool, out);\n }\n \n-Status CheckPythonBytesAreFixedLength(PyObject* obj, Py_ssize_t expected_length) {\n-  const Py_ssize_t length = PyBytes_GET_SIZE(obj);\n-  if (length != expected_length) {\n-    std::stringstream ss;\n-    ss << \"Found byte string of length \" << length << \", expected length is \"\n-       << expected_length;\n-    return Status::Invalid(ss.str());\n-  }\n-  return Status::OK();\n-}\n-\n }  // namespace py\n }  // namespace arrow\ndiff --git a/cpp/src/arrow/python/builtin_convert.h b/cpp/src/arrow/python/builtin_convert.h\nindex 4bd3f08ed..7a32bec89 100644\n--- a/cpp/src/arrow/python/builtin_convert.h\n+++ b/cpp/src/arrow/python/builtin_convert.h\n@@ -73,9 +73,6 @@ ARROW_EXPORT\n Status InvalidConversion(PyObject* obj, const std::string& expected_type_name,\n                          std::ostream* out);\n \n-ARROW_EXPORT Status CheckPythonBytesAreFixedLength(PyObject* obj,\n-                                                   Py_ssize_t expected_length);\n-\n }  // namespace py\n }  // namespace arrow\n \ndiff --git a/cpp/src/arrow/python/common.cc b/cpp/src/arrow/python/common.cc\nindex 1ded88071..bd13f2917 100644\n--- a/cpp/src/arrow/python/common.cc\n+++ b/cpp/src/arrow/python/common.cc\n@@ -25,6 +25,8 @@\n #include \"arrow/status.h\"\n #include \"arrow/util/logging.h\"\n \n+#include \"arrow/python/helpers.h\"\n+\n namespace arrow {\n namespace py {\n \n@@ -87,19 +89,15 @@ Status CheckPyError(StatusCode code) {\n     PyObject* exc_value = nullptr;\n     PyObject* traceback = nullptr;\n \n-    OwnedRef exc_type_ref(exc_type);\n-    OwnedRef exc_value_ref(exc_value);\n-    OwnedRef traceback_ref(traceback);\n-\n     PyErr_Fetch(&exc_type, &exc_value, &traceback);\n-\n     PyErr_NormalizeException(&exc_type, &exc_value, &traceback);\n \n-    OwnedRef exc_value_str(PyObject_Str(exc_value));\n-    PyObjectStringify stringified(exc_value_str.obj());\n-    std::string message(stringified.bytes);\n+    OwnedRef exc_type_ref(exc_type);\n+    OwnedRef exc_value_ref(exc_value);\n+    OwnedRef traceback_ref(traceback);\n \n-    PyErr_Clear();\n+    std::string message;\n+    RETURN_NOT_OK(internal::PyObject_StdStringStr(exc_value, &message));\n     return Status(code, message);\n   }\n   return Status::OK();\ndiff --git a/cpp/src/arrow/python/common.h b/cpp/src/arrow/python/common.h\nindex b2844b18c..76aee16e1 100644\n--- a/cpp/src/arrow/python/common.h\n+++ b/cpp/src/arrow/python/common.h\n@@ -19,7 +19,9 @@\n #define ARROW_PYTHON_COMMON_H\n \n #include <memory>\n+#include <sstream>\n #include <string>\n+#include <utility>\n \n #include \"arrow/python/config.h\"\n \n@@ -33,6 +35,15 @@ class MemoryPool;\n \n namespace py {\n \n+ARROW_EXPORT Status CheckPyError(StatusCode code = StatusCode::UnknownError);\n+\n+ARROW_EXPORT Status PassPyError();\n+\n+// TODO(wesm): We can just let errors pass through. To be explored later\n+#define RETURN_IF_PYERROR() RETURN_NOT_OK(CheckPyError());\n+\n+#define PY_RETURN_IF_ERROR(CODE) RETURN_NOT_OK(CheckPyError(CODE));\n+\n class ARROW_EXPORT PyAcquireGIL {\n  public:\n   PyAcquireGIL() : acquired_gil_(false) { acquire(); }\n@@ -70,6 +81,11 @@ class ARROW_EXPORT OwnedRef {\n   OwnedRef(OwnedRef&& other) : OwnedRef(other.detach()) {}\n   explicit OwnedRef(PyObject* obj) : obj_(obj) {}\n \n+  OwnedRef& operator=(OwnedRef&& other) {\n+    obj_ = other.detach();\n+    return *this;\n+  }\n+\n   ~OwnedRef() { reset(); }\n \n   void reset(PyObject* obj) {\n@@ -89,6 +105,8 @@ class ARROW_EXPORT OwnedRef {\n \n   PyObject** ref() { return &obj_; }\n \n+  operator bool() const { return obj_ != NULLPTR; }\n+\n  private:\n   ARROW_DISALLOW_COPY_AND_ASSIGN(OwnedRef);\n \n@@ -110,36 +128,72 @@ class ARROW_EXPORT OwnedRefNoGIL : public OwnedRef {\n   }\n };\n \n-struct ARROW_EXPORT PyObjectStringify {\n-  OwnedRef tmp_obj;\n+// A temporary conversion of a Python object to a bytes area.\n+struct ARROW_EXPORT PyBytesView {\n   const char* bytes;\n   Py_ssize_t size;\n \n-  explicit PyObjectStringify(PyObject* obj) {\n-    PyObject* bytes_obj;\n+  PyBytesView() : bytes(nullptr), size(0), ref(nullptr) {}\n+\n+  // View the given Python object as binary-like, i.e. bytes\n+  Status FromBinary(PyObject* obj) { return FromBinary(obj, \"a bytes object\"); }\n+\n+  // View the given Python object as string-like, i.e. str or (utf8) bytes\n+  Status FromString(PyObject* obj, bool check_valid = false) {\n     if (PyUnicode_Check(obj)) {\n-      bytes_obj = PyUnicode_AsUTF8String(obj);\n-      tmp_obj.reset(bytes_obj);\n-      bytes = PyBytes_AsString(bytes_obj);\n-      size = PyBytes_GET_SIZE(bytes_obj);\n-    } else if (PyBytes_Check(obj)) {\n-      bytes = PyBytes_AsString(obj);\n-      size = PyBytes_GET_SIZE(obj);\n+#if PY_MAJOR_VERSION >= 3\n+      Py_ssize_t size;\n+      // The utf-8 representation is cached on the unicode object\n+      const char* data = PyUnicode_AsUTF8AndSize(obj, &size);\n+      RETURN_IF_PYERROR();\n+      this->bytes = data;\n+      this->size = size;\n+      this->ref.reset();\n+      return Status::OK();\n+#else\n+      PyObject* converted = PyUnicode_AsUTF8String(obj);\n+      RETURN_IF_PYERROR();\n+      this->bytes = PyBytes_AS_STRING(converted);\n+      this->size = PyBytes_GET_SIZE(converted);\n+      this->ref.reset(converted);\n+      return Status::OK();\n+#endif\n     } else {\n-      bytes = NULLPTR;\n-      size = -1;\n+      RETURN_NOT_OK(FromBinary(obj, \"a string or bytes object\"));\n+      if (check_valid) {\n+        // Check the bytes are valid utf-8\n+        OwnedRef decoded(PyUnicode_FromStringAndSize(bytes, size));\n+        RETURN_IF_PYERROR();\n+      }\n+      return Status::OK();\n     }\n   }\n-};\n-\n-Status CheckPyError(StatusCode code = StatusCode::UnknownError);\n \n-Status PassPyError();\n-\n-// TODO(wesm): We can just let errors pass through. To be explored later\n-#define RETURN_IF_PYERROR() RETURN_NOT_OK(CheckPyError());\n+ protected:\n+  PyBytesView(const char* b, Py_ssize_t s, PyObject* obj = nullptr)\n+      : bytes(b), size(s), ref(obj) {}\n+\n+  Status FromBinary(PyObject* obj, const char* expected_msg) {\n+    if (PyBytes_Check(obj)) {\n+      this->bytes = PyBytes_AS_STRING(obj);\n+      this->size = PyBytes_GET_SIZE(obj);\n+      this->ref.reset();\n+      return Status::OK();\n+    } else if (PyByteArray_Check(obj)) {\n+      this->bytes = PyByteArray_AS_STRING(obj);\n+      this->size = PyByteArray_GET_SIZE(obj);\n+      this->ref.reset();\n+      return Status::OK();\n+    } else {\n+      std::stringstream ss;\n+      ss << \"Expected \" << expected_msg << \", got a '\" << Py_TYPE(obj)->tp_name\n+         << \"' object\";\n+      return Status::TypeError(ss.str());\n+    }\n+  }\n \n-#define PY_RETURN_IF_ERROR(CODE) RETURN_NOT_OK(CheckPyError(CODE));\n+  OwnedRef ref;\n+};\n \n // Return the common PyArrow memory pool\n ARROW_EXPORT void set_default_memory_pool(MemoryPool* pool);\ndiff --git a/cpp/src/arrow/python/decimal.cc b/cpp/src/arrow/python/decimal.cc\nnew file mode 100644\nindex 000000000..10593c729\n--- /dev/null\n+++ b/cpp/src/arrow/python/decimal.cc\n@@ -0,0 +1,201 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#include <algorithm>\n+#include <limits>\n+\n+#include \"arrow/python/common.h\"\n+#include \"arrow/python/decimal.h\"\n+#include \"arrow/python/helpers.h\"\n+#include \"arrow/util/decimal.h\"\n+#include \"arrow/util/logging.h\"\n+\n+#include <arrow/api.h>\n+\n+namespace arrow {\n+namespace py {\n+namespace internal {\n+\n+Status ImportDecimalType(OwnedRef* decimal_type) {\n+  OwnedRef decimal_module;\n+  RETURN_NOT_OK(ImportModule(\"decimal\", &decimal_module));\n+  RETURN_NOT_OK(ImportFromModule(decimal_module, \"Decimal\", decimal_type));\n+  return Status::OK();\n+}\n+\n+Status PythonDecimalToString(PyObject* python_decimal, std::string* out) {\n+  // Call Python's str(decimal_object)\n+  return PyObject_StdStringStr(python_decimal, out);\n+}\n+\n+// \\brief Infer the precision and scale of a Python decimal.Decimal instance\n+// \\param python_decimal[in] An instance of decimal.Decimal\n+// \\param precision[out] The value of the inferred precision\n+// \\param scale[out] The value of the inferred scale\n+// \\return The status of the operation\n+static Status InferDecimalPrecisionAndScale(PyObject* python_decimal, int32_t* precision,\n+                                            int32_t* scale) {\n+  DCHECK_NE(python_decimal, NULLPTR);\n+  DCHECK_NE(precision, NULLPTR);\n+  DCHECK_NE(scale, NULLPTR);\n+\n+  // TODO(phillipc): Make sure we perform PyDecimal_Check(python_decimal) as a DCHECK\n+  OwnedRef as_tuple(PyObject_CallMethod(python_decimal, const_cast<char*>(\"as_tuple\"),\n+                                        const_cast<char*>(\"\")));\n+  RETURN_IF_PYERROR();\n+  DCHECK(PyTuple_Check(as_tuple.obj()));\n+\n+  OwnedRef digits(PyObject_GetAttrString(as_tuple.obj(), \"digits\"));\n+  RETURN_IF_PYERROR();\n+  DCHECK(PyTuple_Check(digits.obj()));\n+\n+  const auto num_digits = static_cast<int32_t>(PyTuple_Size(digits.obj()));\n+  RETURN_IF_PYERROR();\n+\n+  OwnedRef py_exponent(PyObject_GetAttrString(as_tuple.obj(), \"exponent\"));\n+  RETURN_IF_PYERROR();\n+  DCHECK(IsPyInteger(py_exponent.obj()));\n+\n+  const auto exponent = static_cast<int32_t>(PyLong_AsLong(py_exponent.obj()));\n+  RETURN_IF_PYERROR();\n+\n+  const int32_t abs_exponent = std::abs(exponent);\n+\n+  int32_t num_additional_zeros;\n+\n+  if (num_digits <= abs_exponent) {\n+    DCHECK_NE(exponent, 0) << \"exponent should never be zero here\";\n+\n+    // we have leading/trailing zeros, leading if exponent is negative\n+    num_additional_zeros = exponent < 0 ? abs_exponent - num_digits : exponent;\n+    *scale = static_cast<int32_t>(exponent < 0) * -exponent;\n+  } else {\n+    // we can use the number of digits as the precision\n+    num_additional_zeros = 0;\n+    *scale = -exponent;\n+  }\n+\n+  *precision = num_digits + num_additional_zeros;\n+  return Status::OK();\n+}\n+\n+PyObject* DecimalFromString(PyObject* decimal_constructor,\n+                            const std::string& decimal_string) {\n+  DCHECK_NE(decimal_constructor, nullptr);\n+\n+  auto string_size = decimal_string.size();\n+  DCHECK_GT(string_size, 0);\n+\n+  auto string_bytes = decimal_string.c_str();\n+  DCHECK_NE(string_bytes, nullptr);\n+\n+  return PyObject_CallFunction(decimal_constructor, const_cast<char*>(\"s#\"), string_bytes,\n+                               string_size);\n+}\n+\n+Status DecimalFromPythonDecimal(PyObject* python_decimal, const DecimalType& arrow_type,\n+                                Decimal128* out) {\n+  DCHECK_NE(python_decimal, NULLPTR);\n+  DCHECK_NE(out, NULLPTR);\n+\n+  std::string string;\n+  RETURN_NOT_OK(PythonDecimalToString(python_decimal, &string));\n+\n+  int32_t inferred_precision;\n+  int32_t inferred_scale;\n+\n+  RETURN_NOT_OK(\n+      Decimal128::FromString(string, out, &inferred_precision, &inferred_scale));\n+\n+  const int32_t precision = arrow_type.precision();\n+  const int32_t scale = arrow_type.scale();\n+\n+  if (ARROW_PREDICT_FALSE(inferred_precision > precision)) {\n+    std::stringstream buf;\n+    buf << \"Decimal type with precision \" << inferred_precision\n+        << \" does not fit into precision inferred from first array element: \"\n+        << precision;\n+    return Status::Invalid(buf.str());\n+  }\n+\n+  if (scale != inferred_scale) {\n+    DCHECK_NE(out, NULLPTR);\n+    RETURN_NOT_OK(out->Rescale(inferred_scale, scale, out));\n+  }\n+  return Status::OK();\n+}\n+\n+bool PyDecimal_Check(PyObject* obj) {\n+  static OwnedRef decimal_type;\n+  if (!decimal_type.obj()) {\n+    Status status = ImportDecimalType(&decimal_type);\n+    DCHECK_OK(status);\n+    DCHECK(PyType_Check(decimal_type.obj()));\n+  }\n+  // PyObject_IsInstance() is slower as it has to check for virtual subclasses\n+  const int result =\n+      PyType_IsSubtype(Py_TYPE(obj), reinterpret_cast<PyTypeObject*>(decimal_type.obj()));\n+  DCHECK_NE(result, -1) << \" error during PyType_IsSubtype check\";\n+  return result == 1;\n+}\n+\n+bool PyDecimal_ISNAN(PyObject* obj) {\n+  DCHECK(PyDecimal_Check(obj)) << \"obj is not an instance of decimal.Decimal\";\n+  OwnedRef is_nan(\n+      PyObject_CallMethod(obj, const_cast<char*>(\"is_nan\"), const_cast<char*>(\"\")));\n+  return PyObject_IsTrue(is_nan.obj()) == 1;\n+}\n+\n+DecimalMetadata::DecimalMetadata()\n+    : DecimalMetadata(std::numeric_limits<int32_t>::min(),\n+                      std::numeric_limits<int32_t>::min()) {}\n+\n+DecimalMetadata::DecimalMetadata(int32_t precision, int32_t scale)\n+    : precision_(precision), scale_(scale) {}\n+\n+Status DecimalMetadata::Update(int32_t suggested_precision, int32_t suggested_scale) {\n+  const int32_t current_precision = precision_;\n+  precision_ = std::max(current_precision, suggested_precision);\n+\n+  const int32_t current_scale = scale_;\n+  scale_ = std::max(current_scale, suggested_scale);\n+\n+  // if our suggested scale is zero and we don't yet have enough precision then we need to\n+  // add whatever the current scale is to the precision\n+  if (suggested_scale == 0 && suggested_precision > current_precision) {\n+    precision_ += scale_;\n+  }\n+\n+  return Status::OK();\n+}\n+\n+Status DecimalMetadata::Update(PyObject* object) {\n+  DCHECK(PyDecimal_Check(object)) << \"Object is not a Python Decimal\";\n+\n+  if (ARROW_PREDICT_FALSE(PyDecimal_ISNAN(object))) {\n+    return Status::OK();\n+  }\n+\n+  int32_t precision;\n+  int32_t scale;\n+  RETURN_NOT_OK(InferDecimalPrecisionAndScale(object, &precision, &scale));\n+  return Update(precision, scale);\n+}\n+\n+}  // namespace internal\n+}  // namespace py\n+}  // namespace arrow\ndiff --git a/cpp/src/arrow/python/decimal.h b/cpp/src/arrow/python/decimal.h\nnew file mode 100644\nindex 000000000..41d821f4e\n--- /dev/null\n+++ b/cpp/src/arrow/python/decimal.h\n@@ -0,0 +1,96 @@\n+// Licensed to the Apache Software Foundation (ASF) under one\n+// or more contributor license agreements.  See the NOTICE file\n+// distributed with this work for additional information\n+// regarding copyright ownership.  The ASF licenses this file\n+// to you under the Apache License, Version 2.0 (the\n+// \"License\"); you may not use this file except in compliance\n+// with the License.  You may obtain a copy of the License at\n+//\n+//   http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing,\n+// software distributed under the License is distributed on an\n+// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+// KIND, either express or implied.  See the License for the\n+// specific language governing permissions and limitations\n+// under the License.\n+\n+#ifndef ARROW_PYTHON_DECIMAL_H\n+#define ARROW_PYTHON_DECIMAL_H\n+\n+#include <string>\n+\n+#include \"arrow/type.h\"\n+\n+namespace arrow {\n+\n+class Decimal128;\n+\n+namespace py {\n+\n+//\n+// Python Decimal support\n+//\n+\n+namespace internal {\n+\n+// \\brief Import the Python Decimal type\n+Status ImportDecimalType(OwnedRef* decimal_type);\n+\n+// \\brief Convert a Python Decimal object to a C++ string\n+// \\param[in] python_decimal A Python decimal.Decimal instance\n+// \\param[out] The string representation of the Python Decimal instance\n+// \\return The status of the operation\n+Status PythonDecimalToString(PyObject* python_decimal, std::string* out);\n+\n+// \\brief Convert a C++ std::string to a Python Decimal instance\n+// \\param[in] decimal_constructor The decimal type object\n+// \\param[in] decimal_string A decimal string\n+// \\return An instance of decimal.Decimal\n+PyObject* DecimalFromString(PyObject* decimal_constructor,\n+                            const std::string& decimal_string);\n+\n+// \\brief Convert a Python decimal to an Arrow Decimal128 object\n+// \\param[in] python_decimal A Python decimal.Decimal instance\n+// \\param[in] arrow_type An instance of arrow::DecimalType\n+// \\param[out] out A pointer to a Decimal128\n+// \\return The status of the operation\n+Status DecimalFromPythonDecimal(PyObject* python_decimal, const DecimalType& arrow_type,\n+                                Decimal128* out);\n+\n+// \\brief Check whether obj is an instance of Decimal\n+bool PyDecimal_Check(PyObject* obj);\n+\n+// \\brief Check whether obj is nan. This function will abort the program if the argument\n+// is not a Decimal instance\n+bool PyDecimal_ISNAN(PyObject* obj);\n+\n+// \\brief Helper class to track and update the precision and scale of a decimal\n+class DecimalMetadata {\n+ public:\n+  DecimalMetadata();\n+  DecimalMetadata(int32_t precision, int32_t scale);\n+\n+  // \\brief Adjust the precision and scale of a decimal type given a new precision and a\n+  // new scale \\param[in] suggested_precision A candidate precision \\param[in]\n+  // suggested_scale A candidate scale \\return The status of the operation\n+  Status Update(int32_t suggested_precision, int32_t suggested_scale);\n+\n+  // \\brief A convenient interface for updating the precision and scale based on a Python\n+  // Decimal object \\param object A Python Decimal object \\return The status of the\n+  // operation\n+  Status Update(PyObject* object);\n+\n+  int32_t precision() const { return precision_; }\n+  int32_t scale() const { return scale_; }\n+\n+ private:\n+  int32_t precision_;\n+  int32_t scale_;\n+};\n+\n+}  // namespace internal\n+}  // namespace py\n+}  // namespace arrow\n+\n+#endif  // ARROW_PYTHON_DECIMAL_H\ndiff --git a/cpp/src/arrow/python/helpers.cc b/cpp/src/arrow/python/helpers.cc\nindex 4fd9ef26b..bb0837cd5 100644\n--- a/cpp/src/arrow/python/helpers.cc\n+++ b/cpp/src/arrow/python/helpers.cc\n@@ -15,13 +15,14 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-#include <algorithm>\n #include <limits>\n #include <sstream>\n+#include <type_traits>\n+#include <typeinfo>\n \n #include \"arrow/python/common.h\"\n+#include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n-#include \"arrow/util/decimal.h\"\n #include \"arrow/util/logging.h\"\n \n #include <arrow/api.h>\n@@ -78,6 +79,60 @@ Status PyFloat_AsHalf(PyObject* obj, npy_half* out) {\n \n namespace internal {\n \n+std::string PyBytes_AsStdString(PyObject* obj) {\n+  DCHECK(PyBytes_Check(obj));\n+  return std::string(PyBytes_AS_STRING(obj), PyBytes_GET_SIZE(obj));\n+}\n+\n+Status PyUnicode_AsStdString(PyObject* obj, std::string* out) {\n+  DCHECK(PyUnicode_Check(obj));\n+#if PY_MAJOR_VERSION >= 3\n+  Py_ssize_t size;\n+  // The utf-8 representation is cached on the unicode object\n+  const char* data = PyUnicode_AsUTF8AndSize(obj, &size);\n+  RETURN_IF_PYERROR();\n+  *out = std::string(data, size);\n+  return Status::OK();\n+#else\n+  OwnedRef bytes_ref(PyUnicode_AsUTF8String(obj));\n+  RETURN_IF_PYERROR();\n+  *out = PyBytes_AsStdString(bytes_ref.obj());\n+  return Status::OK();\n+#endif\n+}\n+\n+std::string PyObject_StdStringRepr(PyObject* obj) {\n+#if PY_MAJOR_VERSION >= 3\n+  OwnedRef unicode_ref(PyObject_Repr(obj));\n+  OwnedRef bytes_ref;\n+\n+  if (unicode_ref) {\n+    bytes_ref.reset(\n+        PyUnicode_AsEncodedString(unicode_ref.obj(), \"utf8\", \"backslashreplace\"));\n+  }\n+#else\n+  OwnedRef bytes_ref(PyObject_Repr(obj));\n+  if (!bytes_ref) {\n+    PyErr_Clear();\n+    std::stringstream ss;\n+    ss << \"<object of type '\" << Py_TYPE(obj)->tp_name << \"' repr() failed>\";\n+    return ss.str();\n+  }\n+#endif\n+  return PyBytes_AsStdString(bytes_ref.obj());\n+}\n+\n+Status PyObject_StdStringStr(PyObject* obj, std::string* out) {\n+  OwnedRef string_ref(PyObject_Str(obj));\n+  RETURN_IF_PYERROR();\n+#if PY_MAJOR_VERSION >= 3\n+  return PyUnicode_AsStdString(string_ref.obj(), out);\n+#else\n+  *out = PyBytes_AsStdString(string_ref.obj());\n+  return Status::OK();\n+#endif\n+}\n+\n Status ImportModule(const std::string& module_name, OwnedRef* ref) {\n   PyObject* module = PyImport_ImportModule(module_name.c_str());\n   RETURN_IF_PYERROR();\n@@ -97,209 +152,177 @@ Status ImportFromModule(const OwnedRef& module, const std::string& name, OwnedRe\n   return Status::OK();\n }\n \n-Status ImportDecimalType(OwnedRef* decimal_type) {\n-  OwnedRef decimal_module;\n-  RETURN_NOT_OK(ImportModule(\"decimal\", &decimal_module));\n-  RETURN_NOT_OK(ImportFromModule(decimal_module, \"Decimal\", decimal_type));\n+Status BuilderAppend(BinaryBuilder* builder, PyObject* obj, bool* is_full) {\n+  PyBytesView view;\n+  // XXX For some reason, we must accept unicode objects here\n+  RETURN_NOT_OK(view.FromString(obj));\n+  int32_t length;\n+  RETURN_NOT_OK(CastSize(view.size, &length));\n+  // Did we reach the builder size limit?\n+  if (ARROW_PREDICT_FALSE(builder->value_data_length() + length > kBinaryMemoryLimit)) {\n+    if (is_full) {\n+      *is_full = true;\n+      return Status::OK();\n+    } else {\n+      return Status::Invalid(\"Maximum array size reached (2GB)\");\n+    }\n+  }\n+  RETURN_NOT_OK(builder->Append(view.bytes, length));\n+  if (is_full) {\n+    *is_full = false;\n+  }\n   return Status::OK();\n }\n \n-Status PythonDecimalToString(PyObject* python_decimal, std::string* out) {\n-  // Call Python's str(decimal_object)\n-  OwnedRef str_obj(PyObject_Str(python_decimal));\n-  RETURN_IF_PYERROR();\n-\n-  PyObjectStringify str(str_obj.obj());\n-  RETURN_IF_PYERROR();\n-\n-  const char* bytes = str.bytes;\n-  DCHECK_NE(bytes, nullptr);\n-\n-  Py_ssize_t size = str.size;\n-\n-  std::string c_string(bytes, size);\n-  *out = c_string;\n+Status BuilderAppend(FixedSizeBinaryBuilder* builder, PyObject* obj, bool* is_full) {\n+  PyBytesView view;\n+  // XXX For some reason, we must accept unicode objects here\n+  RETURN_NOT_OK(view.FromString(obj));\n+  const auto expected_length =\n+      static_cast<const FixedSizeBinaryType&>(*builder->type()).byte_width();\n+  if (ARROW_PREDICT_FALSE(view.size != expected_length)) {\n+    std::stringstream ss;\n+    ss << \"Got bytestring of length \" << view.size << \" (expected \" << expected_length\n+       << \")\";\n+    return Status::Invalid(ss.str());\n+  }\n+  // Did we reach the builder size limit?\n+  if (ARROW_PREDICT_FALSE(builder->value_data_length() + view.size >\n+                          kBinaryMemoryLimit)) {\n+    if (is_full) {\n+      *is_full = true;\n+      return Status::OK();\n+    } else {\n+      return Status::Invalid(\"Maximum array size reached (2GB)\");\n+    }\n+  }\n+  RETURN_NOT_OK(builder->Append(view.bytes));\n+  if (is_full) {\n+    *is_full = false;\n+  }\n   return Status::OK();\n }\n \n-// \\brief Infer the precision and scale of a Python decimal.Decimal instance\n-// \\param python_decimal[in] An instance of decimal.Decimal\n-// \\param precision[out] The value of the inferred precision\n-// \\param scale[out] The value of the inferred scale\n-// \\return The status of the operation\n-static Status InferDecimalPrecisionAndScale(PyObject* python_decimal, int32_t* precision,\n-                                            int32_t* scale) {\n-  DCHECK_NE(python_decimal, NULLPTR);\n-  DCHECK_NE(precision, NULLPTR);\n-  DCHECK_NE(scale, NULLPTR);\n-\n-  // TODO(phillipc): Make sure we perform PyDecimal_Check(python_decimal) as a DCHECK\n-  OwnedRef as_tuple(PyObject_CallMethod(python_decimal, const_cast<char*>(\"as_tuple\"),\n-                                        const_cast<char*>(\"\")));\n-  RETURN_IF_PYERROR();\n-  DCHECK(PyTuple_Check(as_tuple.obj()));\n-\n-  OwnedRef digits(PyObject_GetAttrString(as_tuple.obj(), \"digits\"));\n-  RETURN_IF_PYERROR();\n-  DCHECK(PyTuple_Check(digits.obj()));\n-\n-  const auto num_digits = static_cast<int32_t>(PyTuple_Size(digits.obj()));\n-  RETURN_IF_PYERROR();\n-\n-  OwnedRef py_exponent(PyObject_GetAttrString(as_tuple.obj(), \"exponent\"));\n-  RETURN_IF_PYERROR();\n-  DCHECK(IsPyInteger(py_exponent.obj()));\n-\n-  const auto exponent = static_cast<int32_t>(PyLong_AsLong(py_exponent.obj()));\n-  RETURN_IF_PYERROR();\n-\n-  const int32_t abs_exponent = std::abs(exponent);\n-\n-  int32_t num_additional_zeros;\n-\n-  if (num_digits <= abs_exponent) {\n-    DCHECK_NE(exponent, 0) << \"exponent should never be zero here\";\n-\n-    // we have leading/trailing zeros, leading if exponent is negative\n-    num_additional_zeros = exponent < 0 ? abs_exponent - num_digits : exponent;\n-    *scale = static_cast<int32_t>(exponent < 0) * -exponent;\n-  } else {\n-    // we can use the number of digits as the precision\n-    num_additional_zeros = 0;\n-    *scale = -exponent;\n+Status BuilderAppend(StringBuilder* builder, PyObject* obj, bool check_valid,\n+                     bool* is_full) {\n+  PyBytesView view;\n+  RETURN_NOT_OK(view.FromString(obj, check_valid));\n+  int32_t length;\n+  RETURN_NOT_OK(CastSize(view.size, &length));\n+  // Did we reach the builder size limit?\n+  if (ARROW_PREDICT_FALSE(builder->value_data_length() + length > kBinaryMemoryLimit)) {\n+    if (is_full) {\n+      *is_full = true;\n+      return Status::OK();\n+    } else {\n+      return Status::Invalid(\"Maximum array size reached (2GB)\");\n+    }\n+  }\n+  RETURN_NOT_OK(builder->Append(view.bytes, length));\n+  if (is_full) {\n+    *is_full = false;\n   }\n-\n-  *precision = num_digits + num_additional_zeros;\n   return Status::OK();\n }\n \n-PyObject* DecimalFromString(PyObject* decimal_constructor,\n-                            const std::string& decimal_string) {\n-  DCHECK_NE(decimal_constructor, nullptr);\n-\n-  auto string_size = decimal_string.size();\n-  DCHECK_GT(string_size, 0);\n-\n-  auto string_bytes = decimal_string.c_str();\n-  DCHECK_NE(string_bytes, nullptr);\n-\n-  return PyObject_CallFunction(decimal_constructor, const_cast<char*>(\"s#\"), string_bytes,\n-                               string_size);\n-}\n-\n-Status DecimalFromPythonDecimal(PyObject* python_decimal, const DecimalType& arrow_type,\n-                                Decimal128* out) {\n-  DCHECK_NE(python_decimal, NULLPTR);\n-  DCHECK_NE(out, NULLPTR);\n-\n-  std::string string;\n-  RETURN_NOT_OK(PythonDecimalToString(python_decimal, &string));\n+namespace {\n \n-  int32_t inferred_precision;\n-  int32_t inferred_scale;\n-\n-  RETURN_NOT_OK(\n-      Decimal128::FromString(string, out, &inferred_precision, &inferred_scale));\n-\n-  const int32_t precision = arrow_type.precision();\n-  const int32_t scale = arrow_type.scale();\n-\n-  if (ARROW_PREDICT_FALSE(inferred_precision > precision)) {\n-    std::stringstream buf;\n-    buf << \"Decimal type with precision \" << inferred_precision\n-        << \" does not fit into precision inferred from first array element: \"\n-        << precision;\n-    return Status::Invalid(buf.str());\n+Status IntegerOverflowStatus(const std::string& overflow_message) {\n+  if (overflow_message.empty()) {\n+    return Status::Invalid(\"Value too large to fit in C integer type\");\n+  } else {\n+    return Status::Invalid(overflow_message);\n   }\n+}\n \n-  if (scale != inferred_scale) {\n-    DCHECK_NE(out, NULLPTR);\n-    RETURN_NOT_OK(out->Rescale(inferred_scale, scale, out));\n+// Extract C signed int from Python object\n+template <typename Int,\n+          typename std::enable_if<std::is_signed<Int>::value, Int>::type = 0>\n+Status CIntFromPythonImpl(PyObject* obj, Int* out, const std::string& overflow_message) {\n+  static_assert(sizeof(Int) <= sizeof(long long),  // NOLINT\n+                \"integer type larger than long long\");\n+\n+  if (sizeof(Int) > sizeof(long)) {  // NOLINT\n+    const auto value = PyLong_AsLongLong(obj);\n+    if (ARROW_PREDICT_FALSE(value == -1)) {\n+      RETURN_IF_PYERROR();\n+    }\n+    if (ARROW_PREDICT_FALSE(value < std::numeric_limits<Int>::min() ||\n+                            value > std::numeric_limits<Int>::max())) {\n+      return IntegerOverflowStatus(overflow_message);\n+    }\n+    *out = static_cast<Int>(value);\n+  } else {\n+    const auto value = PyLong_AsLong(obj);\n+    if (ARROW_PREDICT_FALSE(value == -1)) {\n+      RETURN_IF_PYERROR();\n+    }\n+    if (ARROW_PREDICT_FALSE(value < std::numeric_limits<Int>::min() ||\n+                            value > std::numeric_limits<Int>::max())) {\n+      return IntegerOverflowStatus(overflow_message);\n+    }\n+    *out = static_cast<Int>(value);\n   }\n   return Status::OK();\n }\n \n-bool IsPyInteger(PyObject* obj) {\n-#if PYARROW_IS_PY2\n-  return PyLong_Check(obj) || PyInt_Check(obj);\n-#else\n-  return PyLong_Check(obj);\n-#endif\n-}\n+// Extract C unsigned int from Python object\n+template <typename Int,\n+          typename std::enable_if<std::is_unsigned<Int>::value, Int>::type = 0>\n+Status CIntFromPythonImpl(PyObject* obj, Int* out, const std::string& overflow_message) {\n+  static_assert(sizeof(Int) <= sizeof(unsigned long long),  // NOLINT\n+                \"integer type larger than unsigned long long\");\n \n-Status UInt64FromPythonInt(PyObject* obj, uint64_t* out) {\n   OwnedRef ref;\n-  // PyLong_AsUnsignedLongLong() doesn't handle conversion from non-ints\n-  // (e.g. np.uint64), so do it ourselves\n+  // PyLong_AsUnsignedLong() and PyLong_AsUnsignedLongLong() don't handle\n+  // conversion from non-ints (e.g. np.uint64), so do it ourselves\n   if (!PyLong_Check(obj)) {\n     ref.reset(PyNumber_Long(obj));\n-    RETURN_IF_PYERROR();\n+    if (!ref) {\n+      RETURN_IF_PYERROR();\n+    }\n     obj = ref.obj();\n   }\n-  auto result = static_cast<uint64_t>(PyLong_AsUnsignedLongLong(obj));\n-  if (result == static_cast<uint64_t>(-1)) {\n-    RETURN_IF_PYERROR();\n+  if (sizeof(Int) > sizeof(unsigned long)) {  // NOLINT\n+    const auto value = PyLong_AsUnsignedLongLong(obj);\n+    if (ARROW_PREDICT_FALSE(value == static_cast<decltype(value)>(-1))) {\n+      RETURN_IF_PYERROR();\n+    }\n+    if (ARROW_PREDICT_FALSE(value > std::numeric_limits<Int>::max())) {\n+      return IntegerOverflowStatus(overflow_message);\n+    }\n+    *out = static_cast<Int>(value);\n+  } else {\n+    const auto value = PyLong_AsUnsignedLong(obj);\n+    if (ARROW_PREDICT_FALSE(value == static_cast<decltype(value)>(-1))) {\n+      RETURN_IF_PYERROR();\n+    }\n+    if (ARROW_PREDICT_FALSE(value > std::numeric_limits<Int>::max())) {\n+      return IntegerOverflowStatus(overflow_message);\n+    }\n+    *out = static_cast<Int>(value);\n   }\n-  *out = static_cast<uint64_t>(result);\n   return Status::OK();\n }\n \n-bool PyDecimal_Check(PyObject* obj) {\n-  static OwnedRef decimal_type;\n-  if (!decimal_type.obj()) {\n-    Status status = ImportDecimalType(&decimal_type);\n-    DCHECK_OK(status);\n-    DCHECK(PyType_Check(decimal_type.obj()));\n-  }\n-  // PyObject_IsInstance() is slower as it has to check for virtual subclasses\n-  const int result =\n-      PyType_IsSubtype(Py_TYPE(obj), reinterpret_cast<PyTypeObject*>(decimal_type.obj()));\n-  DCHECK_NE(result, -1) << \" error during PyType_IsSubtype check\";\n-  return result == 1;\n-}\n-\n-bool PyDecimal_ISNAN(PyObject* obj) {\n-  DCHECK(PyDecimal_Check(obj)) << \"obj is not an instance of decimal.Decimal\";\n-  OwnedRef is_nan(\n-      PyObject_CallMethod(obj, const_cast<char*>(\"is_nan\"), const_cast<char*>(\"\")));\n-  return PyObject_IsTrue(is_nan.obj()) == 1;\n-}\n-\n-DecimalMetadata::DecimalMetadata()\n-    : DecimalMetadata(std::numeric_limits<int32_t>::min(),\n-                      std::numeric_limits<int32_t>::min()) {}\n+}  // namespace\n \n-DecimalMetadata::DecimalMetadata(int32_t precision, int32_t scale)\n-    : precision_(precision), scale_(scale) {}\n-\n-Status DecimalMetadata::Update(int32_t suggested_precision, int32_t suggested_scale) {\n-  const int32_t current_precision = precision_;\n-  precision_ = std::max(current_precision, suggested_precision);\n-\n-  const int32_t current_scale = scale_;\n-  scale_ = std::max(current_scale, suggested_scale);\n-\n-  // if our suggested scale is zero and we don't yet have enough precision then we need to\n-  // add whatever the current scale is to the precision\n-  if (suggested_scale == 0 && suggested_precision > current_precision) {\n-    precision_ += scale_;\n+template <typename Int>\n+Status CIntFromPython(PyObject* obj, Int* out, const std::string& overflow_message) {\n+  if (PyBool_Check(obj)) {\n+    return Status::TypeError(\"Expected integer, got bool\");\n   }\n-\n-  return Status::OK();\n+  return CIntFromPythonImpl(obj, out, overflow_message);\n }\n \n-Status DecimalMetadata::Update(PyObject* object) {\n-  DCHECK(PyDecimal_Check(object)) << \"Object is not a Python Decimal\";\n-\n-  if (ARROW_PREDICT_FALSE(PyDecimal_ISNAN(object))) {\n-    return Status::OK();\n-  }\n-\n-  int32_t precision;\n-  int32_t scale;\n-  RETURN_NOT_OK(InferDecimalPrecisionAndScale(object, &precision, &scale));\n-  return Update(precision, scale);\n-}\n+template Status CIntFromPython(PyObject*, int8_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, int16_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, int32_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, int64_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, uint8_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, uint16_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, uint32_t*, const std::string&);\n+template Status CIntFromPython(PyObject*, uint64_t*, const std::string&);\n \n bool PyFloat_IsNaN(PyObject* obj) {\n   return PyFloat_Check(obj) && std::isnan(PyFloat_AsDouble(obj));\ndiff --git a/cpp/src/arrow/python/helpers.h b/cpp/src/arrow/python/helpers.h\nindex e2f3b1829..195d5fbf9 100644\n--- a/cpp/src/arrow/python/helpers.h\n+++ b/cpp/src/arrow/python/helpers.h\n@@ -15,11 +15,12 @@\n // specific language governing permissions and limitations\n // under the License.\n \n-#ifndef PYARROW_HELPERS_H\n-#define PYARROW_HELPERS_H\n+#ifndef ARROW_PYTHON_HELPERS_H\n+#define ARROW_PYTHON_HELPERS_H\n \n #include \"arrow/python/platform.h\"\n \n+#include <limits>\n #include <memory>\n #include <string>\n #include <utility>\n@@ -32,8 +33,6 @@\n \n namespace arrow {\n \n-class Decimal128;\n-\n namespace py {\n \n class OwnedRef;\n@@ -63,32 +62,14 @@ Status ImportModule(const std::string& module_name, OwnedRef* ref);\n // module\n Status ImportFromModule(const OwnedRef& module, const std::string& name, OwnedRef* ref);\n \n-// \\brief Import\n-Status ImportDecimalType(OwnedRef* decimal_type);\n-\n-// \\brief Convert a Python Decimal object to a C++ string\n-// \\param[in] python_decimal A Python decimal.Decimal instance\n-// \\param[out] The string representation of the Python Decimal instance\n-// \\return The status of the operation\n-Status PythonDecimalToString(PyObject* python_decimal, std::string* out);\n-\n-// \\brief Convert a C++ std::string to a Python Decimal instance\n-// \\param[in] decimal_constructor The decimal type object\n-// \\param[in] decimal_string A decimal string\n-// \\return An instance of decimal.Decimal\n-PyObject* DecimalFromString(PyObject* decimal_constructor,\n-                            const std::string& decimal_string);\n-\n-// \\brief Convert a Python decimal to an Arrow Decimal128 object\n-// \\param[in] python_decimal A Python decimal.Decimal instance\n-// \\param[in] arrow_type An instance of arrow::DecimalType\n-// \\param[out] out A pointer to a Decimal128\n-// \\return The status of the operation\n-Status DecimalFromPythonDecimal(PyObject* python_decimal, const DecimalType& arrow_type,\n-                                Decimal128* out);\n-\n // \\brief Check whether obj is an integer, independent of Python versions.\n-bool IsPyInteger(PyObject* obj);\n+inline bool IsPyInteger(PyObject* obj) {\n+#if PYARROW_IS_PY2\n+  return PyLong_Check(obj) || PyInt_Check(obj);\n+#else\n+  return PyLong_Check(obj);\n+#endif\n+}\n \n // \\brief Use pandas missing value semantics to check if a value is null\n bool PandasObjectIsNull(PyObject* obj);\n@@ -96,45 +77,48 @@ bool PandasObjectIsNull(PyObject* obj);\n // \\brief Check whether obj is nan\n bool PyFloat_IsNaN(PyObject* obj);\n \n-// \\brief Check whether obj is an instance of Decimal\n-bool PyDecimal_Check(PyObject* obj);\n-\n-// \\brief Check whether obj is nan. This function will abort the program if the argument\n-// is not a Decimal instance\n-bool PyDecimal_ISNAN(PyObject* obj);\n+inline bool IsPyBinary(PyObject* obj) {\n+  return PyBytes_Check(obj) || PyByteArray_Check(obj);\n+}\n \n-// \\brief Convert a Python integer into an unsigned 64-bit integer\n+// \\brief Convert a Python integer into a C integer\n // \\param[in] obj A Python integer\n-// \\param[out] out A pointer to a C uint64_t to hold the result of the conversion\n+// \\param[out] out A pointer to a C integer to hold the result of the conversion\n // \\return The status of the operation\n-Status UInt64FromPythonInt(PyObject* obj, uint64_t* out);\n-\n-// \\brief Helper class to track and update the precision and scale of a decimal\n-class DecimalMetadata {\n- public:\n-  DecimalMetadata();\n-  DecimalMetadata(int32_t precision, int32_t scale);\n-\n-  // \\brief Adjust the precision and scale of a decimal type given a new precision and a\n-  // new scale \\param[in] suggested_precision A candidate precision \\param[in]\n-  // suggested_scale A candidate scale \\return The status of the operation\n-  Status Update(int32_t suggested_precision, int32_t suggested_scale);\n-\n-  // \\brief A convenient interface for updating the precision and scale based on a Python\n-  // Decimal object \\param object A Python Decimal object \\return The status of the\n-  // operation\n-  Status Update(PyObject* object);\n-\n-  int32_t precision() const { return precision_; }\n-  int32_t scale() const { return scale_; }\n-\n- private:\n-  int32_t precision_;\n-  int32_t scale_;\n-};\n+template <typename Int>\n+Status CIntFromPython(PyObject* obj, Int* out, const std::string& overflow_message = \"\");\n+\n+// \\brief Convert a Python unicode string to a std::string\n+Status PyUnicode_AsStdString(PyObject* obj, std::string* out);\n+\n+// \\brief Convert a Python bytes object to a std::string\n+std::string PyBytes_AsStdString(PyObject* obj);\n+\n+// \\brief Call str() on the given object and return the result as a std::string\n+Status PyObject_StdStringStr(PyObject* obj, std::string* out);\n+\n+// \\brief Return the repr() of the given object (always succeeds)\n+std::string PyObject_StdStringRepr(PyObject* obj);\n+\n+// \\brief Cast the given size to int32_t, with error checking\n+inline Status CastSize(Py_ssize_t size, int32_t* out,\n+                       const char* error_msg = \"Maximum size exceeded (2GB)\") {\n+  // size is assumed to be positive\n+  if (size > std::numeric_limits<int32_t>::max()) {\n+    return Status::Invalid(error_msg);\n+  }\n+  *out = static_cast<int32_t>(size);\n+  return Status::OK();\n+}\n+\n+Status BuilderAppend(StringBuilder* builder, PyObject* obj, bool check_valid = false,\n+                     bool* is_full = nullptr);\n+Status BuilderAppend(BinaryBuilder* builder, PyObject* obj, bool* is_full = nullptr);\n+Status BuilderAppend(FixedSizeBinaryBuilder* builder, PyObject* obj,\n+                     bool* is_full = nullptr);\n \n }  // namespace internal\n }  // namespace py\n }  // namespace arrow\n \n-#endif  // PYARROW_HELPERS_H\n+#endif  // ARROW_PYTHON_HELPERS_H\ndiff --git a/cpp/src/arrow/python/numpy_to_arrow.cc b/cpp/src/arrow/python/numpy_to_arrow.cc\nindex eb0af8b08..e37013c7e 100644\n--- a/cpp/src/arrow/python/numpy_to_arrow.cc\n+++ b/cpp/src/arrow/python/numpy_to_arrow.cc\n@@ -49,6 +49,7 @@\n #include \"arrow/python/builtin_convert.h\"\n #include \"arrow/python/common.h\"\n #include \"arrow/python/config.h\"\n+#include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n #include \"arrow/python/numpy-internal.h\"\n #include \"arrow/python/numpy_convert.h\"\n@@ -65,14 +66,6 @@ using internal::NumPyTypeSize;\n \n namespace {\n \n-inline bool PyObject_is_string(PyObject* obj) {\n-#if PY_MAJOR_VERSION >= 3\n-  return PyUnicode_Check(obj) || PyBytes_Check(obj);\n-#else\n-  return PyString_Check(obj) || PyUnicode_Check(obj);\n-#endif\n-}\n-\n inline bool PyObject_is_integer(PyObject* obj) {\n   return !PyBool_Check(obj) && PyArray_IsIntegerScalar(obj);\n }\n@@ -204,8 +197,6 @@ int64_t MaskToBitmap(PyArrayObject* mask, int64_t length, uint8_t* bitmap) {\n static Status AppendObjectBinaries(PyArrayObject* arr, PyArrayObject* mask,\n                                    int64_t offset, BinaryBuilder* builder,\n                                    int64_t* end_offset) {\n-  PyObject* obj;\n-\n   Ndarray1DIndexer<PyObject*> objects(arr);\n   Ndarray1DIndexer<uint8_t> mask_values;\n \n@@ -216,30 +207,15 @@ static Status AppendObjectBinaries(PyArrayObject* arr, PyArrayObject* mask,\n   }\n \n   for (; offset < objects.size(); ++offset) {\n-    OwnedRef tmp_obj;\n-    obj = objects[offset];\n+    PyObject* obj = objects[offset];\n     if ((have_mask && mask_values[offset]) || internal::PandasObjectIsNull(obj)) {\n       RETURN_NOT_OK(builder->AppendNull());\n       continue;\n-    } else if (PyBytes_Check(obj)) {\n-      const int32_t length = static_cast<int32_t>(PyBytes_GET_SIZE(obj));\n-      if (ARROW_PREDICT_FALSE(builder->value_data_length() + length >\n-                              kBinaryMemoryLimit)) {\n-        break;\n-      }\n-      RETURN_NOT_OK(builder->Append(PyBytes_AS_STRING(obj), length));\n-    } else if (PyByteArray_Check(obj)) {\n-      const int32_t length = static_cast<int32_t>(PyByteArray_GET_SIZE(obj));\n-      if (ARROW_PREDICT_FALSE(builder->value_data_length() + length >\n-                              kBinaryMemoryLimit)) {\n-        break;\n-      }\n-      RETURN_NOT_OK(builder->Append(PyByteArray_AS_STRING(obj), length));\n-    } else {\n-      std::stringstream ss;\n-      ss << \"Error converting from Python objects to bytes: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"str, bytes, bytearray\", &ss));\n-      return Status::Invalid(ss.str());\n+    }\n+    bool is_full;\n+    RETURN_NOT_OK(internal::BuilderAppend(builder, obj, &is_full));\n+    if (is_full) {\n+      break;\n     }\n   }\n \n@@ -275,27 +251,16 @@ static Status AppendObjectStrings(PyArrayObject* arr, PyArrayObject* mask, int64\n     if ((have_mask && mask_values[offset]) || internal::PandasObjectIsNull(obj)) {\n       RETURN_NOT_OK(builder->AppendNull());\n       continue;\n-    } else if (PyUnicode_Check(obj)) {\n-      obj = PyUnicode_AsUTF8String(obj);\n-      if (obj == NULL) {\n-        PyErr_Clear();\n-        return Status::Invalid(\"failed converting unicode to UTF8\");\n-      }\n-      tmp_obj.reset(obj);\n-    } else if (PyBytes_Check(obj)) {\n+    }\n+    if (internal::IsPyBinary(obj)) {\n       *have_bytes = true;\n-    } else {\n-      std::stringstream ss;\n-      ss << \"Error converting from Python objects to String/UTF8: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"str, bytes\", &ss));\n-      return Status::Invalid(ss.str());\n     }\n-\n-    const int32_t length = static_cast<int32_t>(PyBytes_GET_SIZE(obj));\n-    if (ARROW_PREDICT_FALSE(builder->value_data_length() + length > kBinaryMemoryLimit)) {\n+    bool is_full;\n+    RETURN_NOT_OK(\n+        internal::BuilderAppend(builder, obj, false /* check_valid */, &is_full));\n+    if (is_full) {\n       break;\n     }\n-    RETURN_NOT_OK(builder->Append(PyBytes_AS_STRING(obj), length));\n   }\n \n   // If we consumed the whole array, this will be the length of arr\n@@ -324,28 +289,12 @@ static Status AppendObjectFixedWidthBytes(PyArrayObject* arr, PyArrayObject* mas\n     if ((have_mask && mask_values[offset]) || internal::PandasObjectIsNull(obj)) {\n       RETURN_NOT_OK(builder->AppendNull());\n       continue;\n-    } else if (PyUnicode_Check(obj)) {\n-      obj = PyUnicode_AsUTF8String(obj);\n-      if (obj == NULL) {\n-        PyErr_Clear();\n-        return Status::Invalid(\"failed converting unicode to UTF8\");\n-      }\n-\n-      tmp_obj.reset(obj);\n-    } else if (!PyBytes_Check(obj)) {\n-      std::stringstream ss;\n-      ss << \"Error converting from Python objects to FixedSizeBinary: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"str, bytes\", &ss));\n-      return Status::Invalid(ss.str());\n     }\n-\n-    RETURN_NOT_OK(CheckPythonBytesAreFixedLength(obj, byte_width));\n-    if (ARROW_PREDICT_FALSE(builder->value_data_length() + byte_width >\n-                            kBinaryMemoryLimit)) {\n+    bool is_full;\n+    RETURN_NOT_OK(internal::BuilderAppend(builder, obj, &is_full));\n+    if (is_full) {\n       break;\n     }\n-    RETURN_NOT_OK(\n-        builder->Append(reinterpret_cast<const uint8_t*>(PyBytes_AS_STRING(obj))));\n   }\n \n   // If we consumed the whole array, this will be the length of arr\n@@ -981,15 +930,10 @@ Status NumPyConverter::ConvertObjectIntegers() {\n     obj = objects[i];\n     if ((have_mask && mask_values[i]) || internal::PandasObjectIsNull(obj)) {\n       RETURN_NOT_OK(builder.AppendNull());\n-    } else if (PyObject_is_integer(obj)) {\n-      const int64_t val = static_cast<int64_t>(PyLong_AsLong(obj));\n-      RETURN_IF_PYERROR();\n-      RETURN_NOT_OK(builder.Append(val));\n     } else {\n-      std::stringstream ss;\n-      ss << \"Error converting from Python objects to Int64: \";\n-      RETURN_NOT_OK(InvalidConversion(obj, \"integer\", &ss));\n-      return Status::Invalid(ss.str());\n+      int64_t val;\n+      RETURN_NOT_OK(internal::CIntFromPython(obj, &val));\n+      RETURN_NOT_OK(builder.Append(val));\n     }\n   }\n \n@@ -1102,7 +1046,9 @@ Status NumPyConverter::ConvertObjectsInfer() {\n     PyObject* obj = objects[i];\n     if (internal::PandasObjectIsNull(obj)) {\n       continue;\n-    } else if (PyObject_is_string(obj)) {\n+    } else if (PyUnicode_Check(obj) || internal::IsPyBinary(obj)) {\n+      // The exact Arrow type (Binary or String) will be decided based on\n+      // Python object types\n       return ConvertObjectStrings();\n     } else if (PyFloat_Check(obj)) {\n       return ConvertObjectFloats();\n@@ -1119,8 +1065,6 @@ Status NumPyConverter::ConvertObjectsInfer() {\n       return ConvertTimes();\n     } else if (PyObject_IsInstance(obj, decimal_type_.obj()) == 1) {\n       return ConvertDecimals();\n-    } else if (PyByteArray_Check(obj)) {\n-      return ConvertObjectBytes();\n     } else if (PyList_Check(obj)) {\n       std::shared_ptr<DataType> inferred_type;\n       RETURN_NOT_OK(InferArrowType(obj, &inferred_type));\ndiff --git a/cpp/src/arrow/python/python-test.cc b/cpp/src/arrow/python/python-test.cc\nindex c18b1598f..293255b96 100644\n--- a/cpp/src/arrow/python/python-test.cc\n+++ b/cpp/src/arrow/python/python-test.cc\n@@ -28,6 +28,7 @@\n \n #include \"arrow/python/arrow_to_pandas.h\"\n #include \"arrow/python/builtin_convert.h\"\n+#include \"arrow/python/decimal.h\"\n #include \"arrow/python/helpers.h\"\n \n namespace arrow {\ndiff --git a/cpp/src/arrow/python/python_to_arrow.cc b/cpp/src/arrow/python/python_to_arrow.cc\nindex d781d9f0f..998fa8a8c 100644\n--- a/cpp/src/arrow/python/python_to_arrow.cc\n+++ b/cpp/src/arrow/python/python_to_arrow.cc\n@@ -84,7 +84,9 @@ class SequenceBuilder {\n     if (*tag == -1) {\n       *tag = num_tags_++;\n     }\n-    RETURN_NOT_OK(offsets_.Append(static_cast<int32_t>(offset)));\n+    int32_t offset32;\n+    RETURN_NOT_OK(internal::CastSize(offset, &offset32));\n+    RETURN_NOT_OK(offsets_.Append(offset32));\n     RETURN_NOT_OK(types_.Append(*tag));\n     return nones_.AppendToBitmap(true);\n   }\n@@ -173,26 +175,34 @@ class SequenceBuilder {\n   /// \\param size\n   /// The size of the sublist\n   Status AppendList(Py_ssize_t size) {\n+    int32_t offset;\n+    RETURN_NOT_OK(internal::CastSize(list_offsets_.back() + size, &offset));\n     RETURN_NOT_OK(Update(list_offsets_.size() - 1, &list_tag_));\n-    list_offsets_.push_back(list_offsets_.back() + static_cast<int32_t>(size));\n+    list_offsets_.push_back(offset);\n     return Status::OK();\n   }\n \n   Status AppendTuple(Py_ssize_t size) {\n+    int32_t offset;\n+    RETURN_NOT_OK(internal::CastSize(tuple_offsets_.back() + size, &offset));\n     RETURN_NOT_OK(Update(tuple_offsets_.size() - 1, &tuple_tag_));\n-    tuple_offsets_.push_back(tuple_offsets_.back() + static_cast<int32_t>(size));\n+    tuple_offsets_.push_back(offset);\n     return Status::OK();\n   }\n \n   Status AppendDict(Py_ssize_t size) {\n+    int32_t offset;\n+    RETURN_NOT_OK(internal::CastSize(dict_offsets_.back() + size, &offset));\n     RETURN_NOT_OK(Update(dict_offsets_.size() - 1, &dict_tag_));\n-    dict_offsets_.push_back(dict_offsets_.back() + static_cast<int32_t>(size));\n+    dict_offsets_.push_back(offset);\n     return Status::OK();\n   }\n \n   Status AppendSet(Py_ssize_t size) {\n+    int32_t offset;\n+    RETURN_NOT_OK(internal::CastSize(set_offsets_.back() + size, &offset));\n     RETURN_NOT_OK(Update(set_offsets_.size() - 1, &set_tag_));\n-    set_offsets_.push_back(set_offsets_.back() + static_cast<int32_t>(size));\n+    set_offsets_.push_back(offset);\n     return Status::OK();\n   }\n \n@@ -365,17 +375,8 @@ Status CallCustomCallback(PyObject* context, PyObject* method_name, PyObject* el\n   *result = NULL;\n   if (context == Py_None) {\n     std::stringstream ss;\n-    OwnedRef repr(PyObject_Repr(elem));\n-    RETURN_IF_PYERROR();\n-#if PY_MAJOR_VERSION >= 3\n-    OwnedRef ascii(PyUnicode_AsASCIIString(repr.obj()));\n-    RETURN_IF_PYERROR();\n-    ss << \"error while calling callback on \" << PyBytes_AsString(ascii.obj())\n+    ss << \"error while calling callback on \" << internal::PyObject_StdStringRepr(elem)\n        << \": handler not registered\";\n-#else\n-    ss << \"error while calling callback on \" << PyString_AsString(repr.obj())\n-       << \": handler not registered\";\n-#endif\n     return Status::SerializationError(ss.str());\n   } else {\n     *result = PyObject_CallMethodObjArgs(context, method_name, elem, NULL);\n@@ -483,24 +484,15 @@ Status Append(PyObject* context, PyObject* elem, SequenceBuilder* builder,\n #endif\n   } else if (PyBytes_Check(elem)) {\n     auto data = reinterpret_cast<uint8_t*>(PyBytes_AS_STRING(elem));\n-    const int64_t size = static_cast<int64_t>(PyBytes_GET_SIZE(elem));\n-    if (size > std::numeric_limits<int32_t>::max()) {\n-      return Status::Invalid(\"Cannot writes bytes over 2GB\");\n-    }\n-    RETURN_NOT_OK(builder->AppendBytes(data, static_cast<int32_t>(size)));\n+    int32_t size;\n+    RETURN_NOT_OK(internal::CastSize(PyBytes_GET_SIZE(elem), &size));\n+    RETURN_NOT_OK(builder->AppendBytes(data, size));\n   } else if (PyUnicode_Check(elem)) {\n-    Py_ssize_t size;\n-#if PY_MAJOR_VERSION >= 3\n-    char* data = PyUnicode_AsUTF8AndSize(elem, &size);\n-#else\n-    OwnedRef str(PyUnicode_AsUTF8String(elem));\n-    char* data = PyString_AS_STRING(str.obj());\n-    size = PyString_GET_SIZE(str.obj());\n-#endif\n-    if (size > std::numeric_limits<int32_t>::max()) {\n-      return Status::Invalid(\"Cannot writes bytes over 2GB\");\n-    }\n-    RETURN_NOT_OK(builder->AppendString(data, static_cast<int32_t>(size)));\n+    PyBytesView view;\n+    RETURN_NOT_OK(view.FromString(elem));\n+    int32_t size;\n+    RETURN_NOT_OK(internal::CastSize(view.size, &size));\n+    RETURN_NOT_OK(builder->AppendString(view.bytes, size));\n   } else if (PyList_CheckExact(elem)) {\n     RETURN_NOT_OK(builder->AppendList(PyList_Size(elem)));\n     sublists->push_back(elem);\ndiff --git a/python/pyarrow/lib.pyx b/python/pyarrow/lib.pyx\nindex 672be08df..8929ea09a 100644\n--- a/python/pyarrow/lib.pyx\n+++ b/python/pyarrow/lib.pyx\n@@ -33,10 +33,6 @@ from pyarrow.includes.common cimport PyObject_to_object\n cimport pyarrow.includes.libarrow as libarrow\n cimport cpython as cp\n \n-cdef _pandas():\n-    import pandas as pd\n-    return pd\n-\n arrow_init_numpy()\n set_numpy_nan(np.nan)\n \ndiff --git a/python/pyarrow/tests/test_convert_builtin.py b/python/pyarrow/tests/test_convert_builtin.py\nindex 988d512a8..1c5dd713d 100644\n--- a/python/pyarrow/tests/test_convert_builtin.py\n+++ b/python/pyarrow/tests/test_convert_builtin.py\n@@ -215,6 +215,26 @@ def test_sequence_numpy_integer_inferred(seq, np_scalar_pa_type):\n     assert arr.to_pylist() == expected\n \n \n+@pytest.mark.parametrize(\"bits\", [8, 16, 32, 64])\n+def test_signed_integer_overflow(bits):\n+    ty = getattr(pa, \"int%d\" % bits)()\n+    # XXX ideally would raise OverflowError\n+    with pytest.raises((ValueError, pa.ArrowException)):\n+        pa.array([2 ** (bits - 1)], ty)\n+    with pytest.raises((ValueError, pa.ArrowException)):\n+        pa.array([-2 ** (bits - 1) - 1], ty)\n+\n+\n+@pytest.mark.parametrize(\"bits\", [8, 16, 32, 64])\n+def test_unsigned_integer_overflow(bits):\n+    ty = getattr(pa, \"uint%d\" % bits)()\n+    # XXX ideally would raise OverflowError\n+    with pytest.raises((ValueError, pa.ArrowException)):\n+        pa.array([2 ** bits], ty)\n+    with pytest.raises((ValueError, pa.ArrowException)):\n+        pa.array([-1], ty)\n+\n+\n def test_garbage_collection():\n     import gc\n \n@@ -260,12 +280,14 @@ def test_sequence_bytes():\n     u1 = b'ma\\xc3\\xb1ana'\n     data = [b'foo',\n             u1.decode('utf-8'),  # unicode gets encoded,\n+            bytearray(b'bar'),\n             None]\n-    arr = pa.array(data)\n-    assert len(arr) == 3\n-    assert arr.null_count == 1\n-    assert arr.type == pa.binary()\n-    assert arr.to_pylist() == [b'foo', u1, None]\n+    for ty in [None, pa.binary()]:\n+        arr = pa.array(data, type=ty)\n+        assert len(arr) == 4\n+        assert arr.null_count == 1\n+        assert arr.type == pa.binary()\n+        assert arr.to_pylist() == [b'foo', u1, b'bar', None]\n \n \n def test_sequence_utf8_to_unicode():\n@@ -281,12 +303,12 @@ def test_sequence_utf8_to_unicode():\n \n \n def test_sequence_fixed_size_bytes():\n-    data = [b'foof', None, b'barb', b'2346']\n+    data = [b'foof', None, bytearray(b'barb'), b'2346']\n     arr = pa.array(data, type=pa.binary(4))\n     assert len(arr) == 4\n     assert arr.null_count == 1\n     assert arr.type == pa.binary(4)\n-    assert arr.to_pylist() == data\n+    assert arr.to_pylist() == [b'foof', None, b'barb', b'2346']\n \n \n def test_fixed_size_bytes_does_not_accept_varying_lengths():\n@@ -473,7 +495,7 @@ def test_sequence_mixed_types_with_specified_type_fails():\n     data = ['-10', '-5', {'a': 1}, '0', '5', '10']\n \n     type = pa.string()\n-    with pytest.raises(pa.ArrowInvalid):\n+    with pytest.raises(TypeError):\n         pa.array(data, type=type)\n \n \ndiff --git a/python/pyarrow/tests/test_convert_pandas.py b/python/pyarrow/tests/test_convert_pandas.py\nindex 04b1fa4fa..c6e2b75be 100644\n--- a/python/pyarrow/tests/test_convert_pandas.py\n+++ b/python/pyarrow/tests/test_convert_pandas.py\n@@ -30,7 +30,7 @@\n import pandas as pd\n import pandas.util.testing as tm\n \n-from pyarrow.compat import u, PY2\n+from pyarrow.compat import PY2\n import pyarrow as pa\n import pyarrow.types as patypes\n \n@@ -1065,13 +1065,13 @@ def test_unicode(self):\n         _check_pandas_roundtrip(df, expected_schema=schema)\n \n     def test_bytes_to_binary(self):\n-        values = [u('qux'), b'foo', None, 'bar', 'qux', np.nan]\n+        values = [u'qux', b'foo', None, bytearray(b'barz'), 'qux', np.nan]\n         df = pd.DataFrame({'strings': values})\n \n         table = pa.Table.from_pandas(df)\n         assert table[0].type == pa.binary()\n \n-        values2 = [b'qux', b'foo', None, b'bar', b'qux', np.nan]\n+        values2 = [b'qux', b'foo', None, b'barz', b'qux', np.nan]\n         expected = pd.DataFrame({'strings': values2})\n         _check_pandas_roundtrip(df, expected)\n \n@@ -1093,7 +1093,7 @@ def test_bytes_exceed_2gb(self):\n         assert table[0].data.num_chunks == 2\n \n     def test_fixed_size_bytes(self):\n-        values = [b'foo', None, b'bar', None, None, b'hey']\n+        values = [b'foo', None, bytearray(b'bar'), None, None, b'hey']\n         df = pd.DataFrame({'strings': values})\n         schema = pa.schema([pa.field('strings', pa.binary(3))])\n         table = pa.Table.from_pandas(df, schema=schema)\ndiff --git a/python/pyarrow/tests/test_feather.py b/python/pyarrow/tests/test_feather.py\nindex b0764fdec..a14673f9f 100644\n--- a/python/pyarrow/tests/test_feather.py\n+++ b/python/pyarrow/tests/test_feather.py\n@@ -465,7 +465,7 @@ def test_unsupported(self):\n \n         # non-strings\n         df = pd.DataFrame({'a': ['a', 1, 2.0]})\n-        self._assert_error_on_write(df, ValueError)\n+        self._assert_error_on_write(df, TypeError)\n \n     @pytest.mark.slow\n     def test_large_dataframe(self):\n\n\n \n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-05T13:35:04.304+0000",
                    "updated": "2018-04-05T13:35:04.304+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16426931",
                    "id": "16426931",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "body": "Issue resolved by pull request 1835\n[https://github.com/apache/arrow/pull/1835]",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=apitrou",
                        "name": "apitrou",
                        "key": "pitrou",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?ownerId=pitrou&avatarId=35049",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&ownerId=pitrou&avatarId=35049",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&ownerId=pitrou&avatarId=35049",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&ownerId=pitrou&avatarId=35049"
                        },
                        "displayName": "Antoine Pitrou",
                        "active": true,
                        "timeZone": "Europe/Paris"
                    },
                    "created": "2018-04-05T13:35:08.171+0000",
                    "updated": "2018-04-05T13:35:08.171+0000"
                },
                {
                    "self": "https://issues.apache.org/jira/rest/api/2/issue/13149590/comment/16427361",
                    "id": "16427361",
                    "author": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "body": "BryanCutler commented on issue #1835: ARROW-2380: [Python] Streamline conversions\nURL: https://github.com/apache/arrow/pull/1835#issuecomment-379023958\n \n \n   Thanks @pitrou , looks good!\n\n----------------------------------------------------------------\nThis is an automated message from the Apache Git Service.\nTo respond to the message, please log on GitHub and use the\nURL above to go to the specific comment.\n \nFor queries about this service, please contact Infrastructure at:\nusers@infra.apache.org\n",
                    "updateAuthor": {
                        "self": "https://issues.apache.org/jira/rest/api/2/user?username=githubbot",
                        "name": "githubbot",
                        "key": "githubbot",
                        "avatarUrls": {
                            "48x48": "https://issues.apache.org/jira/secure/useravatar?avatarId=10452",
                            "24x24": "https://issues.apache.org/jira/secure/useravatar?size=small&avatarId=10452",
                            "16x16": "https://issues.apache.org/jira/secure/useravatar?size=xsmall&avatarId=10452",
                            "32x32": "https://issues.apache.org/jira/secure/useravatar?size=medium&avatarId=10452"
                        },
                        "displayName": "ASF GitHub Bot",
                        "active": true,
                        "timeZone": "Etc/UTC"
                    },
                    "created": "2018-04-05T17:59:32.985+0000",
                    "updated": "2018-04-05T17:59:32.985+0000"
                }
            ],
            "maxResults": 8,
            "total": 8,
            "startAt": 0
        },
        "customfield_12311820": "0|i3s2db:",
        "customfield_12314139": null
    }
}